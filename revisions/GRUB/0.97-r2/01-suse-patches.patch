diff -Naur grub-0.97/Makefile.am grub-0.97-suse/Makefile.am
--- grub-0.97/Makefile.am	2004-04-27 17:48:06.000000000 -0300
+++ grub-0.97-suse/Makefile.am	2006-09-09 17:00:12.000000000 -0300
@@ -2,3 +2,4 @@
 AUTOMAKE_OPTIONS = 1.7 gnu
 SUBDIRS = netboot stage2 stage1 lib grub util docs
 EXTRA_DIST = BUGS MAINTENANCE
+pkgdatadir=$(datadir)
diff -Naur grub-0.97/Makefile.am~ grub-0.97-suse/Makefile.am~
--- grub-0.97/Makefile.am~	1969-12-31 21:00:00.000000000 -0300
+++ grub-0.97-suse/Makefile.am~	2004-04-27 17:48:06.000000000 -0300
@@ -0,0 +1,4 @@
+# Do not change this order if you don't know what you are doing.
+AUTOMAKE_OPTIONS = 1.7 gnu
+SUBDIRS = netboot stage2 stage1 lib grub util docs
+EXTRA_DIST = BUGS MAINTENANCE
diff -Naur grub-0.97/docs/grub.texi grub-0.97-suse/docs/grub.texi
--- grub-0.97/docs/grub.texi	2005-05-07 23:59:59.000000000 -0300
+++ grub-0.97-suse/docs/grub.texi	2006-09-09 17:00:12.000000000 -0300
@@ -2118,6 +2118,7 @@
 * default::                     Set the default entry
 * fallback::                    Set the fallback entry
 * hiddenmenu::                  Hide the menu interface
+* gfxmenu::                     Use graphical menu interface
 * timeout::                     Set the timeout
 * title::                       Start a menu entry
 @end menu
@@ -2150,6 +2151,15 @@
 @end deffn
 
 
+@node gfxmenu
+@subsection gfxmenu
+
+@deffn Command gfxmenu file
+Use the graphical menu interface. The graphics data are taken from
+@var{file} and must be created using 'mkbootmsg' from the gfxboot package.
+@end deffn
+
+
 @node hiddenmenu
 @subsection hiddenmenu
 
@@ -2909,7 +2919,7 @@
 @node install
 @subsection install
 
-@deffn Command install [@option{--force-lba}] [@option{--stage2=os_stage2_file}] stage1_file [@option{d}] dest_dev stage2_file [addr] [@option{p}] [config_file] [real_config_file]
+@deffn Command install [@option{--force-lba[=off]}] [@option{--stage2=os_stage2_file}] stage1_file [@option{d}] dest_dev stage2_file [addr] [@option{p}] [config_file] [real_config_file]
 This command is fairly complex, and you should not use this command
 unless you are familiar with GRUB. Use @command{setup} (@pxref{setup})
 instead.
@@ -2956,6 +2966,13 @@
 bitmap even if they do have the support. So GRUB provides a solution to
 ignore the wrong bitmap, that is, the option @option{--force-lba}. Don't
 use this option if you know that your BIOS doesn't have LBA support.
+On the other hand there is at least one known BIOS that does the opposite,
+it claims to support LBA and then fails to provide it. Iff you have an
+Adaptec 2940 with BIOS revision 1.21 ( newer ones just work and older ones
+don't make the false claim ), or otherwise experience grub hanging
+after stage1, you can try to use the option @option{--force-lba=off},
+as long as all disk blocks involved in booting reside
+within the first 1024 cylinders.
 
 @strong{Caution3:} You must specify the option @option{--stage2} in the
 grub shell, if you cannot unmount the filesystem where your stage2 file
diff -Naur grub-0.97/docs/grub.texi~ grub-0.97-suse/docs/grub.texi~
--- grub-0.97/docs/grub.texi~	1969-12-31 21:00:00.000000000 -0300
+++ grub-0.97-suse/docs/grub.texi~	2006-09-09 17:00:12.000000000 -0300
@@ -0,0 +1,3994 @@
+\input texinfo
+@c -*-texinfo-*-
+@c %**start of header
+@setfilename grub.info
+@settitle GRUB Manual
+@c %**end of header
+
+@include version.texi
+
+@c Unify all our little indices for now.
+@syncodeindex fn cp
+@syncodeindex vr cp
+@syncodeindex ky cp
+@syncodeindex pg cp
+@syncodeindex tp cp
+
+@footnotestyle separate
+@paragraphindent 3
+@finalout
+
+@dircategory Kernel
+@direntry
+* GRUB: (grub).                 The GRand Unified Bootloader
+* grub-install: (grub)Invoking grub-install.    Install GRUB on your drive
+* grub-md5-crypt: (grub)Invoking grub-md5-crypt.        Encrypt a password
+                                                        in MD5 format
+* grub-terminfo: (grub)Invoking grub-terminfo.  Generate a terminfo
+                                                command from a
+                                                terminfo name
+* grub-set-default: (grub)Invoking grub-set-default.    Set a default boot
+                                                        entry
+* mbchk: (grub)Invoking mbchk.  Check for the format of a Multiboot kernel
+@end direntry
+
+@setchapternewpage odd
+
+@ifinfo
+Copyright @copyright{} 1999,2000,2001,2002,2004 Free Software Foundation, Inc.
+
+Permission is granted to make and distribute verbatim copies of
+this manual provided the copyright notice and this permission notice
+are preserved on all copies.
+
+@ignore
+Permission is granted to process this file through TeX and print the
+results, provided the printed document carries a copying permission
+notice identical to this one except for the removal of this paragraph
+(this paragraph not being relevant to the printed manual).
+
+@end ignore
+
+Permission is granted to copy and distribute modified versions of this
+manual under the conditions for verbatim copying, provided also that
+the entire resulting derived work is distributed under the terms of a
+permission notice identical to this one.
+
+Permission is granted to copy and distribute translations of this manual
+into another language, under the above conditions for modified versions.
+@end ifinfo
+
+@titlepage
+@sp 10
+@title the GRUB manual
+@subtitle The GRand Unified Bootloader, version @value{VERSION}, @value{UPDATED}.
+@author Gordon Matzigkeit
+@author Yoshinori K. Okuji
+@c The following two commands start the copyright page.
+@page
+@vskip 0pt plus 1filll
+Copyright @copyright{} 1999,2000,2001,2002,2004 Free Software Foundation, Inc.
+
+Permission is granted to make and distribute verbatim copies of
+this manual provided the copyright notice and this permission notice
+are preserved on all copies.
+Permission is granted to copy and distribute modified versions of this
+manual under the conditions for verbatim copying, provided that the entire
+resulting derived work is distributed under the terms of a permission
+notice identical to this one.
+
+Permission is granted to copy and distribute translations of this manual
+into another language, under the above conditions for modified versions,
+except that this permission notice may be stated in a translation approved
+by Free Software Foundation.
+@end titlepage
+
+@c Output the table of contents at the beginning.
+@contents
+
+@finalout
+@headings double
+
+@ifnottex
+@node Top
+@top GRUB manual
+
+This is the documentation of GNU GRUB, the GRand Unified Bootloader,
+a flexible and powerful boot loader program for @sc{pc}s.
+
+This edition documents version @value{VERSION}.
+@end ifnottex
+
+@menu
+* Introduction::                Capturing the spirit of GRUB
+* Naming convention::           Names of your drives in GRUB
+* Installation::                Installing GRUB on your drive
+* Booting::                     How to boot different operating systems
+* Configuration::               Writing your own configuration file
+* Network::                     Downloading OS images from a network
+* Serial terminal::             Using GRUB via a serial line
+* Preset Menu::                 Embedding a configuration file into GRUB
+* Security::                    Improving the security
+* Images::                      GRUB image files
+* Filesystem::                  Filesystem syntax and semantics
+* Interface::                   The menu and the command-line
+* Commands::                    The list of available builtin commands
+* Troubleshooting::             Error messages produced by GRUB
+* Invoking the grub shell::     How to use the grub shell
+* Invoking grub-install::       How to use the GRUB installer
+* Invoking grub-md5-crypt::     How to generate a cryptic password
+* Invoking grub-terminfo::      How to generate a terminfo command
+* Invoking grub-set-default::   How to set a default boot entry
+* Invoking mbchk::              How to use the Multiboot checker
+* Obtaining and Building GRUB:: How to obtain and build GRUB
+* Reporting bugs::              Where you should send a bug report
+* Future::                      Some future plans on GRUB
+* Internals::                   Hacking GRUB
+* Index::
+@end menu
+
+
+@node Introduction
+@chapter Introduction to GRUB
+
+@menu
+* Overview::                    What exactly GRUB is and how to use it
+* History::                     From maggot to house fly
+* Features::                    GRUB features
+* Role of a boot loader::       The role of a boot loader
+@end menu
+
+
+@node Overview
+@section Overview
+
+Briefly, a @dfn{boot loader} is the first software program that runs when
+a computer starts.  It is responsible for loading and transferring
+control to an operating system @dfn{kernel} software (such as Linux or
+GNU Mach).  The kernel, in turn, initializes the rest of the operating
+system (e.g. a GNU system).
+
+GNU GRUB is a very powerful boot loader, which can load a wide variety
+of free operating systems, as well as proprietary operating systems with
+chain-loading@footnote{@dfn{chain-load} is the mechanism for loading
+unsupported operating systems by loading another boot loader. It is
+typically used for loading DOS or Windows.}. GRUB is designed to
+address the complexity of booting a personal computer; both the
+program and this manual are tightly bound to that computer platform,
+although porting to other platforms may be addressed in the future.
+
+One of the important features in GRUB is flexibility; GRUB understands
+filesystems and kernel executable formats, so you can load an arbitrary
+operating system the way you like, without recording the physical
+position of your kernel on the disk. Thus you can load the kernel
+just by specifying its file name and the drive and partition where the
+kernel resides.
+
+When booting with GRUB, you can use either a command-line interface
+(@pxref{Command-line interface}), or a menu interface (@pxref{Menu
+interface}). Using the command-line interface, you type the drive
+specification and file name of the kernel manually. In the menu
+interface, you just select an OS using the arrow keys. The menu is
+based on a configuration file which you prepare beforehand
+(@pxref{Configuration}). While in the menu, you can switch to the
+command-line mode, and vice-versa. You can even edit menu entries
+before using them.
+
+In the following chapters, you will learn how to specify a drive, a
+partition, and a file name (@pxref{Naming convention}) to GRUB, how to
+install GRUB on your drive (@pxref{Installation}), and how to boot your
+OSes (@pxref{Booting}), step by step.
+
+Besides the GRUB boot loader itself, there is a @dfn{grub shell}
+@command{grub} (@pxref{Invoking the grub shell}) which can be run when
+you are in your operating system. It emulates the boot loader and can
+be used for installing the boot loader.
+
+
+@node History
+@section History of GRUB
+
+GRUB originated in 1995 when Erich Boleyn was trying to boot the GNU
+Hurd with the University of Utah's Mach 4 microkernel (now known as GNU
+Mach).  Erich and Brian Ford designed the Multiboot Specification
+(@pxref{Top, Multiboot Specification, Motivation, multiboot, The Multiboot
+Specification}), because they were determined not to add to the large
+number of mutually-incompatible PC boot methods.
+
+Erich then began modifying the FreeBSD boot loader so that it would
+understand Multiboot. He soon realized that it would be a lot easier
+to write his own boot loader from scratch than to keep working on the
+FreeBSD boot loader, and so GRUB was born.
+
+Erich added many features to GRUB, but other priorities prevented him
+from keeping up with the demands of its quickly-expanding user base. In
+1999, Gordon Matzigkeit and Yoshinori K. Okuji adopted GRUB as an
+official GNU package, and opened its development by making the latest
+sources available via anonymous CVS. @xref{Obtaining and Building
+GRUB}, for more information.
+
+
+@node Features
+@section GRUB features
+
+The primary requirement for GRUB is that it be compliant with the
+@dfn{Multiboot Specification}, which is described in @ref{Top, Multiboot
+Specification, Motivation, multiboot, The Multiboot Specification}.
+
+The other goals, listed in approximate order of importance, are:
+
+@itemize @bullet{}
+@item
+Basic functions must be straightforward for end-users.
+
+@item
+Rich functionality to support kernel experts and designers.
+
+@item
+Backward compatibility for booting FreeBSD, NetBSD, OpenBSD, and
+Linux. Proprietary kernels (such as DOS, Windows NT, and OS/2) are
+supported via a chain-loading function.
+@end itemize
+
+Except for specific compatibility modes (chain-loading and the Linux
+@dfn{piggyback} format), all kernels will be started in much the same
+state as in the Multiboot Specification. Only kernels loaded at 1 megabyte
+or above are presently supported. Any attempt to load below that
+boundary will simply result in immediate failure and an error message
+reporting the problem.
+
+In addition to the requirements above, GRUB has the following features
+(note that the Multiboot Specification doesn't require all the features
+that GRUB supports):
+
+@table @asis
+@item Recognize multiple executable formats
+Support many of the @dfn{a.out} variants plus @dfn{ELF}. Symbol
+tables are also loaded.
+
+@item Support non-Multiboot kernels
+Support many of the various free 32-bit kernels that lack Multiboot
+compliance (primarily FreeBSD, NetBSD, OpenBSD, and
+Linux). Chain-loading of other boot loaders is also supported.
+
+@item Load multiples modules
+Fully support the Multiboot feature of loading multiple modules.
+
+@item Load a configuration file
+Support a human-readable text configuration file with preset boot
+commands. You can also load another configuration file dynamically and
+embed a preset configuration file in a GRUB image file. The list of
+commands (@pxref{Commands}) are a superset of those supported on the
+command-line. An example configuration file is provided in
+@ref{Configuration}.
+
+@item Provide a menu interface
+A menu interface listing preset boot commands, with a programmable
+timeout, is available. There is no fixed limit on the number of boot
+entries, and the current implementation has space for several hundred.
+
+@item Have a flexible command-line interface
+A fairly flexible command-line interface, accessible from the menu,
+is available to edit any preset commands, or write a new boot command
+set from scratch. If no configuration file is present, GRUB drops to
+the command-line.
+
+The list of commands (@pxref{Commands}) are a subset of those supported
+for configuration files. Editing commands closely resembles the Bash
+command-line (@pxref{Command Line Editing, Bash, Command Line Editing,
+features, Bash Features}), with @key{TAB}-completion of commands,
+devices, partitions, and files in a directory depending on context.
+
+@item Support multiple filesystem types
+Support multiple filesystem types transparently, plus a useful explicit
+blocklist notation. The currently supported filesystem types are
+@dfn{BSD FFS}, @dfn{DOS FAT16 and FAT32}, @dfn{Minix fs}, @dfn{Linux
+ext2fs}, @dfn{ReiserFS}, @dfn{JFS}, @dfn{XFS}, and @dfn{VSTa
+fs}. @xref{Filesystem}, for more information.
+
+@item Support automatic decompression
+Can decompress files which were compressed by @command{gzip}. This
+function is both automatic and transparent to the user (i.e. all
+functions operate upon the uncompressed contents of the specified
+files). This greatly reduces a file size and loading time, a
+particularly great benefit for floppies.@footnote{There are a few
+pathological cases where loading a very badly organized ELF kernel might
+take longer, but in practice this never happen.}
+
+It is conceivable that some kernel modules should be loaded in a
+compressed state, so a different module-loading command can be specified
+to avoid uncompressing the modules.
+
+@item Access data on any installed device
+Support reading data from any or all floppies or hard disk(s) recognized
+by the BIOS, independent of the setting of the root device.
+
+@item Be independent of drive geometry translations
+Unlike many other boot loaders, GRUB makes the particular drive
+translation irrelevant. A drive installed and running with one
+translation may be converted to another translation without any adverse
+effects or changes in GRUB's configuration.
+
+@item Detect all installed @sc{ram}
+GRUB can generally find all the installed @sc{ram} on a PC-compatible
+machine. It uses an advanced BIOS query technique for finding all
+memory regions. As described on the Multiboot Specification (@pxref{Top,
+Multiboot Specification, Motivation, multiboot, The Multiboot
+Specification}), not all kernels make use of this information, but GRUB
+provides it for those who do.
+
+@item Support Logical Block Address mode
+In traditional disk calls (called @dfn{CHS mode}), there is a geometry
+translation problem, that is, the BIOS cannot access over 1024
+cylinders, so the accessible space is limited to at least 508 MB and to
+at most 8GB. GRUB can't universally solve this problem, as there is no
+standard interface used in all machines. However, several newer machines
+have the new interface, Logical Block Address (@dfn{LBA}) mode. GRUB
+automatically detects if LBA mode is available and uses it if
+available. In LBA mode, GRUB can access the entire disk.
+
+@item Support network booting
+GRUB is basically a disk-based boot loader but also has network
+support. You can load OS images from a network by using the @dfn{TFTP}
+protocol.
+
+@item Support remote terminals
+To support computers with no console, GRUB provides remote terminal
+support, so that you can control GRUB from a remote host. Only serial
+terminal support is implemented at the moment.
+@end table
+
+
+@node Role of a boot loader
+@section The role of a boot loader
+
+The following is a quotation from Gordon Matzigkeit, a GRUB fanatic:
+
+@quotation
+Some people like to acknowledge both the operating system and kernel when
+they talk about their computers, so they might say they use
+``GNU/Linux'' or ``GNU/Hurd''.  Other people seem to think that the
+kernel is the most important part of the system, so they like to call
+their GNU operating systems ``Linux systems.''
+
+I, personally, believe that this is a grave injustice, because the
+@emph{boot loader} is the most important software of all. I used to
+refer to the above systems as either ``LILO''@footnote{The LInux LOader,
+a boot loader that everybody uses, but nobody likes.} or ``GRUB''
+systems.
+
+Unfortunately, nobody ever understood what I was talking about; now I
+just use the word ``GNU'' as a pseudonym for GRUB.
+
+So, if you ever hear people talking about their alleged ``GNU'' systems,
+remember that they are actually paying homage to the best boot loader
+around@dots{} GRUB!
+@end quotation
+
+We, the GRUB maintainers, do not (usually) encourage Gordon's level of
+fanaticism, but it helps to remember that boot loaders deserve
+recognition.  We hope that you enjoy using GNU GRUB as much as we did
+writing it.
+
+
+@node Naming convention
+@chapter Naming convention
+
+The device syntax used in GRUB is a wee bit different from what you may
+have seen before in your operating system(s), and you need to know it so
+that you can specify a drive/partition.
+
+Look at the following examples and explanations:
+
+@example
+(fd0)
+@end example
+
+First of all, GRUB requires that the device name be enclosed with
+@samp{(} and @samp{)}. The @samp{fd} part means that it is a floppy
+disk. The number @samp{0} is the drive number, which is counted from
+@emph{zero}. This expression means that GRUB will use the whole floppy
+disk.
+
+@example
+(hd0,1)
+@end example
+
+Here, @samp{hd} means it is a hard disk drive. The first integer
+@samp{0} indicates the drive number, that is, the first hard disk, while
+the second integer, @samp{1}, indicates the partition number (or the
+@sc{pc} slice number in the BSD terminology). Once again, please note
+that the partition numbers are counted from @emph{zero}, not from
+one. This expression means the second partition of the first hard disk
+drive. In this case, GRUB uses one partition of the disk, instead of the
+whole disk.
+
+@example
+(hd0,4)
+@end example
+
+This specifies the first @dfn{extended partition} of the first hard disk
+drive. Note that the partition numbers for extended partitions are
+counted from @samp{4}, regardless of the actual number of primary
+partitions on your hard disk.
+
+@example
+(hd1,a)
+@end example
+
+This means the BSD @samp{a} partition of the second hard disk. If you
+need to specify which @sc{pc} slice number should be used, use something
+like this: @samp{(hd1,0,a)}. If the @sc{pc} slice number is omitted,
+GRUB searches for the first @sc{pc} slice which has a BSD @samp{a}
+partition.
+
+Of course, to actually access the disks or partitions with GRUB, you
+need to use the device specification in a command, like @samp{root
+(fd0)} or @samp{unhide (hd0,2)}. To help you find out which number
+specifies a partition you want, the GRUB command-line
+(@pxref{Command-line interface}) options have argument
+completion. This means that, for example, you only need to type
+
+@example
+root (
+@end example
+
+followed by a @key{TAB}, and GRUB will display the list of drives,
+partitions, or file names. So it should be quite easy to determine the
+name of your target partition, even with minimal knowledge of the
+syntax.
+
+Note that GRUB does @emph{not} distinguish IDE from SCSI - it simply
+counts the drive numbers from zero, regardless of their type. Normally,
+any IDE drive number is less than any SCSI drive number, although that
+is not true if you change the boot sequence by swapping IDE and SCSI
+drives in your BIOS.
+
+Now the question is, how to specify a file? Again, consider an
+example:
+
+@example
+(hd0,0)/vmlinuz
+@end example
+
+This specifies the file named @samp{vmlinuz}, found on the first
+partition of the first hard disk drive. Note that the argument
+completion works with file names, too.
+
+That was easy, admit it. Now read the next chapter, to find out how to
+actually install GRUB on your drive.
+
+
+@node Installation
+@chapter Installation
+
+In order to install GRUB as your boot loader, you need to first
+install the GRUB system and utilities under your UNIX-like operating
+system (@pxref{Obtaining and Building GRUB}). You can do this either
+from the source tarball, or as a package for your OS.
+
+After you have done that, you need to install the boot loader on a
+drive (floppy or hard disk). There are two ways of doing that - either
+using the utility @command{grub-install} (@pxref{Invoking
+grub-install}) on a UNIX-like OS, or by running GRUB itself from a
+floppy. These are quite similar, however the utility might probe a
+wrong BIOS drive, so you should be careful.
+
+Also, if you install GRUB on a UNIX-like OS, please make sure that you
+have an emergency boot disk ready, so that you can rescue your computer
+if, by any chance, your hard drive becomes unusable (unbootable).
+
+GRUB comes with boot images, which are normally put in the directory
+@file{/usr/lib/grub/i386-pc}. If you do not use grub-install, then
+you need to copy the files @file{stage1}, @file{stage2}, and
+@file{*stage1_5} to the directory @file{/boot/grub}, and run the
+@command{grub-set-default} (@pxref{Invoking grub-set-default}) if you
+intend to use @samp{default saved} (@pxref{default}) in your
+configuration file. Hereafter, the directory where GRUB images are
+initially placed (normally @file{/usr/lib/grub/i386-pc}) will be
+called the @dfn{image directory}, and the directory where the boot
+loader needs to find them (usually @file{/boot/grub}) will be called
+the @dfn{boot directory}.
+
+@menu
+* Creating a GRUB boot floppy::
+* Installing GRUB natively::
+* Installing GRUB using grub-install::
+* Making a GRUB bootable CD-ROM::
+@end menu
+
+
+@node Creating a GRUB boot floppy
+@section Creating a GRUB boot floppy
+
+To create a GRUB boot floppy, you need to take the files @file{stage1}
+and @file{stage2} from the image directory, and write them to the first
+and the second block of the floppy disk, respectively.
+
+@strong{Caution:} This procedure will destroy any data currently stored
+on the floppy.
+
+On a UNIX-like operating system, that is done with the following
+commands:
+
+@example
+@group
+# @kbd{cd /usr/lib/grub/i386-pc}
+# @kbd{dd if=stage1 of=/dev/fd0 bs=512 count=1}
+1+0 records in
+1+0 records out
+# @kbd{dd if=stage2 of=/dev/fd0 bs=512 seek=1}
+153+1 records in
+153+1 records out
+#
+@end group
+@end example
+
+The device file name may be different. Consult the manual for your OS.
+
+
+@node Installing GRUB natively
+@section Installing GRUB natively
+
+@strong{Caution:} Installing GRUB's stage1 in this manner will erase the
+normal boot-sector used by an OS.
+
+GRUB can currently boot GNU Mach, Linux, FreeBSD, NetBSD, and OpenBSD
+directly, so using it on a boot sector (the first sector of a
+partition) should be okay. But generally, it would be a good idea to
+back up the first sector of the partition on which you are installing
+GRUB's stage1. This isn't as important if you are installing GRUB on
+the first sector of a hard disk, since it's easy to reinitialize it
+(e.g. by running @samp{FDISK /MBR} from DOS).
+
+If you decide to install GRUB in the native environment, which is
+definitely desirable, you'll need to create a GRUB boot disk, and
+reboot your computer with it. Otherwise, see @ref{Installing GRUB using
+grub-install}.
+
+Once started, GRUB will show the command-line interface
+(@pxref{Command-line interface}). First, set the GRUB's @dfn{root
+device}@footnote{Note that GRUB's root device doesn't necessarily mean
+your OS's root partition; if you need to specify a root partition for
+your OS, add the argument into the command @command{kernel}.} to the
+partition containing the boot directory, like this:
+
+@example
+grub> @kbd{root (hd0,0)}
+@end example
+
+If you are not sure which partition actually holds this directory, use the
+command @command{find} (@pxref{find}), like this:
+
+@example
+grub> @kbd{find /boot/grub/stage1}
+@end example
+
+This will search for the file name @file{/boot/grub/stage1} and show the
+devices which contain the file.
+
+Once you've set the root device correctly, run the command
+@command{setup} (@pxref{setup}):
+
+@example
+grub> @kbd{setup (hd0)}
+@end example
+
+This command will install the GRUB boot loader on the Master Boot
+Record (MBR) of the first drive. If you want to put GRUB into the boot
+sector of a partition instead of putting it in the MBR, specify the
+partition into which you want to install GRUB:
+
+@example
+grub> @kbd{setup (hd0,0)}
+@end example
+
+If you install GRUB into a partition or a drive other than the first
+one, you must chain-load GRUB from another boot loader. Refer to the
+manual for the boot loader to know how to chain-load GRUB.
+
+After using the setup command, you will boot into GRUB without the
+GRUB floppy. See the chapter @ref{Booting} to find out how to boot
+your operating systems from GRUB.
+
+
+@node Installing GRUB using grub-install
+@section Installing GRUB using grub-install
+
+@strong{Caution:} This procedure is definitely less safe, because
+there are several ways in which your computer can become
+unbootable. For example, most operating systems don't tell GRUB how to
+map BIOS drives to OS devices correctly---GRUB merely @dfn{guesses}
+the mapping. This will succeed in most cases, but not
+always. Therefore, GRUB provides you with a map file called the
+@dfn{device map}, which you must fix if it is wrong. @xref{Device
+map}, for more details.
+
+If you still do want to install GRUB under a UNIX-like OS (such
+as @sc{gnu}), invoke the program @command{grub-install} (@pxref{Invoking
+grub-install}) as the superuser (@dfn{root}).
+
+The usage is basically very simple. You only need to specify one
+argument to the program, namely, where to install the boot loader. The
+argument can be either a device file (like @samp{/dev/hda}) or a
+partition specified in GRUB's notation. For example, under Linux the
+following will install GRUB into the MBR of the first IDE disk:
+
+@example
+# @kbd{grub-install /dev/hda}
+@end example
+
+Likewise, under GNU/Hurd, this has the same effect:
+
+@example
+# @kbd{grub-install /dev/hd0}
+@end example
+
+If it is the first BIOS drive, this is the same as well:
+
+@example
+# @kbd{grub-install '(hd0)'}
+@end example
+
+Or you can omit the parentheses:
+
+@example
+# @kbd{grub-install hd0}
+@end example
+
+But all the above examples assume that GRUB should use images under
+the root directory. If you want GRUB to use images under a directory
+other than the root directory, you need to specify the option
+@option{--root-directory}. The typical usage is that you create a GRUB
+boot floppy with a filesystem. Here is an example:
+
+@example
+@group
+# @kbd{mke2fs /dev/fd0}
+# @kbd{mount -t ext2 /dev/fd0 /mnt}
+# @kbd{grub-install --root-directory=/mnt fd0}
+# @kbd{umount /mnt}
+@end group
+@end example
+
+Another example is when you have a separate boot partition
+which is mounted at @file{/boot}. Since GRUB is a boot loader, it
+doesn't know anything about mountpoints at all. Thus, you need to run
+@command{grub-install} like this:
+
+@example
+# @kbd{grub-install --root-directory=/boot /dev/hda}
+@end example
+
+By the way, as noted above, it is quite difficult to guess BIOS drives
+correctly under a UNIX-like OS. Thus, @command{grub-install} will prompt
+you to check if it could really guess the correct mappings, after the
+installation. The format is defined in @ref{Device map}. Please be
+quite careful. If the output is wrong, it is unlikely that your
+computer will be able to boot with no problem.
+
+Note that @command{grub-install} is actually just a shell script and the
+real task is done by the grub shell @command{grub} (@pxref{Invoking the
+grub shell}). Therefore, you may run @command{grub} directly to install
+GRUB, without using @command{grub-install}. Don't do that, however,
+unless you are very familiar with the internals of GRUB. Installing a
+boot loader on a running OS may be extremely dangerous.
+
+
+@node Making a GRUB bootable CD-ROM
+@section Making a GRUB bootable CD-ROM
+
+GRUB supports the @dfn{no emulation mode} in the El Torito
+specification@footnote{El Torito is a specification for bootable CD
+using BIOS functions.}. This means that you can use the whole CD-ROM
+from GRUB and you don't have to make a floppy or hard disk image file,
+which can cause compatibility problems.
+
+For booting from a CD-ROM, GRUB uses a special Stage 2 called
+@file{stage2_eltorito}. The only GRUB files you need to have in your 
+bootable CD-ROM are this @file{stage2_eltorito} and optionally a config file
+@file{menu.lst}. You don't need to use @file{stage1} or @file{stage2},
+because El Torito is quite different from the standard boot process.
+
+Here is an example of procedures to make a bootable CD-ROM
+image. First, make a top directory for the bootable image, say,
+@samp{iso}:
+
+@example
+$ @kbd{mkdir iso}
+@end example
+
+Make a directory for GRUB:
+
+@example
+$ @kbd{mkdir -p iso/boot/grub}
+@end example
+
+Copy the file @file{stage2_eltorito}:
+
+@example
+$ @kbd{cp /usr/lib/grub/i386-pc/stage2_eltorito iso/boot/grub}
+@end example
+
+If desired, make the config file @file{menu.lst} under @file{iso/boot/grub}
+(@pxref{Configuration}), and copy any files and directories for the disc to the
+directory @file{iso/}.
+
+Finally, make a ISO9660 image file like this:
+
+@example
+$ @kbd{mkisofs -R -b boot/grub/stage2_eltorito -no-emul-boot \
+    -boot-load-size 4 -boot-info-table -o grub.iso iso}
+@end example
+
+This produces a file named @file{grub.iso}, which then can be burned
+into a CD (or a DVD).  @kbd{mkisofs} has already set up the disc to boot
+from the @kbd{boot/grub/stage2_eltorito} file, so there is no need to 
+setup GRUB on the disc.  (Note that the @kbd{-boot-load-size 4} bit is
+required for compatibility with the BIOS on many older machines.)
+
+You can use the device @samp{(cd)} to access a CD-ROM in your
+config file. This is not required; GRUB automatically sets the root device 
+to @samp{(cd)} when booted from a CD-ROM. It is only necessary to refer to 
+@samp{(cd)} if you want to access other drives as well.
+
+
+@node Booting
+@chapter Booting
+
+GRUB can load Multiboot-compliant kernels in a consistent way,
+but for some free operating systems you need to use some OS-specific
+magic.
+
+@menu
+* General boot methods::        How to boot OSes with GRUB generally
+* OS-specific notes::           Notes on some operating systems
+* Making your system robust::   How to make your system robust
+@end menu
+
+
+@node General boot methods
+@section How to boot operating systems
+
+GRUB has two distinct boot methods. One of the two is to load an
+operating system directly, and the other is to chain-load another boot
+loader which then will load an operating system actually. Generally
+speaking, the former is more desirable, because you don't need to
+install or maintain other boot loaders and GRUB is flexible enough to
+load an operating system from an arbitrary disk/partition. However,
+the latter is sometimes required, since GRUB doesn't support all the
+existing operating systems natively.
+
+@menu
+* Loading an operating system directly::
+* Chain-loading::
+@end menu
+
+
+@node Loading an operating system directly
+@subsection How to boot an OS directly with GRUB
+
+Multiboot (@pxref{Top, Multiboot Specification, Motivation, multiboot,
+The Multiboot Specification}) is the native format supported by GRUB.
+For the sake of convenience, there is also support for Linux, FreeBSD,
+NetBSD and OpenBSD. If you want to boot other operating systems, you
+will have to chain-load them (@pxref{Chain-loading}).
+
+Generally, GRUB can boot any Multiboot-compliant OS in the following
+steps:
+
+@enumerate
+@item
+Set GRUB's root device to the drive where the OS images are stored with
+the command @command{root} (@pxref{root}).
+
+@item
+Load the kernel image with the command @command{kernel} (@pxref{kernel}).
+
+@item
+If you need modules, load them with the command @command{module}
+(@pxref{module}) or @command{modulenounzip} (@pxref{modulenounzip}).
+
+@item
+Run the command @command{boot} (@pxref{boot}).
+@end enumerate
+
+Linux, FreeBSD, NetBSD and OpenBSD can be booted in a similar
+manner. You load a kernel image with the command @command{kernel} and
+then run the command @command{boot}. If the kernel requires some
+parameters, just append the parameters to @command{kernel}, after the
+file name of the kernel. Also, please refer to @ref{OS-specific notes},
+for information on your OS-specific issues.
+
+
+@node Chain-loading
+@subsection Load another boot loader to boot unsupported operating systems
+
+If you want to boot an unsupported operating system (e.g. Windows 95),
+chain-load a boot loader for the operating system. Normally, the boot
+loader is embedded in the @dfn{boot sector} of the partition on which
+the operating system is installed.
+
+@enumerate
+@item
+Set GRUB's root device to the partition by the command
+@command{rootnoverify} (@pxref{rootnoverify}):
+
+@example
+grub> @kbd{rootnoverify (hd0,0)}
+@end example
+
+@item
+Set the @dfn{active} flag in the partition using the command
+@command{makeactive}@footnote{This is not necessary for most of the
+modern operating systems.} (@pxref{makeactive}):
+
+@example
+grub> @kbd{makeactive}
+@end example
+
+@item
+Load the boot loader with the command @command{chainloader}
+(@pxref{chainloader}):
+
+@example
+grub> @kbd{chainloader +1}
+@end example
+
+@samp{+1} indicates that GRUB should read one sector from the start of
+the partition. The complete description about this syntax can be found
+in @ref{Block list syntax}.
+
+@item
+Run the command @command{boot} (@pxref{boot}).
+@end enumerate
+
+However, DOS and Windows have some deficiencies, so you might have to
+use more complicated instructions. @xref{DOS/Windows}, for more
+information.
+
+
+@node OS-specific notes
+@section Some caveats on OS-specific issues
+
+Here, we describe some caveats on several operating systems.
+
+@menu
+* GNU/Hurd::
+* GNU/Linux::
+* FreeBSD::
+* NetBSD::
+* OpenBSD::
+* DOS/Windows::
+* SCO UnixWare::
+* QNX::
+@end menu
+
+
+@node GNU/Hurd
+@subsection GNU/Hurd
+
+Since GNU/Hurd is Multiboot-compliant, it is easy to boot it; there is
+nothing special about it. But do not forget that you have to specify a
+root partition to the kernel.
+
+@enumerate
+@item
+Set GRUB's root device to the same drive as GNU/Hurd's. Probably the
+command @code{find /boot/gnumach} or similar can help you
+(@pxref{find}).
+
+@item
+Load the kernel and the module, like this:
+
+@example
+@group
+grub> @kbd{kernel /boot/gnumach root=hd0s1}
+grub> @kbd{module /boot/serverboot}
+@end group
+@end example
+
+@item
+Run the command @command{boot} (@pxref{boot}).
+@end enumerate
+
+
+@node GNU/Linux
+@subsection GNU/Linux
+
+It is relatively easy to boot GNU/Linux from GRUB, because it somewhat
+resembles to boot a Multiboot-compliant OS.
+
+@enumerate
+@item
+Set GRUB's root device to the same drive as GNU/Linux's. Probably the
+command @code{find /vmlinuz} or similar can help you (@pxref{find}).
+
+@item
+Load the kernel:
+
+@example
+grub> @kbd{kernel /vmlinuz root=/dev/hda1}
+@end example
+
+If you need to specify some kernel parameters, just append them to the
+command. For example, to set @option{vga} to @samp{ext}, do this:
+
+@example
+grub> @kbd{kernel /vmlinuz root=/dev/hda1 vga=ext}
+@end example
+
+See the documentation in the Linux source tree for complete
+information on the available options.
+
+@item
+If you use an initrd, execute the command @command{initrd}
+(@pxref{initrd}) after @command{kernel}:
+
+@example
+grub> @kbd{initrd /initrd}
+@end example
+
+@item
+Finally, run the command @command{boot} (@pxref{boot}).
+@end enumerate
+
+@strong{Caution:} If you use an initrd and specify the @samp{mem=}
+option to the kernel to let it use less than actual memory size, you
+will also have to specify the same memory size to GRUB. To let GRUB know
+the size, run the command @command{uppermem} @emph{before} loading the
+kernel. @xref{uppermem}, for more information.
+
+
+@node FreeBSD
+@subsection FreeBSD
+
+GRUB can load the kernel directly, either in ELF or a.out format. But
+this is not recommended, since FreeBSD's bootstrap interface sometimes
+changes heavily, so GRUB can't guarantee to pass kernel parameters
+correctly.
+
+Thus, we'd recommend loading the very flexible loader
+@file{/boot/loader} instead. See this example:
+
+@example
+@group
+grub> @kbd{root (hd0,a)}
+grub> @kbd{kernel /boot/loader}
+grub> @kbd{boot}
+@end group
+@end example
+
+
+@node NetBSD
+@subsection NetBSD
+
+GRUB can load NetBSD a.out and ELF directly, follow these steps:
+
+@enumerate
+@item
+Set GRUB's root device with @command{root} (@pxref{root}).
+
+@item
+Load the kernel with @command{kernel} (@pxref{kernel}). You should
+append the ugly option @option{--type=netbsd}, if you want to load an
+ELF kernel, like this:
+
+@example
+grub> @kbd{kernel --type=netbsd /netbsd-elf}
+@end example
+
+@item
+Run @command{boot} (@pxref{boot}).
+@end enumerate
+
+For now, however, GRUB doesn't allow you to pass kernel parameters, so
+it may be better to chain-load it instead. For more information, please
+see @ref{Chain-loading}.
+
+
+@node OpenBSD
+@subsection OpenBSD
+
+The booting instruction is exactly the same as for NetBSD
+(@pxref{NetBSD}).
+
+
+@node DOS/Windows
+@subsection DOS/Windows
+
+GRUB cannot boot DOS or Windows directly, so you must chain-load them
+(@pxref{Chain-loading}). However, their boot loaders have some critical
+deficiencies, so it may not work to just chain-load them. To overcome
+the problems, GRUB provides you with two helper functions.
+
+If you have installed DOS (or Windows) on a non-first hard disk, you
+have to use the disk swapping technique, because that OS cannot boot
+from any disks but the first one. The workaround used in GRUB is the
+command @command{map} (@pxref{map}), like this:
+
+@example
+@group
+grub> @kbd{map (hd0) (hd1)}
+grub> @kbd{map (hd1) (hd0)}
+@end group
+@end example
+
+This performs a @dfn{virtual} swap between your first and second hard
+drive.
+
+@strong{Caution:} This is effective only if DOS (or Windows) uses BIOS
+to access the swapped disks. If that OS uses a special driver for the
+disks, this probably won't work.
+
+Another problem arises if you installed more than one set of DOS/Windows
+onto one disk, because they could be confused if there are more than one
+primary partitions for DOS/Windows. Certainly you should avoid doing
+this, but there is a solution if you do want to do so. Use the partition
+hiding/unhiding technique.
+
+If GRUB @dfn{hide}s a DOS (or Windows) partition (@pxref{hide}), DOS (or
+Windows) will ignore the partition. If GRUB @dfn{unhide}s a DOS (or
+Windows) partition (@pxref{unhide}), DOS (or Windows) will detect the
+partition. Thus, if you have installed DOS (or Windows) on the first
+and the second partition of the first hard disk, and you want to boot
+the copy on the first partition, do the following:
+
+@example
+@group
+grub> @kbd{unhide (hd0,0)}
+grub> @kbd{hide (hd0,1)}
+grub> @kbd{rootnoverify (hd0,0)}
+grub> @kbd{chainloader +1}
+grub> @kbd{makeactive}
+grub> @kbd{boot}
+@end group
+@end example
+
+
+@node SCO UnixWare
+@subsection SCO UnixWare
+
+It is known that the signature in the boot loader for SCO UnixWare is
+wrong, so you will have to specify the option @option{--force} to
+@command{chainloader} (@pxref{chainloader}), like this:
+
+@example
+@group
+grub> @kbd{rootnoverify (hd1,0)}
+grub> @kbd{chainloader --force +1}
+grub> @kbd{makeactive}
+grub> @kbd{boot}
+@end group
+@end example
+
+
+@node QNX
+@subsection QNX
+
+QNX seems to use a bigger boot loader, so you need to boot it up, like
+this:
+
+@example
+@group
+grub> @kbd{rootnoverify (hd1,1)}
+grub> @kbd{chainloader +4}
+grub> @kbd{boot}
+@end group
+@end example
+
+
+@node Making your system robust
+@section How to make your system robust
+
+When you test a new kernel or a new OS, it is important to make sure
+that your computer can boot even if the new system is unbootable. This
+is crucial especially if you maintain servers or remote systems. To
+accomplish this goal, you need to set up two things:
+
+@enumerate
+@item
+You must maintain a system which is always bootable. For instance, if
+you test a new kernel, you need to keep a working kernel in a
+different place. And, it would sometimes be very nice to even have a
+complete copy of a working system in a different partition or disk.
+
+@item
+You must direct GRUB to boot a working system when the new system
+fails. This is possible with the @dfn{fallback} system in GRUB.
+@end enumerate
+
+The former requirement is very specific to each OS, so this
+documentation does not cover that topic. It is better to consult some
+backup tools.
+
+So let's see the GRUB part. There are two possibilities: one of them
+is quite simple but not very robust, and the other is a bit complex to
+set up but probably the best solution to make sure that your system
+can start as long as GRUB itself is bootable.
+
+@menu
+* Booting once-only::
+* Booting fallback systems::
+@end menu
+
+
+@node Booting once-only
+@subsection Booting once-only
+
+You can teach GRUB to boot an entry only at next boot time. Suppose
+that your have an old kernel @file{old_kernel} and a new kernel
+@file{new_kernel}. You know that @file{old_kernel} can boot
+your system correctly, and you want to test @file{new_kernel}.
+
+To ensure that your system will go back to the old kernel even if the
+new kernel fails (e.g. it panics), you can specify that GRUB should
+try the new kernel only once and boot the old kernel after that.
+
+First, modify your configuration file. Here is an example:
+
+@example
+@group
+default saved        # This is important!!!
+timeout 10
+
+title the old kernel
+root (hd0,0)
+kernel /old_kernel
+savedefault
+
+title the new kernel
+root (hd0,0)
+kernel /new_kernel
+savedefault 0         # This is important!!!
+@end group
+@end example
+
+Note that this configuration file uses @samp{default saved}
+(@pxref{default}) at the head and @samp{savedefault 0}
+(@pxref{savedefault}) in the entry for the new kernel. This means
+that GRUB boots a saved entry by default, and booting the entry for the
+new kernel saves @samp{0} as the saved entry.
+
+With this configuration file, after all, GRUB always tries to boot the
+old kernel after it booted the new one, because @samp{0} is the entry
+of @code{the old kernel}.
+
+The next step is to tell GRUB to boot the new kernel at next boot
+time. For this, execute @command{grub-set-default} (@pxref{Invoking
+grub-set-default}):
+
+@example
+# @kbd{grub-set-default 1}
+@end example
+
+This command sets the saved entry to @samp{1}, that is, to the new
+kernel.
+
+This method is useful, but still not very robust, because GRUB stops
+booting, if there is any error in the boot entry, such that the new
+kernel has an invalid executable format. Thus, it it even better to
+use the @dfn{fallback} mechanism of GRUB. Look at next subsection for
+this feature.
+
+
+@node Booting fallback systems
+@subsection Booting fallback systems
+
+GRUB supports a fallback mechanism of booting one or more other
+entries if a default boot entry fails. You can specify multiple
+fallback entries if you wish.
+
+Suppose that you have three systems, @samp{A}, @samp{B} and
+@samp{C}. @samp{A} is a system which you want to boot by
+default. @samp{B} is a backup system which is supposed to boot
+safely. @samp{C} is another backup system which is used in case where
+@samp{B} is broken.
+
+Then you may want GRUB to boot the first system which is bootable
+among @samp{A}, @samp{B} and @samp{C}. A configuration file can be
+written in this way:
+
+@example
+@group
+default saved        # This is important!!!
+timeout 10
+fallback 1 2         # This is important!!!
+
+title A
+root (hd0,0)
+kernel /kernel
+savedefault fallback # This is important!!!
+
+title B
+root (hd1,0)
+kernel /kernel
+savedefault fallback # This is important!!!
+
+title C
+root (hd2,0)
+kernel /kernel
+savedefault
+@end group
+@end example
+
+Note that @samp{default saved} (@pxref{default}), @samp{fallback 1 2}
+and @samp{savedefault fallback} are used. GRUB will boot a saved entry
+by default and save a fallback entry as next boot entry with this
+configuration.
+
+When GRUB tries to boot @samp{A}, GRUB saves @samp{1} as next boot
+entry, because the command @command{fallback} specifies that @samp{1}
+is the first fallback entry. The entry @samp{1} is @samp{B}, so GRUB
+will try to boot @samp{B} at next boot time.
+
+Likewise, when GRUB tries to boot @samp{B}, GRUB saves @samp{2} as
+next boot entry, because @command{fallback} specifies @samp{2} as next
+fallback entry. This makes sure that GRUB will boot @samp{C} after
+booting @samp{B}.
+
+It is noteworthy that GRUB uses fallback entries both when GRUB
+itself fails in booting an entry and when @samp{A} or @samp{B} fails
+in starting up your system. So this solution ensures that your system
+is started even if GRUB cannot find your kernel or if your kernel
+panics.
+
+However, you need to run @command{grub-set-default} (@pxref{Invoking
+grub-set-default}) when @samp{A} starts correctly or you fix @samp{A}
+after it crashes, since GRUB always sets next boot entry to a fallback
+entry. You should run this command in a startup script such as
+@file{rc.local} to boot @samp{A} by default:
+
+@example
+# @kbd{grub-set-default 0}
+@end example
+
+where @samp{0} is the number of the boot entry for the system
+@samp{A}.
+
+If you want to see what is current default entry, you can look at the
+file @file{/boot/grub/default} (or @file{/grub/default} in
+some systems). Because this file is plain-text, you can just
+@command{cat} this file. But it is strongly recommended @strong{not to
+modify this file directly}, because GRUB may fail in saving a default
+entry in this file, if you change this file in an unintended
+manner. Therefore, you should use @command{grub-set-default} when you
+need to change the default entry.
+
+
+@node Configuration
+@chapter Configuration
+
+You've probably noticed that you need to type several commands to boot your
+OS. There's a solution to that - GRUB provides a menu interface
+(@pxref{Menu interface}) from which you can select an item (using arrow
+keys) that will do everything to boot an OS.
+
+To enable the menu, you need a configuration file,
+@file{menu.lst} under the boot directory. We'll analyze an example
+file.
+
+The file first contains some general settings, the menu interface
+related options. You can put these commands (@pxref{Menu-specific
+commands}) before any of the items (starting with @command{title}
+(@pxref{title})).
+
+@example
+@group
+#
+# Sample boot menu configuration file
+#
+@end group
+@end example
+
+As you may have guessed, these lines are comments. Lines starting with a
+hash character (@samp{#}), and blank lines, are ignored by GRUB.
+
+@example
+@group
+# By default, boot the first entry.
+default 0
+@end group
+@end example
+
+The first entry (here, counting starts with number zero, not one!) will
+be the default choice.
+
+@example
+@group
+# Boot automatically after 30 secs.
+timeout 30
+@end group
+@end example
+
+As the comment says, GRUB will boot automatically in 30 seconds, unless
+interrupted with a keypress.
+
+@example
+@group
+# Fallback to the second entry.
+fallback 1
+@end group
+@end example
+
+If, for any reason, the default entry doesn't work, fall back to the
+second one (this is rarely used, for obvious reasons).
+
+Note that the complete descriptions of these commands, which are menu
+interface specific, can be found in @ref{Menu-specific
+commands}. Other descriptions can be found in @ref{Commands}.
+
+Now, on to the actual OS definitions. You will see that each entry
+begins with a special command, @command{title} (@pxref{title}), and the
+action is described after it. Note that there is no command
+@command{boot} (@pxref{boot}) at the  end of each item. That is because
+GRUB automatically executes @command{boot} if it loads other commands
+successfully.
+
+The argument for the command @command{title} is used to display a short
+title/description of the entry in the menu. Since @command{title}
+displays the argument as is, you can write basically anything there.
+
+@example
+@group
+# For booting GNU/Hurd
+title  GNU/Hurd
+root   (hd0,0)
+kernel /boot/gnumach.gz root=hd0s1
+module /boot/serverboot.gz
+@end group
+@end example
+
+This boots GNU/Hurd from the first hard disk.
+
+@example
+@group
+# For booting GNU/Linux
+title  GNU/Linux
+kernel (hd1,0)/vmlinuz root=/dev/hdb1
+@end group
+@end example
+
+This boots GNU/Linux, but from the second hard disk.
+
+@example
+@group
+# For booting Mach (getting kernel from floppy)
+title  Utah Mach4 multiboot
+root   (hd0,2)
+pause  Insert the diskette now^G!!
+kernel (fd0)/boot/kernel root=hd0s3
+module (fd0)/boot/bootstrap
+@end group
+@end example
+
+This boots Mach with a kernel on a floppy, but the root filesystem at
+hd0s3. It also contains a @command{pause} line (@pxref{pause}), which
+will cause GRUB to display a prompt and delay, before actually executing
+the rest of the commands and booting.
+
+@example
+@group
+# For booting FreeBSD
+title  FreeBSD
+root   (hd0,2,a)
+kernel /boot/loader
+@end group
+@end example
+
+This item will boot FreeBSD kernel loaded from the @samp{a} partition of
+the third @sc{pc} slice of the first hard disk.
+
+@example
+@group
+# For booting OS/2
+title OS/2
+root  (hd0,1)
+makeactive
+# chainload OS/2 bootloader from the first sector
+chainloader +1
+# This is similar to "chainload", but loads a specific file
+#chainloader /boot/chain.os2
+@end group
+@end example
+
+This will boot OS/2, using a chain-loader (@pxref{Chain-loading}).
+
+@example
+@group
+# For booting Windows NT or Windows95
+title Windows NT / Windows 95 boot menu
+root        (hd0,0)
+makeactive
+chainloader +1
+# For loading DOS if Windows NT is installed
+# chainload /bootsect.dos
+@end group
+@end example
+
+The same as the above, but for Windows.
+
+@example
+@group
+# For installing GRUB into the hard disk
+title Install GRUB into the hard disk
+root    (hd0,0)
+setup   (hd0)
+@end group
+@end example
+
+This will just (re)install GRUB onto the hard disk.
+
+@example
+# Change the colors.
+title Change the colors
+color light-green/brown blink-red/blue
+@end example
+
+In the last entry, the command @command{color} is used (@pxref{color}),
+to change the menu colors (try it!). This command is somewhat special,
+because it can be used both in the command-line and in the menu. GRUB
+has several such commands, see @ref{General commands}.
+
+We hope that you now understand how to use the basic features of
+GRUB. To learn more about GRUB, see the following chapters.
+
+
+@node Network
+@chapter Downloading OS images from a network
+
+Although GRUB is a disk-based boot loader, it does provide network
+support. To use the network support, you need to enable at least one
+network driver in the GRUB build process. For more information please
+see @file{netboot/README.netboot} in the source distribution.
+
+@menu
+* General usage of network support::
+* Diskless::
+@end menu
+
+
+@node General usage of network support
+@section How to set up your network
+
+GRUB requires a file server and optionally a server that will assign an
+IP address to the machine on which GRUB is running. For the former, only
+TFTP is supported at the moment. The latter is either BOOTP, DHCP or a
+RARP server@footnote{RARP is not advised, since it cannot serve much
+information}. It is not necessary to run both the servers on one
+computer. How to configure these servers is beyond the scope of this
+document, so please refer to the manuals specific to those
+protocols/servers.
+
+If you decided to use a server to assign an IP address, set up the
+server and run @command{bootp} (@pxref{bootp}), @command{dhcp}
+(@pxref{dhcp}) or @command{rarp} (@pxref{rarp}) for BOOTP, DHCP or RARP,
+respectively. Each command will show an assigned IP address, a netmask,
+an IP address for your TFTP server and a gateway. If any of the
+addresses is wrong or it causes an error, probably the configuration of
+your servers isn't set up properly.
+
+Otherwise, run @command{ifconfig}, like this:
+
+@example
+grub> @kbd{ifconfig --address=192.168.110.23 --server=192.168.110.14}
+@end example
+
+You can also use @command{ifconfig} in conjuction with @command{bootp},
+@command{dhcp} or @command{rarp} (e.g. to reassign the server address
+manually). @xref{ifconfig}, for more details.
+
+Finally, download your OS images from your network. The network can be
+accessed using the network drive @samp{(nd)}. Everything else is very
+similar to the normal instructions (@pxref{Booting}).
+
+Here is an example:
+
+@example
+@group
+grub> @kbd{bootp}
+Probing... [NE*000]
+NE2000 base ...
+Address: 192.168.110.23    Netmask: 255.255.255.0
+Server: 192.168.110.14     Gateway: 192.168.110.1
+
+grub> @kbd{root (nd)}
+grub> @kbd{kernel /tftproot/gnumach.gz root=sd0s1}
+grub> @kbd{module /tftproot/serverboot.gz}
+grub> @kbd{boot}
+@end group
+@end example
+
+
+@node Diskless
+@section Booting from a network
+
+It is sometimes very useful to boot from a network, especially when you
+use a machine which has no local disk. In this case, you need to obtain
+a kind of Net Boot @sc{rom}, such as a PXE @sc{rom} or a free software
+package like Etherboot. Such a Boot @sc{rom} first boots the machine,
+sets up the network card installed into the machine, and downloads a
+second stage boot image from the network. Then, the second image will
+try to boot an operating system actually from the network.
+
+GRUB provides two second stage images, @file{nbgrub} and
+@file{pxegrub} (@pxref{Images}). These images are the same as the
+normal Stage 2, except that they set up a network automatically, and try
+to load a configuration file from the network, if specified. The usage
+is very simple: If the machine has a PXE @sc{rom}, use
+@file{pxegrub}. If the machine has an NBI loader such as Etherboot, use
+@file{nbgrub}. There is no difference between them except their
+formats. Since the way to load a second stage image you want to use
+should be described in the manual on your Net Boot @sc{rom}, please
+refer to the manual, for more information.
+
+However, there is one thing specific to GRUB. Namely, how to specify a
+configuration file in a BOOTP/DHCP server. For now, GRUB uses the tag
+@samp{150}, to get the name of a configuration file. The following is an
+example with a BOOTP configuration:
+
+@example
+@group
+.allhost:hd=/tmp:bf=null:\
+        :ds=145.71.35.1 145.71.32.1:\
+        :sm=255.255.254.0:\
+        :gw=145.71.35.1:\
+        :sa=145.71.35.5:
+
+foo:ht=1:ha=63655d0334a7:ip=145.71.35.127:\
+        :bf=/nbgrub:\
+        :tc=.allhost:\
+        :T150="(nd)/tftpboot/menu.lst.foo":
+@end group
+@end example
+
+Note that you should specify the drive name @code{(nd)} in the name of
+the configuration file. This is because you might change the root drive
+before downloading the configuration from the TFTP server when the
+preset menu feature is used (@pxref{Preset Menu}).
+
+See the manual of your BOOTP/DHCP server for more information. The
+exact syntax should differ a little from the example.
+
+
+@node Serial terminal
+@chapter Using GRUB via a serial line
+
+This chapter describes how to use the serial terminal support in GRUB.
+
+If you have many computers or computers with no display/keyboard, it
+could be very useful to control the computers through serial
+communications. To connect one computer with another via a serial line,
+you need to prepare a null-modem (cross) serial cable, and you may need
+to have multiport serial boards, if your computer doesn't have extra
+serial ports. In addition, a terminal emulator is also required, such as
+minicom. Refer to a manual of your operating system, for more
+information.
+
+As for GRUB, the instruction to set up a serial terminal is quite
+simple. First of all, make sure that you haven't specified the option
+@option{--disable-serial} to the configure script when you built your
+GRUB images. If you get them in binary form, probably they have serial
+terminal support already.
+
+Then, initialize your serial terminal after GRUB starts up. Here is an
+example:
+
+@example
+@group
+grub> @kbd{serial --unit=0 --speed=9600}
+grub> @kbd{terminal serial}
+@end group
+@end example
+
+The command @command{serial} initializes the serial unit 0 with the
+speed 9600bps. The serial unit 0 is usually called @samp{COM1}, so, if
+you want to use COM2, you must specify @samp{--unit=1} instead. This
+command accepts many other options, so please refer to @ref{serial},
+for more details.
+
+The command @command{terminal} (@pxref{terminal}) chooses which type of
+terminal you want to use. In the case above, the terminal will be a
+serial terminal, but you can also pass @code{console} to the command,
+as @samp{terminal serial console}. In this case, a terminal in which
+you press any key will be selected as a GRUB terminal.
+
+However, note that GRUB assumes that your terminal emulator is
+compatible with VT100 by default. This is true for most terminal
+emulators nowadays, but you should pass the option @option{--dumb} to
+the command if your terminal emulator is not VT100-compatible or
+implements few VT100 escape sequences. If you specify this option then
+GRUB provides you with an alternative menu interface, because the normal
+menu requires several fancy features of your terminal.
+
+
+@node Preset Menu
+@chapter Embedding a configuration file into GRUB
+
+GRUB supports a @dfn{preset menu} which is to be always loaded before
+starting. The preset menu feature is useful, for example, when your
+computer has no console but a serial cable. In this case, it is
+critical to set up the serial terminal as soon as possible, since you
+cannot see any message until the serial terminal begins to work. So it
+is good to run the commands @command{serial} (@pxref{serial}) and
+@command{terminal} (@pxref{terminal}) before anything else at the
+start-up time.
+
+How the preset menu works is slightly complicated:
+
+@enumerate
+@item
+GRUB checks if the preset menu feature is used, and loads the preset
+menu, if available. This includes running commands and reading boot
+entries, like an ordinary configuration file.
+
+@item
+GRUB checks if the configuration file is available. Note that this check
+is performed @strong{regardless of the existence of the preset
+menu}. The configuration file is loaded even if the preset menu was
+loaded.
+
+@item
+If the preset menu includes any boot entries, they are cleared when
+the configuration file is loaded. It doesn't matter whether the
+configuration file has any entries or no entry. The boot entries in the
+preset menu are used only when GRUB fails in loading the configuration
+file.
+@end enumerate
+
+To enable the preset menu feature, you must rebuild GRUB specifying a
+file to the configure script with the option
+@option{--enable-preset-menu}. The file has the same semantics as
+normal configuration files (@pxref{Configuration}).
+
+Another point you should take care is that the diskless support
+(@pxref{Diskless}) diverts the preset menu. Diskless images embed a
+preset menu to execute the command @command{bootp} (@pxref{bootp})
+automatically, unless you specify your own preset menu to the configure
+script. This means that you must put commands to initialize a network in
+the preset menu yourself, because diskless images don't set it up
+implicitly, when you use the preset menu explicitly.
+
+Therefore, a typical preset menu used with diskless support would be
+like this:
+
+@example
+@group
+# Set up the serial terminal, first of all.
+serial --unit=0 --speed=19200
+terminal --timeout=0 serial
+
+# Initialize the network.
+dhcp
+@end group
+@end example
+
+
+@node Security
+@chapter Protecting your computer from cracking
+
+You may be interested in how to prevent ordinary users from doing
+whatever they like, if you share your computer with other people. So
+this chapter describes how to improve the security of GRUB.
+
+One thing which could be a security hole is that the user can do too
+many things with GRUB, because GRUB allows one to modify its configuration
+and run arbitrary commands at run-time. For example, the user can even
+read @file{/etc/passwd} in the command-line interface by the command
+@command{cat} (@pxref{cat}). So it is necessary to disable all the
+interactive operations.
+
+Thus, GRUB provides a @dfn{password} feature, so that only administrators
+can start the interactive operations (i.e. editing menu entries and
+entering the command-line interface). To use this feature, you need to
+run the command @command{password} in your configuration file
+(@pxref{password}), like this:
+
+@example
+password --md5 PASSWORD
+@end example
+
+If this is specified, GRUB disallows any interactive control, until you
+press the key @key{p} and enter a correct password.  The option
+@option{--md5} tells GRUB that @samp{PASSWORD} is in MD5 format.  If it
+is omitted, GRUB assumes the @samp{PASSWORD} is in clear text.
+
+You can encrypt your password with the command @command{md5crypt}
+(@pxref{md5crypt}). For example, run the grub shell (@pxref{Invoking the
+grub shell}), and enter your password:
+
+@example
+@group
+grub> md5crypt
+Password: **********
+Encrypted: $1$U$JK7xFegdxWH6VuppCUSIb.
+@end group
+@end example
+
+Then, cut and paste the encrypted password to your configuration file.
+
+Also, you can specify an optional argument to @command{password}. See
+this example:
+
+@example
+password PASSWORD /boot/grub/menu-admin.lst
+@end example
+
+In this case, GRUB will load @file{/boot/grub/menu-admin.lst} as a
+configuration file when you enter the valid password.
+
+Another thing which may be dangerous is that any user can choose any
+menu entry. Usually, this wouldn't be problematic, but you might want to
+permit only administrators to run some of your menu entries, such as an
+entry for booting an insecure OS like DOS.
+
+GRUB provides the command @command{lock} (@pxref{lock}). This command
+always fails until you enter the valid password, so you can use it, like
+this:
+
+@example
+@group
+title Boot DOS
+lock
+rootnoverify (hd0,1)
+makeactive
+chainload +1
+@end group
+@end example
+
+You should insert @command{lock} right after @command{title}, because
+any user can execute commands in an entry until GRUB encounters
+@command{lock}.
+
+You can also use the command @command{password} instead of
+@command{lock}. In this case the boot process will ask for the password
+and stop if it was entered incorrectly.  Since the @command{password}
+takes its own @var{PASSWORD} argument this is useful if you want
+different passwords for different entries.
+
+
+@node Images
+@chapter GRUB image files
+
+GRUB consists of several images: two essential stages, optional stages
+called @dfn{Stage 1.5}, one image for bootable CD-ROM, and two network
+boot images. Here is a short overview of them. @xref{Internals}, for
+more details.
+
+@table @file
+@item stage1
+This is an essential image used for booting up GRUB. Usually, this is
+embedded in an MBR or the boot sector of a partition. Because a PC boot
+sector is 512 bytes, the size of this image is exactly 512 bytes.
+
+All @file{stage1} must do is to load Stage 2 or Stage 1.5 from a local
+disk. Because of the size restriction, @file{stage1} encodes the
+location of Stage 2 (or Stage 1.5) in a block list format, so it never
+understand any filesystem structure.
+
+@item stage2
+This is the core image of GRUB. It does everything but booting up
+itself. Usually, this is put in a filesystem, but that is not required.
+
+@item e2fs_stage1_5
+@itemx fat_stage1_5
+@itemx ffs_stage1_5
+@itemx jfs_stage1_5
+@itemx minix_stage1_5
+@itemx reiserfs_stage1_5
+@itemx vstafs_stage1_5
+@itemx xfs_stage1_5
+
+These are called @dfn{Stage 1.5}, because they serve as a bridge
+between @file{stage1} and @file{stage2}, that is to say, Stage 1.5 is
+loaded by Stage 1 and Stage 1.5 loads Stage 2. The difference between
+@file{stage1} and @file{*_stage1_5} is that the former doesn't
+understand any filesystem while the latter understands one filesystem
+(e.g. @file{e2fs_stage1_5} understands ext2fs). So you can move the
+Stage 2 image to another location safely, even after GRUB has been
+installed.
+
+While Stage 2 cannot generally be embedded in a fixed area as the size
+is so large, Stage 1.5 can be installed into the area right after an MBR,
+or the boot loader area of a ReiserFS or a FFS.
+
+@item stage2_eltorito
+This is a boot image for CD-ROMs using the @dfn{no emulation mode} in
+El Torito specification. This is identical to Stage 2, except that
+this boots up without Stage 1 and sets up a special drive @samp{(cd)}.
+
+@item nbgrub
+This is a network boot image for the Network Image Proposal used by some
+network boot loaders, such as Etherboot. This is mostly the same as
+Stage 2, but it also sets up a network and loads a configuration file
+from the network.
+
+@item pxegrub
+This is another network boot image for the Preboot Execution Environment
+used by several Netboot ROMs. This is identical to @file{nbgrub}, except
+for the format.
+@end table
+
+
+@node Filesystem
+@chapter Filesystem syntax and semantics
+
+GRUB uses a special syntax for specifying disk drives which can be
+accessed by BIOS. Because of BIOS limitations, GRUB cannot distinguish
+between IDE, ESDI, SCSI, or others. You must know yourself which BIOS
+device is equivalent to which OS device. Normally, that will be clear if
+you see the files in a device or use the command @command{find}
+(@pxref{find}).
+
+@menu
+* Device syntax::               How to specify devices
+* File name syntax::            How to specify files
+* Block list syntax::           How to specify block lists
+@end menu
+
+
+@node Device syntax
+@section How to specify devices
+
+The device syntax is like this:
+
+@example
+@code{(@var{device}[,@var{part-num}][,@var{bsd-subpart-letter}])}
+@end example
+
+@samp{[]} means the parameter is optional. @var{device} should be
+either @samp{fd} or @samp{hd} followed by a digit, like @samp{fd0}.
+But you can also set @var{device} to a hexadecimal or a decimal number
+which is a BIOS drive number, so the following are equivalent:
+
+@example
+(hd0)
+(0x80)
+(128)
+@end example
+
+@var{part-num} represents the partition number of @var{device}, starting
+from zero for primary partitions and from four for extended partitions,
+and @var{bsd-subpart-letter} represents the BSD disklabel subpartition,
+such as @samp{a} or @samp{e}.
+
+A shortcut for specifying BSD subpartitions is
+@code{(@var{device},@var{bsd-subpart-letter})}, in this case, GRUB
+searches for the first PC partition containing a BSD disklabel, then
+finds the subpartition @var{bsd-subpart-letter}. Here is an example:
+
+@example
+(hd0,a)
+@end example
+
+The syntax @samp{(hd0)} represents using the entire disk (or the
+MBR when installing GRUB), while the syntax @samp{(hd0,0)}
+represents using the first partition of the disk (or the boot sector
+of the partition when installing GRUB).
+
+If you enabled the network support, the special drive, @samp{(nd)}, is
+also available. Before using the network drive, you must initialize the
+network. @xref{Network}, for more information.
+
+If you boot GRUB from a CD-ROM, @samp{(cd)} is available. @xref{Making
+a GRUB bootable CD-ROM}, for details.
+
+
+@node File name syntax
+@section How to specify files
+
+There are two ways to specify files, by @dfn{absolute file name} and by
+@dfn{block list}.
+
+An absolute file name resembles a Unix absolute file name, using
+@samp{/} for the directory separator (not @samp{\} as in DOS). One
+example is @samp{(hd0,0)/boot/grub/menu.lst}. This means the file
+@file{/boot/grub/menu.lst} in the first partition of the first hard
+disk. If you omit the device name in an absolute file name, GRUB uses
+GRUB's @dfn{root device} implicitly. So if you set the root device to,
+say, @samp{(hd1,0)} by the command @command{root} (@pxref{root}), then
+@code{/boot/kernel} is the same as @code{(hd1,0)/boot/kernel}.
+
+
+@node Block list syntax
+@section How to specify block lists
+
+A block list is used for specifying a file that doesn't appear in the
+filesystem, like a chainloader. The syntax is
+@code{[@var{offset}]+@var{length}[,[@var{offset}]+@var{length}]@dots{}}.
+Here is an example:
+
+@example
+@code{0+100,200+1,300+300}
+@end example
+
+This represents that GRUB should read blocks 0 through 99, block 200,
+and blocks 300 through 599. If you omit an offset, then GRUB assumes
+the offset is zero.
+
+Like the file name syntax (@pxref{File name syntax}), if a blocklist
+does not contain a device name, then GRUB uses GRUB's @dfn{root
+device}. So @code{(hd0,1)+1} is the same as @code{+1} when the root
+device is @samp{(hd0,1)}.
+
+
+@node Interface
+@chapter GRUB's user interface
+
+GRUB has both a simple menu interface for choosing preset entries from a
+configuration file, and a highly flexible command-line for performing
+any desired combination of boot commands.
+
+GRUB looks for its configuration file as soon as it is loaded. If one
+is found, then the full menu interface is activated using whatever
+entries were found in the file. If you choose the @dfn{command-line} menu
+option, or if the configuration file was not found, then GRUB drops to
+the command-line interface.
+
+@menu
+* Command-line interface::      The flexible command-line interface
+* Menu interface::              The simple menu interface
+* Menu entry editor::           Editing a menu entry
+* Hidden menu interface::       The hidden menu interface
+@end menu
+
+
+@node Command-line interface
+@section The flexible command-line interface
+
+The command-line interface provides a prompt and after it an editable
+text area much like a command-line in Unix or DOS. Each command is
+immediately executed after it is entered@footnote{However, this
+behavior will be changed in the future version, in a user-invisible
+way.}. The commands (@pxref{Command-line and menu entry commands}) are a
+subset of those available in the configuration file, used with exactly
+the same syntax.
+
+Cursor movement and editing of the text on the line can be done via a
+subset of the functions available in the Bash shell:
+
+@table @key
+@item C-f
+@itemx PC right key
+Move forward one character.
+
+@item C-b
+@itemx PC left key
+Move back one character.
+
+@item C-a
+@itemx HOME
+Move to the start of the line.
+
+@item C-e
+@itemx END
+Move the the end of the line.
+
+@item C-d
+@itemx DEL
+Delete the character underneath the cursor.
+
+@item C-h
+@itemx BS
+Delete the character to the left of the cursor.
+
+@item C-k
+Kill the text from the current cursor position to the end of the line.
+
+@item C-u
+Kill backward from the cursor to the beginning of the line.
+
+@item C-y
+Yank the killed text back into the buffer at the cursor.
+
+@item C-p
+@itemx PC up key
+Move up through the history list.
+
+@item C-n
+@itemx PC down key
+Move down through the history list.
+@end table
+
+When typing commands interactively, if the cursor is within or before
+the first word in the command-line, pressing the @key{TAB} key (or
+@key{C-i}) will display a listing of the available commands, and if the
+cursor is after the first word, the @kbd{@key{TAB}} will provide a
+completion listing of disks, partitions, and file names depending on the
+context. Note that to obtain a list of drives, one must open a
+parenthesis, as @command{root (}.
+
+Note that you cannot use the completion functionality in the TFTP
+filesystem. This is because TFTP doesn't support file name listing for
+the security.
+
+
+@node Menu interface
+@section The simple menu interface
+
+The menu interface is quite easy to use. Its commands are both
+reasonably intuitive and described on screen.
+
+Basically, the menu interface provides a list of @dfn{boot entries} to
+the user to choose from. Use the arrow keys to select the entry of
+choice, then press @key{RET} to run it.  An optional timeout is
+available to boot the default entry (the first one if not set), which is
+aborted by pressing any key.
+
+Commands are available to enter a bare command-line by pressing @key{c}
+(which operates exactly like the non-config-file version of GRUB, but
+allows one to return to the menu if desired by pressing @key{ESC}) or to
+edit any of the @dfn{boot entries} by pressing @key{e}.
+
+If you protect the menu interface with a password (@pxref{Security}),
+all you can do is choose an entry by pressing @key{RET}, or press
+@key{p} to enter the password.
+
+
+@node Menu entry editor
+@section Editing a menu entry
+
+The menu entry editor looks much like the main menu interface, but the
+lines in the menu are individual commands in the selected entry instead
+of entry names.
+
+If an @key{ESC} is pressed in the editor, it aborts all the changes made
+to the configuration entry and returns to the main menu interface.
+
+When a particular line is selected, the editor places the user in a
+special version of the GRUB command-line to edit that line.  When the
+user hits @key{RET}, GRUB replaces the line in question in the boot
+entry with the changes (unless it was aborted via @key{ESC},
+in which case the changes are thrown away).
+
+If you want to add a new line to the menu entry, press @key{o} if adding
+a line after the current line or press @key{O} if before the current
+line.
+
+To delete a line, hit the key @key{d}. Although GRUB unfortunately
+does not support @dfn{undo}, you can do almost the same thing by just
+returning to the main menu.
+
+
+@node Hidden menu interface
+@section The hidden menu interface
+
+When your terminal is dumb or you request GRUB to hide the menu
+interface explicitly with the command @command{hiddenmenu}
+(@pxref{hiddenmenu}), GRUB doesn't show the menu interface (@pxref{Menu
+interface}) and automatically boots the default entry, unless
+interrupted by pressing @key{ESC}.
+
+When you interrupt the timeout and your terminal is dumb, GRUB falls
+back to the command-line interface (@pxref{Command-line interface}).
+
+
+@node Commands
+@chapter The list of available commands
+
+In this chapter, we list all commands that are available in GRUB.
+
+Commands belong to different groups. A few can only be used in
+the global section of the configuration file (or ``menu''); most
+of them can be entered on the command-line and can be used either
+anywhere in the menu or specifically in the menu entries.
+
+@menu
+* Menu-specific commands::
+* General commands::
+* Command-line and menu entry commands::
+@end menu
+
+
+@node Menu-specific commands
+@section The list of commands for the menu only
+
+The semantics used in parsing the configuration file are the following:
+
+@itemize @bullet
+@item
+The menu-specific commands have to be used before any others.
+
+@item
+The files @emph{must} be in plain-text format.
+
+@item
+@samp{#} at the beginning of a line in a configuration file means it is
+only a comment.
+
+@item
+Options are separated by spaces.
+
+@item
+All numbers can be either decimal or hexadecimal. A hexadecimal number
+must be preceded by @samp{0x}, and is case-insensitive.
+
+@item
+Extra options or text at the end of the line are ignored unless otherwise
+specified.
+
+@item
+Unrecognized commands are added to the current entry, except before entries
+start, where they are ignored.
+@end itemize
+
+These commands can only be used in the menu:
+
+@menu
+* default::                     Set the default entry
+* fallback::                    Set the fallback entry
+* hiddenmenu::                  Hide the menu interface
+* gfxmenu::                     Use graphical menu interface
+* timeout::                     Set the timeout
+* title::                       Start a menu entry
+@end menu
+
+
+@node default
+@subsection default
+
+@deffn Command default num
+Set the default entry to the entry number @var{num}. Numbering starts
+from 0, and the entry number 0 is the default if the command is not
+used.
+
+You can specify @samp{saved} instead of a number. In this case, the
+default entry is the entry saved with the command
+@command{savedefault}. @xref{savedefault}, for more information.
+@end deffn
+
+
+@node fallback
+@subsection fallback
+
+@deffn Command fallback num...
+Go into unattended boot mode: if the default boot entry has any errors,
+instead of waiting for the user to do something, immediately start
+over using the @var{num} entry (same numbering as the @code{default}
+command (@pxref{default})). This obviously won't help if the machine was
+rebooted by a kernel that GRUB loaded. You can specify multiple
+fallback entry numbers.
+@end deffn
+
+
+@node gfxmenu
+@subsection gfxmenu
+
+@deffn Command gfxmenu file
+Use the graphical menu interface. The graphics data are taken from
+@var{file} and must be created using 'mkbootmsg' from the gfxboot package.
+@end deffn
+
+
+@node hiddenmenu
+@subsection hiddenmenu
+
+@deffn Command hiddenmenu
+Don't display the menu. If the command is used, no menu will be
+displayed on the control terminal, and the default entry will be
+booted after the timeout expired. The user can still request the
+menu to be displayed by pressing @key{ESC} before the timeout
+expires. See also @ref{Hidden menu interface}.
+@end deffn
+
+
+@node timeout
+@subsection timeout
+
+@deffn Command timeout sec
+Set a timeout, in @var{sec} seconds, before automatically booting the
+default entry (normally the first entry defined).
+@end deffn
+
+
+@node title
+@subsection title
+
+@deffn Command title name @dots{}
+Start a new boot entry, and set its name to the contents of the rest of
+the line, starting with the first non-space character.
+@end deffn
+
+
+@node General commands
+@section The list of general commands
+
+Commands usable anywhere in the menu and in the command-line.
+
+@menu
+* bootp::                       Initialize a network device via BOOTP
+* color::                       Color the menu interface
+* device::                      Specify a file as a drive
+* dhcp::                        Initialize a network device via DHCP
+* hide::                        Hide a partition
+* ifconfig::                    Configure a network device manually
+* pager::                       Change the state of the internal pager
+* partnew::                     Make a primary partition
+* parttype::                    Change the type of a partition
+* password::                    Set a password for the menu interface
+* rarp::                        Initialize a network device via RARP
+* serial::                      Set up a serial device
+* setkey::                      Configure the key map
+* terminal::                    Choose a terminal
+* terminfo::                    Define escape sequences for a terminal
+* tftpserver::                  Specify a TFTP server
+* unhide::                      Unhide a partition
+@end menu
+
+
+@node bootp
+@subsection bootp
+
+@deffn Command bootp [@option{--with-configfile}]
+Initialize a network device via the @dfn{BOOTP} protocol. This command
+is only available if GRUB is compiled with netboot support. See also
+@ref{Network}.
+
+If you specify @option{--with-configfile} to this command, GRUB will
+fetch and load a configuration file specified by your BOOTP server
+with the vendor tag @samp{150}.
+@end deffn
+
+
+@node color
+@subsection color
+
+@deffn Command color normal [highlight]
+Change the menu colors. The color @var{normal} is used for most
+lines in the menu (@pxref{Menu interface}), and the color
+@var{highlight} is used to highlight the line where the cursor
+points. If you omit @var{highlight}, then the inverted color of
+@var{normal} is used for the highlighted line. The format of a color is
+@code{@var{foreground}/@var{background}}. @var{foreground} and
+@var{background} are symbolic color names. A symbolic color name must be
+one of these:
+
+@itemize @bullet
+@item
+black
+
+@item
+blue
+
+@item
+green
+
+@item
+cyan
+
+@item
+red
+
+@item
+magenta
+
+@item
+brown
+
+@item
+light-gray
+
+@strong{These below can be specified only for the foreground.}
+
+@item
+dark-gray
+
+@item
+light-blue
+
+@item
+light-green
+
+@item
+light-cyan
+
+@item
+light-red
+
+@item
+light-magenta
+
+@item
+yellow
+
+@item
+white
+@end itemize
+
+But only the first eight names can be used for @var{background}. You can
+prefix @code{blink-} to @var{foreground} if you want a blinking
+foreground color.
+
+This command can be used in the configuration file and on the command
+line, so you may write something like this in your configuration file:
+
+@example
+@group
+# Set default colors.
+color light-gray/blue black/light-gray
+
+# Change the colors.
+title OS-BS like
+color magenta/blue black/magenta
+@end group
+@end example
+@end deffn
+
+
+@node device
+@subsection device
+
+@deffn Command device drive file
+In the grub shell, specify the file @var{file} as the actual drive for a
+@sc{bios} drive @var{drive}. You can use this command to create a disk
+image, and/or to fix the drives guessed by GRUB when GRUB fails to
+determine them correctly, like this:
+
+@example
+@group
+grub> @kbd{device (fd0) /floppy-image}
+grub> @kbd{device (hd0) /dev/sd0}
+@end group
+@end example
+
+This command can be used only in the grub shell (@pxref{Invoking the
+grub shell}).
+@end deffn
+
+
+@node dhcp
+@subsection dhcp
+
+@deffn Command dhcp [--with-configfile]
+Initialize a network device via the @dfn{DHCP} protocol. Currently,
+this command is just an alias for @command{bootp}, since the two
+protocols are very similar. This command is only available if GRUB is
+compiled with netboot support. See also @ref{Network}.
+
+If you specify @option{--with-configfile} to this command, GRUB will
+fetch and load a configuration file specified by your DHCP server
+with the vendor tag @samp{150}.
+@end deffn
+
+
+@node hide
+@subsection hide
+
+@deffn Command hide partition
+Hide the partition @var{partition} by setting the @dfn{hidden} bit in
+its partition type code. This is useful only when booting DOS or Windows
+and multiple primary FAT partitions exist in one disk. See also
+@ref{DOS/Windows}.
+@end deffn
+
+
+@node ifconfig
+@subsection ifconfig
+
+@deffn Command ifconfig [@option{--server=server}] [@option{--gateway=gateway}] [@option{--mask=mask}] [@option{--address=address}]
+Configure the IP address, the netmask, the gateway, and the server
+address of a network device manually. The values must be in dotted
+decimal format, like @samp{192.168.11.178}. The order of the options is
+not important. This command shows current network configuration, if no
+option is specified. See also @ref{Network}.
+@end deffn
+
+
+@node pager
+@subsection pager
+
+@deffn Command pager [flag]
+Toggle or set the state of the internal pager. If @var{flag} is
+@samp{on}, the internal pager is enabled. If @var{flag} is @samp{off},
+it is disabled. If no argument is given, the state is toggled.
+@end deffn
+
+
+@node partnew
+@subsection partnew
+
+@deffn Command partnew part type from len
+Create a new primary partition. @var{part} is a partition specification
+in GRUB syntax (@pxref{Naming convention}); @var{type} is the partition
+type and must be a number in the range @code{0-0xff}; @var{from} is
+the starting address and @var{len} is the length, both in sector units.
+@end deffn
+
+
+@node parttype
+@subsection parttype
+
+@deffn Command parttype part type
+Change the type of an existing partition.  @var{part} is a partition
+specification in GRUB syntax (@pxref{Naming convention}); @var{type}
+is the new partition type and must be a number in the range 0-0xff.
+@end deffn
+
+
+@node password
+@subsection password
+
+@deffn Command password [@option{--md5}] passwd [new-config-file]
+If used in the first section of a menu file, disable all interactive
+editing control (menu entry editor and command-line) and entries
+protected by the command @command{lock}. If the password @var{passwd} is
+entered, it loads the @var{new-config-file} as a new config file and
+restarts the GRUB Stage 2, if @var{new-config-file} is
+specified. Otherwise, GRUB will just unlock the privileged instructions.
+You can also use this command in the script section, in which case it
+will ask for the password, before continuing.  The option
+@option{--md5} tells GRUB that @var{passwd} is encrypted with
+@command{md5crypt} (@pxref{md5crypt}).
+@end deffn
+
+
+@node rarp
+@subsection rarp
+
+@deffn Command rarp
+Initialize a network device via the @dfn{RARP} protocol.  This command
+is only available if GRUB is compiled with netboot support. See also
+@ref{Network}.
+@end deffn
+
+
+@node serial
+@subsection serial
+
+@deffn Command serial [@option{--unit=unit}] [@option{--port=port}] [@option{--speed=speed}] [@option{--word=word}] [@option{--parity=parity}] [@option{--stop=stop}] [@option{--device=dev}]
+Initialize a serial device. @var{unit} is a number in the range 0-3
+specifying which serial port to use; default is 0, which corresponds to
+the port often called COM1. @var{port} is the I/O port where the UART
+is to be found; if specified it takes precedence over @var{unit}.
+@var{speed} is the transmission speed; default is 9600. @var{word} and
+@var{stop} are the number of data bits and stop bits. Data bits must
+be in the range 5-8 and stop bits must be 1 or 2. Default is 8 data
+bits and one stop bit. @var{parity} is one of @samp{no}, @samp{odd},
+@samp{even} and defaults to @samp{no}. The option @option{--device}
+can only be used in the grub shell and is used to specify the 
+tty device to be used in the host operating system (@pxref{Invoking the
+grub shell}).
+
+The serial port is not used as a communication channel unless the
+@command{terminal} command is used (@pxref{terminal}).
+
+This command is only available if GRUB is compiled with serial
+support. See also @ref{Serial terminal}.
+@end deffn
+
+
+@node setkey
+@subsection setkey
+
+@deffn Command setkey [to_key from_key]
+Change the keyboard map. The key @var{from_key} is mapped to the key
+@var{to_key}. If no argument is specified, reset key mappings. Note that 
+this command @emph{does not} exchange the keys. If you want to exchange 
+the keys, run this command again with the arguments exchanged, like this:
+
+@example
+grub> @kbd{setkey capslock control}
+grub> @kbd{setkey control capslock}
+@end example
+
+A key must be an alphabet letter, a digit, or one of these symbols:
+@samp{escape}, @samp{exclam}, @samp{at}, @samp{numbersign},
+@samp{dollar}, @samp{percent}, @samp{caret}, @samp{ampersand},
+@samp{asterisk}, @samp{parenleft}, @samp{parenright}, @samp{minus},
+@samp{underscore}, @samp{equal}, @samp{plus}, @samp{backspace},
+@samp{tab}, @samp{bracketleft}, @samp{braceleft}, @samp{bracketright},
+@samp{braceright}, @samp{enter}, @samp{control}, @samp{semicolon},
+@samp{colon}, @samp{quote}, @samp{doublequote}, @samp{backquote},
+@samp{tilde}, @samp{shift}, @samp{backslash}, @samp{bar}, @samp{comma},
+@samp{less}, @samp{period}, @samp{greater}, @samp{slash},
+@samp{question}, @samp{alt}, @samp{space}, @samp{capslock}, @samp{FX}
+(@samp{X} is a digit), and @samp{delete}. This table describes to which
+character each of the symbols corresponds:
+
+@table @samp
+@item exclam
+@samp{!}
+
+@item at
+@samp{@@}
+
+@item numbersign
+@samp{#}
+
+@item dollar
+@samp{$}
+
+@item percent
+@samp{%}
+
+@item caret
+@samp{^}
+
+@item ampersand
+@samp{&}
+
+@item asterisk
+@samp{*}
+
+@item parenleft
+@samp{(}
+
+@item parenright
+@samp{)}
+
+@item minus
+@samp{-}
+
+@item underscore
+@samp{_}
+
+@item equal
+@samp{=}
+
+@item plus
+@samp{+}
+
+@item bracketleft
+@samp{[}
+
+@item braceleft
+@samp{@{}
+
+@item bracketright
+@samp{]}
+
+@item braceright
+@samp{@}}
+
+@item semicolon
+@samp{;}
+
+@item colon
+@samp{:}
+
+@item quote
+@samp{'}
+
+@item doublequote
+@samp{"}
+
+@item backquote
+@samp{`}
+
+@item tilde
+@samp{~}
+
+@item backslash
+@samp{\}
+
+@item bar
+@samp{|}
+
+@item comma
+@samp{,}
+
+@item less
+@samp{<}
+
+@item period
+@samp{.}
+
+@item greater
+@samp{>}
+
+@item slash
+@samp{/}
+
+@item question
+@samp{?}
+
+@item space
+@samp{ }
+@end table
+@end deffn
+
+
+@node terminal
+@subsection terminal
+
+@deffn Command terminal [@option{--dumb}] [@option{--no-echo}] [@option{--no-edit}] [@option{--timeout=secs}] [@option{--lines=lines}] [@option{--silent}] [@option{console}] [@option{serial}] [@option{hercules}]
+Select a terminal for user interaction. The terminal is assumed to be
+VT100-compatible unless @option{--dumb} is specified. If both
+@option{console} and @option{serial} are specified, then GRUB will use
+the one where a key is entered first or the first when the timeout
+expires. If neither are specified, the current setting is
+reported. This command is only available if GRUB is compiled with serial
+support. See also @ref{Serial terminal}.
+
+This may not make sense for most users, but GRUB supports Hercules
+console as well. Hercules console is usable like the ordinary console,
+and the usage is quite similar to that for serial terminals: specify
+@option{hercules} as the argument.
+
+The option @option{--lines} defines the number of lines in your
+terminal, and it is used for the internal pager function. If you don't
+specify this option, the number is assumed as 24.
+
+The option @option{--silent} suppresses the message to prompt you to
+hit any key. This might be useful if your system has no terminal
+device.
+
+The option @option{--no-echo} has GRUB not to echo back input
+characters. This implies the option @option{--no-edit}.
+
+The option @option{--no-edit} disables the BASH-like editing feature.
+@end deffn
+
+
+@node terminfo
+@subsection terminfo
+
+@deffn Command terminfo @option{--name=name} @option{--cursor-address=seq} [@option{--clear-screen=seq}] [@option{--enter-standout-mode=seq}] [@option{--exit-standout-mode=seq}]
+Define the capabilities of your terminal. Use this command to define
+escape sequences, if it is not vt100-compatible. You may use @samp{\e}
+for @key{ESC} and @samp{^X} for a control character.
+
+You can use the utility @command{grub-terminfo} to generate
+appropriate arguments to this command. @xref{Invoking grub-terminfo}.
+
+If no option is specified, the current settings are printed.
+@end deffn
+
+
+@node tftpserver
+@subsection tftpserver
+
+@deffn Command tftpserver ipaddr
+@strong{Caution:} This command exists only for backward
+compatibility. Use @command{ifconfig} (@pxref{ifconfig}) instead.
+
+Override a TFTP server address returned by a BOOTP/DHCP/RARP server. The
+argument @var{ipaddr} must be in dotted decimal format, like
+@samp{192.168.0.15}.  This command is only available if GRUB is compiled
+with netboot support. See also @ref{Network}.
+@end deffn
+
+
+@node unhide
+@subsection unhide
+
+@deffn Command unhide partition
+Unhide the partition @var{partition} by clearing the @dfn{hidden} bit in
+its partition type code. This is useful only when booting DOS or Windows
+and multiple primary partitions exist on one disk. See also
+@ref{DOS/Windows}.
+@end deffn
+
+
+@node Command-line and menu entry commands
+@section The list of command-line and menu entry commands
+
+These commands are usable in the command-line and in menu entries.  If
+you forget a command, you can run the command @command{help}
+(@pxref{help}).
+
+@menu
+* blocklist::                   Get the block list notation of a file
+* boot::                        Start up your operating system
+* cat::                         Show the contents of a file
+* chainloader::                 Chain-load another boot loader
+* cmp::                         Compare two files
+* configfile::                  Load a configuration file
+* debug::                       Toggle the debug flag
+* displayapm::                  Display APM information
+* displaymem::                  Display memory configuration
+* embed::                       Embed Stage 1.5
+* find::                        Find a file
+* fstest::                      Test a filesystem
+* geometry::                    Manipulate the geometry of a drive
+* halt::                        Shut down your computer
+* help::                        Show help messages
+* impsprobe::                   Probe SMP
+* initrd::                      Load an initrd
+* install::                     Install GRUB
+* ioprobe::                     Probe I/O ports used for a drive
+* kernel::                      Load a kernel
+* lock::                        Lock a menu entry
+* makeactive::                  Make a partition active
+* map::                         Map a drive to another
+* md5crypt::                    Encrypt a password in MD5 format
+* module::                      Load a module
+* modulenounzip::               Load a module without decompression
+* pause::                       Wait for a key press
+* quit::                        Exit from the grub shell
+* reboot::                      Reboot your computer
+* read::                        Read data from memory
+* root::                        Set GRUB's root device
+* rootnoverify::                Set GRUB's root device without mounting
+* savedefault::                 Save current entry as the default entry
+* setup::                       Set up GRUB's installation automatically
+* testload::                    Load a file for testing a filesystem
+* testvbe::                     Test VESA BIOS EXTENSION
+* uppermem::                    Set the upper memory size
+* vbeprobe::                    Probe VESA BIOS EXTENSION
+@end menu
+
+
+@node blocklist
+@subsection blocklist
+
+@deffn Command blocklist file
+Print the block list notation of the file @var{file}. @xref{Block list
+syntax}.
+@end deffn
+
+
+@node boot
+@subsection boot
+
+@deffn Command boot
+Boot the OS or chain-loader which has been loaded. Only necessary if
+running the fully interactive command-line (it is implicit at the end of
+a menu entry).
+@end deffn
+
+
+@node cat
+@subsection cat
+
+@deffn Command cat file
+Display the contents of the file @var{file}. This command may be useful
+to remind you of your OS's root partition:
+
+@example
+grub> @kbd{cat /etc/fstab}
+@end example
+@end deffn
+
+
+@node chainloader
+@subsection chainloader
+
+@deffn Command chainloader [@option{--force}] file
+Load @var{file} as a chain-loader. Like any other file loaded by the
+filesystem code, it can use the blocklist notation to grab the first
+sector of the current partition with @samp{+1}. If you specify the
+option @option{--force}, then load @var{file} forcibly, whether it has a
+correct signature or not. This is required when you want to load a
+defective boot loader, such as SCO UnixWare 7.1 (@pxref{SCO UnixWare}).
+@end deffn
+
+
+@node cmp
+@subsection cmp
+
+@deffn Command cmp file1 file2
+Compare the file @var{file1} with the file @var{file2}. If they differ
+in size, print the sizes like this:
+
+@example
+Differ in size: 0x1234 [foo], 0x4321 [bar]
+@end example
+
+If the sizes are equal but the bytes at an offset differ, then print the
+bytes like this:
+
+@example
+Differ at the offset 777: 0xbe [foo], 0xef [bar]
+@end example
+
+If they are completely identical, nothing will be printed.
+@end deffn
+
+
+@node configfile
+@subsection configfile
+
+@deffn Command configfile file
+Load @var{file} as a configuration file.
+@end deffn
+
+
+@node debug
+@subsection debug
+
+@deffn Command debug
+Toggle debug mode (by default it is off). When debug mode is on, some
+extra messages are printed to show disk activity. This global debug flag
+is mainly useful for GRUB developers when testing new code.
+@end deffn
+
+
+@node displayapm
+@subsection displayapm
+
+@deffn Command displayapm
+Display APM BIOS information.
+@end deffn
+
+
+@node displaymem
+@subsection displaymem
+
+@deffn Command displaymem
+Display what GRUB thinks the system address space map of the machine is,
+including all regions of physical @sc{ram} installed. GRUB's
+@dfn{upper/lower memory} display uses the standard BIOS interface for
+the available memory in the first megabyte, or @dfn{lower memory}, and a
+synthesized number from various BIOS interfaces of the memory starting
+at 1MB and going up to the first chipset hole for @dfn{upper memory}
+(the standard PC @dfn{upper memory} interface is limited to reporting a
+maximum of 64MB).
+@end deffn
+
+
+@node embed
+@subsection embed
+
+@deffn Command embed stage1_5 device
+Embed the Stage 1.5 @var{stage1_5} in the sectors after the MBR if
+@var{device} is a drive, or in the @dfn{boot loader} area if @var{device}
+is a FFS partition or a ReiserFS partition.@footnote{The latter feature
+has not been implemented yet.} Print the number of sectors which
+@var{stage1_5} occupies, if successful.
+
+Usually, you don't need to run this command directly. @xref{setup}.
+@end deffn
+
+
+@node find
+@subsection find
+
+@deffn Command find filename
+Search for the file name @var{filename} in all mountable partitions
+and print the list of the devices which contain the file. The file
+name @var{filename} should be an absolute file name like
+@code{/boot/grub/stage1}.
+@end deffn
+
+
+@node fstest
+@subsection fstest
+
+@deffn Command fstest
+Toggle filesystem test mode.
+Filesystem test mode, when turned on, prints out data corresponding to
+all the device reads and what values are being sent to the low-level
+routines. The format is @samp{<@var{partition-offset-sector},
+@var{byte-offset}, @var{byte-length}>} for high-level reads inside a
+partition, and @samp{[@var{disk-offset-sector}]} for low-level sector
+requests from the disk.
+Filesystem test mode is turned off by any use of the @command{install}
+(@pxref{install}) or @command{testload} (@pxref{testload}) commands.
+@end deffn
+
+
+@node geometry
+@subsection geometry
+
+@deffn Command geometry drive [cylinder head sector [total_sector]]
+Print the information for the drive @var{drive}. In the grub shell, you
+can set the geometry of the drive arbitrarily. The number of
+cylinders, the number of heads, the number of sectors and the number of
+total sectors are set to CYLINDER, HEAD, SECTOR and TOTAL_SECTOR,
+respectively. If you omit TOTAL_SECTOR, then it will be calculated
+based on the C/H/S values automatically.
+@end deffn
+
+
+@node halt
+@subsection halt
+
+@deffn Command halt @option{--no-apm}
+The command halts the computer. If the @option{--no-apm} option
+is specified, no APM BIOS call is performed. Otherwise, the computer
+is shut down using APM.
+@end deffn
+
+
+@node help
+@subsection help
+
+@deffn Command help @option{--all} [pattern @dots{}]
+Display helpful information about builtin commands. If you do not
+specify @var{pattern}, this command shows short descriptions of most of
+available commands. If you specify the option @option{--all} to this
+command, short descriptions of rarely used commands (such as
+@ref{testload}) are displayed as well.
+
+If you specify any @var{patterns}, it displays longer information
+about each of the commands which match those @var{patterns}.
+@end deffn
+
+
+@node impsprobe
+@subsection impsprobe
+
+@deffn Command impsprobe
+Probe the Intel Multiprocessor Specification 1.1 or 1.4 configuration
+table and boot the various CPUs which are found into a tight loop. This
+command can be used only in the Stage 2, but not in the grub shell.
+@end deffn
+
+
+@node initrd
+@subsection initrd
+
+@deffn Command initrd file @dots{}
+Load an initial ramdisk for a Linux format boot image and set the
+appropriate parameters in the Linux setup area in memory. See also
+@ref{GNU/Linux}.
+@end deffn
+
+
+@node install
+@subsection install
+
+@deffn Command install [@option{--force-lba}] [@option{--stage2=os_stage2_file}] stage1_file [@option{d}] dest_dev stage2_file [addr] [@option{p}] [config_file] [real_config_file]
+This command is fairly complex, and you should not use this command
+unless you are familiar with GRUB. Use @command{setup} (@pxref{setup})
+instead.
+
+In short, it will perform a full install presuming the Stage 2 or Stage
+1.5@footnote{They're loaded the same way, so we will refer to the Stage
+1.5 as a Stage 2 from now on.} is in its final install location.
+
+In slightly more detail, it will load @var{stage1_file}, validate that
+it is a GRUB Stage 1 of the right version number, install in it a
+blocklist for loading @var{stage2_file} as a Stage 2. If the option
+@option{d} is present, the Stage 1 will always look for the actual
+disk @var{stage2_file} was installed on, rather than using the booting
+drive. The Stage 2 will be loaded at address @var{addr}, which must be
+@samp{0x8000} for a true Stage 2, and @samp{0x2000} for a Stage 1.5. If
+@var{addr} is not present, GRUB will determine the address
+automatically. It then writes the completed Stage 1 to the first block
+of the device @var{dest_dev}. If the options @option{p} or
+@var{config_file} are present, then it reads the first block of stage2,
+modifies it with the values of the partition @var{stage2_file} was found
+on (for @option{p}) or places the string @var{config_file} into the area
+telling the stage2 where to look for a configuration file at boot
+time. Likewise, if @var{real_config_file} is present and
+@var{stage2_file} is a Stage 1.5, then the Stage 2 @var{config_file} is
+patched with the configuration file name @var{real_config_file}. This
+command preserves the DOS BPB (and for hard disks, the partition table)
+of the sector the Stage 1 is to be installed into.
+
+@strong{Caution:} Several buggy BIOSes don't pass a booting drive
+properly when booting from a hard disk drive. Therefore, you will
+unfortunately have to specify the option @option{d}, whether your
+Stage2 resides at the booting drive or not, if you have such a
+BIOS. We know these are defective in this way:
+
+@table @asis
+@item
+Fujitsu LifeBook 400 BIOS version 31J0103A
+
+@item
+HP Vectra XU 6/200 BIOS version GG.06.11
+@end table
+
+@strong{Caution2:} A number of BIOSes don't return a correct LBA support
+bitmap even if they do have the support. So GRUB provides a solution to
+ignore the wrong bitmap, that is, the option @option{--force-lba}. Don't
+use this option if you know that your BIOS doesn't have LBA support.
+
+@strong{Caution3:} You must specify the option @option{--stage2} in the
+grub shell, if you cannot unmount the filesystem where your stage2 file
+resides. The argument should be the file name in your operating system.
+@end deffn
+
+
+@node ioprobe
+@subsection ioprobe
+
+@deffn Command ioprobe drive
+Probe I/O ports used for the drive @var{drive}. This command will list
+the I/O ports on the screen. For technical information,
+@xref{Internals}.
+@end deffn
+
+
+@node kernel
+@subsection kernel
+
+@deffn Command kernel [@option{--type=type}] [@option{--no-mem-option}] file @dots{}
+Attempt to load the primary boot image (Multiboot a.out or @sc{elf},
+Linux zImage or bzImage, FreeBSD a.out, NetBSD a.out, etc.) from
+@var{file}. The rest of the line is passed verbatim as the @dfn{kernel
+command-line}. Any modules must be reloaded after using this command.
+
+This command also accepts the option @option{--type} so that you can
+specify the kernel type of @var{file} explicitly. The argument
+@var{type} must be one of these: @samp{netbsd}, @samp{freebsd},
+@samp{openbsd}, @samp{linux}, @samp{biglinux}, and
+@samp{multiboot}. However, you need to specify it only if you want to
+load a NetBSD @sc{elf} kernel, because GRUB can automatically determine
+a kernel type in the other cases, quite safely.
+
+The option @option{--no-mem-option} is effective only for Linux. If the
+option is specified, GRUB doesn't pass the option @option{mem=} to the
+kernel.  This option is implied for Linux kernels 2.4.18 and newer.
+@end deffn
+
+
+@node lock
+@subsection lock
+
+@deffn Command lock
+Prevent normal users from executing arbitrary menu entries. You must use
+the command @command{password} if you really want this command to be
+useful (@pxref{password}).
+
+This command is used in a menu, as shown in this example:
+
+@example
+@group
+title This entry is too dangerous to be executed by normal users
+lock
+root (hd0,a)
+kernel /no-security-os
+@end group
+@end example
+
+See also @ref{Security}.
+@end deffn
+
+
+@node makeactive
+@subsection makeactive
+
+@deffn Command makeactive
+Set the active partition on the root disk to GRUB's root device.
+This command is limited to @emph{primary} PC partitions on a hard disk.
+@end deffn
+
+
+@node map
+@subsection map
+
+@deffn Command map to_drive from_drive
+Map the drive @var{from_drive} to the drive @var{to_drive}. This is
+necessary when you chain-load some operating systems, such as DOS, if
+such an OS resides at a non-first drive. Here is an example:
+
+@example
+@group
+grub> @kbd{map (hd0) (hd1)}
+grub> @kbd{map (hd1) (hd0)}
+@end group
+@end example
+
+The example exchanges the order between the first hard disk and the
+second hard disk. See also @ref{DOS/Windows}.
+@end deffn
+
+
+@node md5crypt
+@subsection md5crypt
+
+@deffn Command md5crypt
+Prompt to enter a password, and encrypt it in MD5 format. The encrypted
+password can be used with the command @command{password}
+(@pxref{password}). See also @ref{Security}.
+@end deffn
+
+
+@node module
+@subsection module
+
+@deffn Command module file @dots{}
+Load a boot module @var{file} for a Multiboot format boot image (no
+interpretation of the file contents are made, so the user of this
+command must know what the kernel in question expects). The rest of the
+line is passed as the @dfn{module command-line}, like the
+@command{kernel} command. You must load a Multiboot kernel image before
+loading any module. See also @ref{modulenounzip}.
+@end deffn
+
+
+@node modulenounzip
+@subsection modulenounzip
+
+@deffn Command modulenounzip file @dots{}
+The same as @command{module} (@pxref{module}), except that automatic
+decompression is disabled.
+@end deffn
+
+
+@node pause
+@subsection pause
+
+@deffn Command pause message @dots{}
+Print the @var{message}, then wait until a key is pressed. Note that
+placing @key{^G} (ASCII code 7) in the message will cause the speaker to
+emit the standard beep sound, which is useful when prompting the user to
+change floppies.
+@end deffn
+
+
+@node quit
+@subsection quit
+
+@deffn Command quit
+Exit from the grub shell @command{grub} (@pxref{Invoking the grub
+shell}). This command can be used only in the grub shell.
+@end deffn
+
+
+@node reboot
+@subsection reboot
+
+@deffn Command reboot
+Reboot the computer.
+@end deffn
+
+
+@node read
+@subsection read
+
+@deffn Command read addr
+Read a 32-bit value from memory at address @var{addr} and display it in
+hex format.
+@end deffn
+
+
+@node root
+@subsection root
+
+@deffn Command root device [hdbias]
+Set the current @dfn{root device} to the device @var{device}, then
+attempt to mount it to get the partition size (for passing the partition
+descriptor in @code{ES:ESI}, used by some chain-loaded boot loaders), the
+BSD drive-type (for booting BSD kernels using their native boot format),
+and correctly determine the PC partition where a BSD sub-partition is
+located. The optional @var{hdbias} parameter is a number to tell a BSD
+kernel how many BIOS drive numbers are on controllers before the current
+one. For example, if there is an IDE disk and a SCSI disk, and your
+FreeBSD root partition is on the SCSI disk, then use a @samp{1} for
+@var{hdbias}.
+
+See also @ref{rootnoverify}.
+@end deffn
+
+
+@node rootnoverify
+@subsection rootnoverify
+
+@deffn Command rootnoverify device [hdbias]
+Similar to @command{root} (@pxref{root}), but don't attempt to mount the
+partition. This is useful for when an OS is outside of the area of the
+disk that GRUB can read, but setting the correct root device is still
+desired. Note that the items mentioned in @command{root} above which
+derived from attempting the mount will @emph{not} work correctly.
+@end deffn
+
+
+@node savedefault
+@subsection savedefault
+
+@deffn Command savedefault num
+Save the current menu entry or @var{num} if specified as a default
+entry. Here is an example:
+
+@example
+@group
+default saved
+timeout 10
+
+title GNU/Linux
+root (hd0,0)
+kernel /boot/vmlinuz root=/dev/sda1 vga=ext
+initrd /boot/initrd
+savedefault
+
+title FreeBSD
+root (hd0,a)
+kernel /boot/loader
+savedefault
+@end group
+@end example
+
+With this configuration, GRUB will choose the entry booted previously as
+the default entry.
+
+You can specify @samp{fallback} instead of a number. Then, next
+fallback entry is saved. Next fallback entry is chosen from fallback
+entries. Normally, this will be the first entry in fallback ones.
+
+See also @ref{default} and @ref{Invoking grub-set-default}.
+@end deffn
+
+
+@node setup
+@subsection setup
+
+@deffn Command setup [@option{--force-lba}] [@option{--stage2=os_stage2_file}] [@option{--prefix=dir}] install_device [image_device]
+Set up the installation of GRUB automatically. This command uses the
+more flexible command @command{install} (@pxref{install}) in the backend
+and installs GRUB into the device @var{install_device}. If
+@var{image_device} is specified, then find the GRUB images
+(@pxref{Images}) in the device @var{image_device}, otherwise use the
+current @dfn{root device}, which can be set by the command
+@command{root}. If @var{install_device} is a hard disk, then embed a
+Stage 1.5 in the disk if possible.
+
+The option @option{--prefix} specifies the directory under which GRUB
+images are put. If it is not specified, GRUB automatically searches them
+in @file{/boot/grub} and @file{/grub}.
+
+The options @option{--force-lba} and @option{--stage2} are just passed
+to @command{install} if specified. @xref{install}, for more
+information.
+@end deffn
+
+
+@node testload
+@subsection testload
+
+@deffn Command testload file
+Read the entire contents of @var{file} in several different ways and
+compare them, to test the filesystem code. The output is somewhat
+cryptic, but if no errors are reported and the final @samp{i=@var{X},
+filepos=@var{Y}} reading has @var{X} and @var{Y} equal, then it is
+definitely consistent, and very likely works correctly subject to a
+consistent offset error. If this test succeeds, then a good next step is
+to try loading a kernel.
+@end deffn
+
+
+@node testvbe
+@subsection testvbe
+
+@deffn Command testvbe mode
+Test the VESA BIOS EXTENSION mode @var{mode}. This command will switch
+your video card to the graphics mode, and show an endless animation. Hit
+any key to return. See also @ref{vbeprobe}.
+@end deffn
+
+
+@node uppermem
+@subsection uppermem
+
+@deffn Command uppermem kbytes
+Force GRUB to assume that only @var{kbytes} kilobytes of upper memory
+are installed. Any system address range maps are discarded.
+
+@strong{Caution:} This should be used with great caution, and should
+only be necessary on some old machines. GRUB's BIOS probe can pick up
+all @sc{ram} on all new machines the author has ever heard of. It can
+also be used for debugging purposes to lie to an OS.
+@end deffn
+
+
+@node vbeprobe
+@subsection vbeprobe
+
+@deffn Command vbeprobe [mode]
+Probe VESA BIOS EXTENSION information. If the mode @var{mode} is
+specified, show only the information about @var{mode}. Otherwise, this
+command lists up available VBE modes on the screen. See also
+@ref{testvbe}.
+@end deffn
+
+
+@node Troubleshooting
+@chapter Error messages reported by GRUB
+
+This chapter describes error messages reported by GRUB when you
+encounter trouble. @xref{Invoking the grub shell}, if your problem is
+specific to the grub shell.
+
+@menu
+* Stage1 errors::               Errors reported by the Stage 1
+* Stage1.5 errors::             Errors reported by the Stage 1.5
+* Stage2 errors::               Errors reported by the Stage 2
+@end menu
+
+
+@node Stage1 errors
+@section Errors reported by the Stage 1
+
+The general way that the Stage 1 handles errors is to print an error
+string and then halt. Pressing @kbd{@key{CTRL}-@key{ALT}-@key{DEL}} will
+reboot.
+
+The following is a comprehensive list of error messages for the Stage 1:
+
+@table @asis
+@item Hard Disk Error
+The stage2 or stage1.5 is being read from a hard disk, and the attempt
+to determine the size and geometry of the hard disk failed.
+
+@item Floppy Error
+The stage2 or stage1.5 is being read from a floppy disk, and the attempt
+to determine the size and geometry of the floppy disk failed. It's listed
+as a separate error since the probe sequence is different than for hard
+disks.
+
+@item Read Error
+A disk read error happened while trying to read the stage2 or stage1.5.
+
+@item Geom Error
+The location of the stage2 or stage1.5 is not in the portion of the disk
+supported directly by the BIOS read calls.  This could occur because the
+BIOS translated geometry has been changed by the user or the disk is
+moved to another machine or controller after installation, or GRUB was
+not installed using itself (if it was, the Stage 2 version of this error
+would have been seen during that process and it would not have completed
+the install).
+@end table
+
+
+@node Stage1.5 errors
+@section Errors reported by the Stage 1.5
+
+The general way that the Stage 1.5 handles errors is to print an error
+number in the form @code{Error @var{num}} and then halt. Pressing
+@kbd{@key{CTRL}-@key{ALT}-@key{DEL}} will reboot.
+
+The error numbers correspond to the errors reported by Stage
+2. @xref{Stage2 errors}.
+
+
+@node Stage2 errors
+@section Errors reported by the Stage 2
+
+The general way that the Stage 2 handles errors is to abort the
+operation in question, print an error string, then (if possible) either
+continue based on the fact that an error occurred or wait for the user to
+deal with the error.
+
+The following is a comprehensive list of error messages for the Stage 2
+(error numbers for the Stage 1.5 are listed before the colon in each
+description):
+
+@table @asis
+@item 1 : Filename must be either an absolute filename or blocklist
+This error is returned if a file name is requested which doesn't fit the
+syntax/rules listed in the @ref{Filesystem}.
+
+@item 2 : Bad file or directory type
+This error is returned if a file requested is not a regular file, but
+something like a symbolic link, directory, or FIFO.
+
+@item 3 : Bad or corrupt data while decompressing file
+This error is returned if the run-length decompression code gets an
+internal error. This is usually from a corrupt file.
+
+@item 4 : Bad or incompatible header in compressed file
+This error is returned if the file header for a supposedly compressed
+file is bad.
+
+@item 5 : Partition table invalid or corrupt
+This error is returned if the sanity checks on the integrity of the
+partition table fail. This is a bad sign.
+
+@item 6 : Mismatched or corrupt version of stage1/stage2
+This error is returned if the install command points to incompatible
+or corrupt versions of the stage1 or stage2. It can't detect corruption
+in general, but this is a sanity check on the version numbers, which
+should be correct.
+
+@item 7 : Loading below 1MB is not supported
+This error is returned if the lowest address in a kernel is below the
+1MB boundary. The Linux zImage format is a special case and can be
+handled since it has a fixed loading address and maximum size.
+
+@item 8 : Kernel must be loaded before booting
+This error is returned if GRUB is told to execute the boot sequence
+without having a kernel to start.
+
+@item 9 : Unknown boot failure
+This error is returned if the boot attempt did not succeed for reasons
+which are unknown.
+
+@item 10 : Unsupported Multiboot features requested
+This error is returned when the Multiboot features word in the Multiboot
+header requires a feature that is not recognized. The point of this is
+that the kernel requires special handling which GRUB is probably
+unable to provide.
+
+@item 11 : Unrecognized device string
+This error is returned if a device string was expected, and the string
+encountered didn't fit the syntax/rules listed in the @ref{Filesystem}.
+
+@item 12 : Invalid device requested
+This error is returned if a device string is recognizable but does not
+fall under the other device errors.
+
+@item 13 : Invalid or unsupported executable format
+This error is returned if the kernel image being loaded is not
+recognized as Multiboot or one of the supported native formats (Linux
+zImage or bzImage, FreeBSD, or NetBSD).
+
+@item 14 : Filesystem compatibility error, cannot read whole file
+Some of the filesystem reading code in GRUB has limits on the length of
+the files it can read. This error is returned when the user runs into
+such a limit.
+
+@item 15 : File not found
+This error is returned if the specified file name cannot be found, but
+everything else (like the disk/partition info) is OK.
+
+@item 16 : Inconsistent filesystem structure
+This error is returned by the filesystem code to denote an internal
+error caused by the sanity checks of the filesystem structure on disk
+not matching what it expects. This is usually caused by a corrupt
+filesystem or bugs in the code handling it in GRUB.
+
+@item 17 : Cannot mount selected partition
+This error is returned if the partition requested exists, but the
+filesystem type cannot be recognized by GRUB.
+
+@item 18 : Selected cylinder exceeds maximum supported by BIOS
+This error is returned when a read is attempted at a linear block
+address beyond the end of the BIOS translated area. This generally
+happens if your disk is larger than the BIOS can handle (512MB for
+(E)IDE disks on older machines or larger than 8GB in general).
+
+@item 19 : Linux kernel must be loaded before initrd
+This error is returned if the initrd command is used before loading a
+Linux kernel.
+
+@item 20 : Multiboot kernel must be loaded before modules
+This error is returned if the module load command is used before loading
+a Multiboot kernel. It only makes sense in this case anyway, as GRUB has
+no idea how to communicate the presence of such modules to a
+non-Multiboot-aware kernel.
+
+@item 21 : Selected disk does not exist
+This error is returned if the device part of a device- or full file name
+refers to a disk or BIOS device that is not present or not recognized by
+the BIOS in the system.
+
+@item 22 : No such partition
+This error is returned if a partition is requested in the device part of
+a device- or full file name which isn't on the selected disk.
+
+@item 23 : Error while parsing number
+This error is returned if GRUB was expecting to read a number and
+encountered bad data.
+
+@item 24 : Attempt to access block outside partition
+This error is returned if a linear block address is outside of the disk
+partition. This generally happens because of a corrupt filesystem on the
+disk or a bug in the code handling it in GRUB (it's a great debugging
+tool).
+
+@item 25 : Disk read error
+This error is returned if there is a disk read error when trying to
+probe or read data from a particular disk.
+
+@item 26 : Too many symbolic links
+This error is returned if the link count is beyond the maximum
+(currently 5), possibly the symbolic links are looped.
+
+@item 27 : Unrecognized command
+This error is returned if an unrecognized command is entered on the
+command-line or in a boot sequence section of a configuration file and
+that entry is selected.
+
+@item 28 : Selected item cannot fit into memory
+This error is returned if a kernel, module, or raw file load command is
+either trying to load its data such that it won't fit into memory or it
+is simply too big.
+
+@item 29 : Disk write error
+This error is returned if there is a disk write error when trying to
+write to a particular disk. This would generally only occur during an
+install of set active partition command.
+
+@item 30 : Invalid argument
+This error is returned if an argument specified to a command is invalid.
+
+@item 31 : File is not sector aligned
+This error may occur only when you access a ReiserFS partition by
+block-lists (e.g. the command @command{install}). In this case, you
+should mount the partition with the @samp{-o notail} option.
+
+@item 32 : Must be authenticated
+This error is returned if you try to run a locked entry. You should
+enter a correct password before running such an entry.
+
+@item 33 : Serial device not configured
+This error is returned if you try to change your terminal to a serial
+one before initializing any serial device.
+
+@item 34 : No spare sectors on the disk
+This error is returned if a disk doesn't have enough spare space. This
+happens when you try to embed Stage 1.5 into the unused sectors after
+the MBR, but the first partition starts right after the MBR or they are
+used by EZ-BIOS.
+@end table
+
+
+@node Invoking the grub shell
+@chapter Invoking the grub shell
+
+This chapter documents the grub shell @command{grub}. Note that the grub
+shell is an emulator; it doesn't run under the native environment, so it
+sometimes does something wrong. Therefore, you shouldn't trust it too
+much. If there is anything wrong with it, don't hesitate to try the
+native GRUB environment, especially when it guesses a wrong map between
+BIOS drives and OS devices.
+
+@menu
+* Basic usage::                 How to use the grub shell
+* Installation under UNIX::     How to install GRUB via @command{grub}
+* Device map::                  The map between BIOS drives and OS devices
+@end menu
+
+
+@node Basic usage
+@section Introduction into the grub shell
+
+You can use the command @command{grub} for installing GRUB under your
+operating systems and for a testbed when you add a new feature into GRUB
+or when fixing a bug. @command{grub} is almost the same as the Stage 2,
+and, in fact, it shares the source code with the Stage 2 and you can use
+the same commands (@pxref{Commands}) in @command{grub}. It is emulated by
+replacing BIOS calls with UNIX system calls and libc functions.
+
+The command @command{grub} accepts the following options:
+
+@table @option
+@item --help
+Print a summary of the command-line options and exit.
+
+@item --version
+Print the version number of GRUB and exit.
+
+@item --verbose
+Print some verbose messages for debugging purpose.
+
+@item --device-map=@var{file}
+Use the device map file @var{file}. The format is described in
+@ref{Device map}.
+
+@item --no-floppy
+Do not probe any floppy drive. This option has no effect if the option
+@option{--device-map} is specified (@pxref{Device map}).
+
+@item --probe-second-floppy
+Probe the second floppy drive. If this option is not specified, the grub
+shell does not probe it, as that sometimes takes a long time. If you
+specify the device map file (@pxref{Device map}), the grub shell just
+ignores this option.
+
+@item --config-file=@var{file}
+Read the configuration file @var{file} instead of
+@file{/boot/grub/menu.lst}. The format is the same as the normal GRUB
+syntax. See @ref{Filesystem}, for more information.
+
+@item --boot-drive=@var{drive}
+Set the stage2 @var{boot_drive} to @var{drive}. This argument should be
+an integer (decimal, octal or hexadecimal).
+
+@item --install-partition=@var{par}
+Set the stage2 @var{install_partition} to @var{par}. This argument
+should be an integer (decimal, octal or hexadecimal).
+
+@item --no-config-file
+Do not use the configuration file even if it can be read.
+
+@item --no-curses
+Do not use the screen handling interface by the curses even if it is
+available.
+
+@item --batch
+This option has the same meaning as @samp{--no-config-file --no-curses}.
+
+@item --read-only
+Disable writing to any disk.
+
+@item --hold
+Wait until a debugger will attach. This option is useful when you want
+to debug the startup code.
+@end table
+
+
+@node Installation under UNIX
+@section How to install GRUB via @command{grub}
+
+The installation procedure is the same as under the @dfn{native} Stage
+2. @xref{Installation}, for more information. The command
+@command{grub}-specific information is described here.
+
+What you should be careful about is @dfn{buffer cache}. @command{grub}
+makes use of raw devices instead of filesystems that your operating
+systems serve, so there exists a potential problem that some cache
+inconsistency may corrupt your filesystems. What we recommend is:
+
+@itemize @bullet
+@item
+If you can unmount drives to which GRUB may write any amount of data,
+unmount them before running @command{grub}.
+
+@item
+If a drive cannot be unmounted but can be mounted with the read-only
+flag, mount it in read-only mode. That should be secure.
+
+@item
+If a drive must be mounted with the read-write flag, make sure that no
+activity is being done on it while the command @command{grub} is
+running.
+
+@item
+Reboot your operating system as soon as possible. This is probably not
+required if you follow the rules above, but reboot is the most secure
+way.
+@end itemize
+
+In addition, enter the command @command{quit} when you finish the
+installation. That is @emph{very important} because @command{quit} makes
+the buffer cache consistent. Do not push @key{C-c}.
+
+If you want to install GRUB non-interactively, specify @samp{--batch}
+option in the command-line. This is a simple example:
+
+@example
+@group
+#!/bin/sh
+
+# Use /usr/sbin/grub if you are on an older system.
+/sbin/grub --batch <<EOT 1>/dev/null 2>/dev/null
+root (hd0,0)
+setup (hd0)
+quit
+EOT
+@end group
+@end example
+
+
+@node Device map
+@section The map between BIOS drives and OS devices
+
+When you specify the option @option{--device-map} (@pxref{Basic usage}),
+the grub shell creates the @dfn{device map file} automatically unless it
+already exists. The file name @file{/boot/grub/device.map} is preferred.
+
+If the device map file exists, the grub shell reads it to map BIOS
+drives to OS devices. This file consists of lines like this:
+
+@example
+@var{device} @var{file}
+@end example
+
+@var{device} is a drive specified in the GRUB syntax (@pxref{Device
+syntax}), and @var{file} is an OS file, which is normally a device
+file.
+
+The reason why the grub shell gives you the device map file is that it
+cannot guess the map between BIOS drives and OS devices correctly in
+some environments. For example, if you exchange the boot sequence
+between IDE and SCSI in your BIOS, it gets the order wrong.
+
+Thus, edit the file if the grub shell makes a mistake. You can put any
+comments in the file if needed, as the grub shell assumes that a line is
+just a comment if the first character is @samp{#}.
+
+
+@node Invoking grub-install
+@chapter Invoking grub-install
+
+The program @command{grub-install} installs GRUB on your drive using the
+grub shell (@pxref{Invoking the grub shell}). You must specify the
+device name on which you want to install GRUB, like this:
+
+@example
+grub-install @var{install_device}
+@end example
+
+The device name @var{install_device} is an OS device name or a GRUB
+device name.
+
+@command{grub-install} accepts the following options:
+
+@table @option
+@item --help
+Print a summary of the command-line options and exit.
+
+@item --version
+Print the version number of GRUB and exit.
+
+@item --force-lba
+Force GRUB to use LBA mode even for a buggy BIOS. Use this option only
+if your BIOS doesn't work properly in LBA mode even though it supports
+LBA mode.
+
+@item --root-directory=@var{dir}
+Install GRUB images under the directory @var{dir} instead of the root
+directory. This option is useful when you want to install GRUB into a
+separate partition or a removable disk. Here is an example in which
+you have a separate @dfn{boot} partition which is mounted on
+@file{/boot}:
+
+@example
+@kbd{grub-install --root-directory=/boot hd0}
+@end example
+
+@item --grub-shell=@var{file}
+Use @var{file} as the grub shell. You can append arbitrary options to
+@var{file} after the file name, like this:
+
+@example
+@kbd{grub-install --grub-shell="grub --read-only" /dev/fd0}
+@end example
+
+@item --recheck
+Recheck the device map, even if @file{/boot/grub/device.map} already
+exists. You should use this option whenever you add/remove a disk
+into/from your computer.
+@end table
+
+
+@node Invoking grub-md5-crypt
+@chapter Invoking grub-md5-crypt
+
+The program @command{grub-md5-crypt} encrypts a password in MD5 format.
+This is just a frontend of the grub shell (@pxref{Invoking the grub
+shell}). Passwords encrypted by this program can be used with the
+command @command{password} (@pxref{password}).
+
+@command{grub-md5-crypt} accepts the following options:
+
+@table @option
+@item --help
+Print a summary of the command-line options and exit.
+
+@item --version
+Print the version information and exit.
+
+@item --grub-shell=@var{file}
+Use @var{file} as the grub shell.
+@end table
+
+
+@node Invoking grub-terminfo
+@chapter Invoking grub-terminfo
+
+The program @command{grub-terminfo} generates a terminfo command from
+a terminfo name (@pxref{terminfo}). The result can be used in the
+configuration file, to define escape sequences. Because GRUB assumes
+that your terminal is vt100-compatible by default, this would be
+useful only if your terminal is uncommon (such as vt52).
+
+@command{grub-terminfo} accepts the following options:
+
+@table @option
+@item --help
+Print a summary of the command-line options and exit.
+
+@item --version
+Print the version information and exit.
+@end table
+
+You must specify one argument to this command. For example:
+
+@example
+@kbd{grub-terminfo vt52}
+@end example
+
+
+@node Invoking grub-set-default
+@chapter Invoking grub-set-default
+
+The program @command{grub-set-default} sets the default boot entry for
+GRUB. This automatically creates a file named @file{default} under
+your GRUB directory (i.e. @file{/boot/grub}), if it is not
+present. This file is used to determine the default boot entry when
+GRUB boots up your system when you use @samp{default saved} in your
+configuration file (@pxref{default}), and to save next default boot
+entry when you use @samp{savedefault} in a boot entry
+(@pxref{savedefault}).
+
+@command{grub-set-default} accepts the following options:
+
+@table @option
+@item --help
+Print a summary of the command-line options and exit.
+
+@item --version
+Print the version information and exit.
+
+@item --root-directory=@var{dir}
+Use the directory @var{dir} instead of the root directory
+(i.e. @file{/}) to define the location of the default file. This
+is useful when you mount a disk which is used for another system.
+@end table
+
+You must specify a single argument to @command{grub-set-default}. This
+argument is normally the number of a default boot entry. For example,
+if you have this configuration file:
+
+@example
+@group
+default saved
+timeout 10
+
+title GNU/Hurd
+root (hd0,0)
+...
+
+title GNU/Linux
+root (hd0,1)
+...
+@end group
+@end example
+
+and if you want to set the next default boot entry to GNU/Linux, you
+may execute this command:
+
+@example
+@kbd{grub-set-default 1}
+@end example
+
+Because the entry for GNU/Linux is @samp{1}. Note that entries are
+counted from zero. So, if you want to specify GNU/Hurd here, then you
+should specify @samp{0}.
+
+This feature is very useful if you want to test a new kernel or to
+make your system quite robust. @xref{Making your system robust}, for
+more hints about how to set up a robust system.
+
+
+@node Invoking mbchk
+@chapter Invoking mbchk
+
+The program @command{mbchk} checks for the format of a Multiboot
+kernel. We recommend using this program before booting your own kernel
+by GRUB.
+
+@command{mbchk} accepts the following options:
+
+@table @option
+@item --help
+Print a summary of the command-line options and exit.
+
+@item --version
+Print the version number of GRUB and exit.
+
+@item --quiet
+Suppress all normal output.
+@end table
+
+
+@node Obtaining and Building GRUB
+@appendix How to obtain and build GRUB
+
+@quotation
+@strong{Caution:} GRUB requires binutils-2.9.1.0.23 or later because the
+GNU assembler has been changed so that it can produce real 16bits
+machine code between 2.9.1 and 2.9.1.0.x. See
+@uref{http://sources.redhat.com/binutils/}, to obtain information on
+how to get the latest version.
+@end quotation
+
+GRUB is available from the GNU alpha archive site
+@uref{ftp://alpha.gnu.org/gnu/grub} or any of its mirrors. The file
+will be named grub-version.tar.gz. The current version is
+@value{VERSION}, so the file you should grab is:
+
+@uref{ftp://alpha.gnu.org/gnu/grub/grub-@value{VERSION}.tar.gz}
+
+To unbundle GRUB use the instruction:
+
+@example
+@kbd{zcat grub-@value{VERSION}.tar.gz | tar xvf -}
+@end example
+
+which will create a directory called @file{grub-@value{VERSION}} with
+all the sources. You can look at the file @file{INSTALL} for detailed
+instructions on how to build and install GRUB, but you should be able to
+just do:
+
+@example
+@group
+@kbd{cd grub-@value{VERSION}}
+@kbd{./configure}
+@kbd{make install}
+@end group
+@end example
+
+This will install the grub shell @file{grub} (@pxref{Invoking the grub
+shell}), the Multiboot checker @file{mbchk} (@pxref{Invoking mbchk}),
+and the GRUB images. This will also install the GRUB manual.
+
+Also, the latest version is available from the CVS. See
+@uref{http://savannah.gnu.org/cvs/?group=grub} for more information.
+
+
+@node Reporting bugs
+@appendix Reporting bugs
+
+These are the guideline for how to report bugs. Take a look at this
+list below before you submit bugs:
+
+@enumerate
+@item
+Before getting unsettled, read this manual through and through. Also,
+see the @uref{http://www.gnu.org/software/grub/grub-faq.html, GNU GRUB FAQ}.
+
+@item
+Always mention the information on your GRUB. The version number and the
+configuration are quite important. If you build it yourself, write the
+options specified to the configure script and your operating system,
+including the versions of gcc and binutils.
+
+@item
+If you have trouble with the installation, inform us of how you
+installed GRUB. Don't omit error messages, if any. Just @samp{GRUB hangs
+up when it boots} is not enough.
+
+The information on your hardware is also essential. These are especially
+important: the geometries and the partition tables of your hard disk
+drives and your BIOS.
+
+@item
+If GRUB cannot boot your operating system, write down
+@emph{everything} you see on the screen. Don't paraphrase them, like
+@samp{The foo OS crashes with GRUB, even though it can boot with the
+bar boot loader just fine}. Mention the commands you executed, the
+messages printed by them, and information on your operating system
+including the version number.
+
+@item
+Explain what you wanted to do. It is very useful to know your purpose
+and your wish, and how GRUB didn't satisfy you.
+
+@item
+If you can investigate the problem yourself, please do. That will give
+you and us much more information on the problem. Attaching a patch is
+even better.
+
+When you attach a patch, make the patch in unified diff format, and
+write ChangeLog entries. But, even when you make a patch, don't forget
+to explain the problem, so that we can understand what your patch is
+for.
+
+@item
+Write down anything that you think might be related. Please understand
+that we often need to reproduce the same problem you encounterred in our
+environment. So your information should be sufficient for us to do the
+same thing---Don't forget that we cannot see your computer directly. If
+you are not sure whether to state a fact or leave it out, state it!
+Reporting too many things is much better than omitting something
+important.
+@end enumerate
+
+If you follow the guideline above, submit a report to the
+@uref{http://savannah.gnu.org/bugs/?group=grub, Bug Tracking System}.
+Alternatively, you can submit a report via electronic mail to
+@email{bug-grub@@gnu.org}, but we strongly recommend that you use the
+Bug Tracking System, because e-mail can be passed over easily.
+
+Once we get your report, we will try to fix the bugs.
+
+
+@node Future
+@appendix Where GRUB will go
+
+We started the next generation of GRUB, GRUB 2. This will include
+internationalization, dynamic module loading, real memory management,
+multiple architecture support, a scripting language, and many other
+nice feature. If you are interested in the development of GRUB 2, take
+a look at @uref{http://www.gnu.org/software/grub/grub.html, the
+homepage}.
+
+
+@c Separate the programming guide.
+@include internals.texi
+
+
+@node Index
+@unnumbered Index
+
+@c Currently, we use only the Concept Index.
+@printindex cp
+
+
+@bye
+
+Some notes:
+
+  This is the second attempt to rewrite the manual. The status is
+mostly complete, but I need to check the spelling by ispell, and add
+more indices. Perhaps I also have to let some English native speakers
+proofread this manual through. My English is syntactically almost
+perfect, but sometimes (often?) awful in the nuance. Hehe, I can't be an
+English poet for now.
diff -Naur grub-0.97/grub/asmstub.c grub-0.97-suse/grub/asmstub.c
--- grub-0.97/grub/asmstub.c	2005-02-16 18:45:14.000000000 -0200
+++ grub-0.97-suse/grub/asmstub.c	2006-09-09 17:00:13.000000000 -0300
@@ -43,6 +43,8 @@
 #include <termios.h>
 #include <signal.h>
 
+#include <sys/mman.h>
+
 #ifdef __linux__
 # include <sys/ioctl.h>		/* ioctl */
 # if !defined(__GLIBC__) || \
@@ -142,14 +144,30 @@
     }
 
   assert (grub_scratch_mem == 0);
-  scratch = malloc (0x100000 + EXTENDED_MEMSIZE + 15);
+#ifdef MAP_32BIT
+#define MY_MAP_SET MAP_PRIVATE | MAP_GROWSDOWN | MAP_ANONYMOUS | MAP_32BIT
+#else
+#define MY_MAP_SET MAP_PRIVATE | MAP_GROWSDOWN | MAP_ANONYMOUS
+#endif
+  scratch = mmap(NULL,
+                 0x100000 + EXTENDED_MEMSIZE + 15,
+                 PROT_EXEC | PROT_READ | PROT_WRITE,
+                 MY_MAP_SET,
+                 -1,
+                 0);
+
   assert (scratch);
   grub_scratch_mem = (char *) ((((int) scratch) >> 4) << 4);
 
   /* FIXME: simulate the memory holes using mprot, if available. */
 
   assert (disks == 0);
-  disks = malloc (NUM_DISKS * sizeof (*disks));
+  disks = mmap(NULL,
+               NUM_DISKS * sizeof (*disks),
+               PROT_EXEC | PROT_READ | PROT_WRITE,
+               MY_MAP_SET,
+               -1,
+               0);
   assert (disks);
   /* Initialize DISKS.  */
   for (i = 0; i < NUM_DISKS; i++)
@@ -215,9 +233,9 @@
   /* Release memory. */
   restore_device_map (device_map);
   device_map = 0;
-  free (disks);
+  munmap(disks, NUM_DISKS * sizeof (*disks));
   disks = 0;
-  free (scratch);
+  munmap(scratch, 0x100000 + EXTENDED_MEMSIZE + 15);
   grub_scratch_mem = 0;
 
   if (serial_device)
@@ -480,6 +498,32 @@
   return 0;
 }
 
+/* graphical menu functions .  */
+int
+gfx_init (gfx_data_t *gfx_data)
+{
+  return 0;
+}
+
+int
+gfx_done (gfx_data_t *gfx_data)
+{
+  return 0;
+}
+
+int
+gfx_input (gfx_data_t *gfx_data, int *menu_entry)
+{
+  return 0;
+}
+
+int
+gfx_setup_menu (gfx_data_t *gfx_data)
+{
+  return 0;
+}
+
+
 /* low-level timing info */
 int
 getrtsecs (void)
diff -Naur grub-0.97/grub/asmstub.c~ grub-0.97-suse/grub/asmstub.c~
--- grub-0.97/grub/asmstub.c~	1969-12-31 21:00:00.000000000 -0300
+++ grub-0.97-suse/grub/asmstub.c~	2006-09-09 17:00:12.000000000 -0300
@@ -0,0 +1,1301 @@
+/* asmstub.c - a version of shared_src/asm.S that works under Unix */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 1999,2000,2001,2002,2004  Free Software Foundation, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* Try to use glibc's transparant LFS support. */
+#define _LARGEFILE_SOURCE	1
+/* lseek becomes synonymous with lseek64.  */
+#define _FILE_OFFSET_BITS	64
+
+/* Simulator entry point. */
+int grub_stage2 (void);
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <assert.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <time.h>
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <setjmp.h>
+#include <sys/time.h>
+#include <termios.h>
+#include <signal.h>
+
+#ifdef __linux__
+# include <sys/ioctl.h>		/* ioctl */
+# if !defined(__GLIBC__) || \
+	((__GLIBC__ < 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ < 1)))
+/* Maybe libc doesn't have large file support.  */
+#  include <linux/unistd.h>	/* _llseek */
+# endif /* (GLIBC < 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR < 1)) */
+# ifndef BLKFLSBUF
+#  define BLKFLSBUF	_IO (0x12,97)	/* flush buffer cache */
+# endif /* ! BLKFLSBUF */
+#endif /* __linux__ */
+
+/* We want to prevent any circularararity in our stubs, as well as
+   libc name clashes. */
+#define WITHOUT_LIBC_STUBS 1
+#include <shared.h>
+#include <device.h>
+#include <serial.h>
+#include <term.h>
+
+/* Simulated memory sizes. */
+#define EXTENDED_MEMSIZE (3 * 1024 * 1024)	/* 3MB */
+#define CONVENTIONAL_MEMSIZE (640 * 1024)	/* 640kB */
+
+unsigned long install_partition = 0x20000;
+unsigned long boot_drive = 0;
+int saved_entryno = 0;
+char version_string[] = VERSION;
+char config_file[128] = "/boot/grub/menu.lst"; /* FIXME: arbitrary */
+unsigned long linux_text_len = 0;
+char *linux_data_tmp_addr = 0;
+char *linux_data_real_addr = 0;
+unsigned short io_map[IO_MAP_SIZE];
+struct apm_info apm_bios_info;
+
+/* Emulation requirements. */
+char *grub_scratch_mem = 0;
+
+struct geometry *disks = 0;
+
+/* The map between BIOS drives and UNIX device file names.  */
+char **device_map = 0;
+
+/* The jump buffer for exiting correctly.  */
+static jmp_buf env_for_exit;
+
+/* The current color for console.  */
+int console_current_color = A_NORMAL;
+
+/* The file descriptor for a serial device.  */
+static int serial_fd = -1;
+
+/* The file name of a serial device.  */
+static char *serial_device = 0;
+
+#ifdef SIMULATE_SLOWNESS_OF_SERIAL
+/* The speed of a serial device.  */
+static unsigned int serial_speed;
+#endif /* SIMULATE_SLOWNESS_OF_SERIAL */
+
+/* The main entry point into this mess. */
+int
+grub_stage2 (void)
+{
+  /* These need to be static, because they survive our stack transitions. */
+  static int status = 0;
+  static char *realstack;
+  char *scratch, *simstack;
+  int i;
+
+  auto void doit (void);
+  
+  /* We need a nested function so that we get a clean stack frame,
+     regardless of how the code is optimized. */
+  void doit (void)
+    {
+      /* Make sure our stack lives in the simulated memory area. */
+      asm volatile ("movl %%esp, %0\n\tmovl %1, %%esp\n"
+		    : "=&r" (realstack) : "r" (simstack));
+      
+      /* Do a setjmp here for the stop command.  */
+      if (! setjmp (env_for_exit))
+	{
+	  /* Actually enter the generic stage2 code.  */
+	  status = 0;
+	  init_bios_info ();
+	}
+      else
+	{
+	  /* If ERRNUM is non-zero, then set STATUS to non-zero.  */
+	  if (errnum)
+	    status = 1;
+	}
+      
+      /* Replace our stack before we use any local variables. */
+      asm volatile ("movl %0, %%esp\n" : : "r" (realstack));
+    }
+
+  assert (grub_scratch_mem == 0);
+  scratch = malloc (0x100000 + EXTENDED_MEMSIZE + 15);
+  assert (scratch);
+  grub_scratch_mem = (char *) ((((int) scratch) >> 4) << 4);
+
+  /* FIXME: simulate the memory holes using mprot, if available. */
+
+  assert (disks == 0);
+  disks = malloc (NUM_DISKS * sizeof (*disks));
+  assert (disks);
+  /* Initialize DISKS.  */
+  for (i = 0; i < NUM_DISKS; i++)
+    disks[i].flags = -1;
+
+  if (! init_device_map (&device_map, device_map_file, floppy_disks))
+    return 1;
+  
+  /* Check some invariants. */
+  assert ((SCRATCHSEG << 4) == SCRATCHADDR);
+  assert ((BUFFERSEG << 4) == BUFFERADDR);
+  assert (BUFFERADDR + BUFFERLEN == SCRATCHADDR);
+  assert (FSYS_BUF % 16 == 0);
+  assert (FSYS_BUF + FSYS_BUFLEN == BUFFERADDR);
+
+#ifdef HAVE_LIBCURSES
+  /* Get into char-at-a-time mode. */
+  if (use_curses)
+    {
+      initscr ();
+      cbreak ();
+      noecho ();
+      nonl ();
+      scrollok (stdscr, TRUE);
+      keypad (stdscr, TRUE);
+      wtimeout (stdscr, 100);
+      signal (SIGWINCH, SIG_IGN);
+    }
+#endif
+
+  /* Make sure that actual writing is done.  */
+  sync ();
+
+  /* Set our stack, and go for it. */
+  simstack = (char *) PROTSTACKINIT;
+  doit ();
+
+  /* I don't know if this is necessary really.  */
+  sync ();
+
+#ifdef HAVE_LIBCURSES
+  if (use_curses)
+    endwin ();
+#endif
+
+  /* Close off the file descriptors we used. */
+  for (i = 0; i < NUM_DISKS; i ++)
+    if (disks[i].flags != -1)
+      {
+#ifdef __linux__
+	/* In Linux, invalidate the buffer cache. In other OSes, reboot
+	   is one of the solutions...  */
+	ioctl (disks[i].flags, BLKFLSBUF, 0);
+#else
+# warning "In your operating system, the buffer cache will not be flushed."
+#endif
+	close (disks[i].flags);
+      }
+
+  if (serial_fd >= 0)
+    close (serial_fd);
+  
+  /* Release memory. */
+  restore_device_map (device_map);
+  device_map = 0;
+  free (disks);
+  disks = 0;
+  free (scratch);
+  grub_scratch_mem = 0;
+
+  if (serial_device)
+    free (serial_device);
+  serial_device = 0;
+  
+  /* Ahh... at last we're ready to return to caller. */
+  return status;
+}
+
+/* Assign DRIVE to a device name DEVICE.  */
+void
+assign_device_name (int drive, const char *device)
+{
+  /* If DRIVE is already assigned, free it.  */
+  if (device_map[drive])
+    free (device_map[drive]);
+
+  /* If the old one is already opened, close it.  */
+  if (disks[drive].flags != -1)
+    {
+      close (disks[drive].flags);
+      disks[drive].flags = -1;
+    }
+
+  /* Assign DRIVE to DEVICE.  */
+  if (! device)
+    device_map[drive] = 0;
+  else
+    device_map[drive] = strdup (device);
+}
+
+void
+stop (void)
+{
+#ifdef HAVE_LIBCURSES
+  if (use_curses)
+    endwin ();
+#endif
+
+  /* Jump to doit.  */
+  longjmp (env_for_exit, 1);
+}
+
+void
+grub_reboot (void)
+{
+  stop ();
+}
+
+void
+grub_halt (int no_apm)
+{
+  stop ();
+}
+
+/* calls for direct boot-loader chaining */
+void
+chain_stage1 (unsigned long segment, unsigned long offset,
+	      unsigned long part_table_addr)
+{
+  stop ();
+}
+
+
+void
+chain_stage2 (unsigned long segment, unsigned long offset, int second_sector)
+{
+  stop ();
+}
+
+
+/* do some funky stuff, then boot linux */
+void
+linux_boot (void)
+{
+  stop ();
+}
+
+
+/* For bzImage kernels. */
+void
+big_linux_boot (void)
+{
+  stop ();
+}
+
+
+/* booting a multiboot executable */
+void
+multi_boot (int start, int mb_info)
+{
+  stop ();
+}
+
+/* sets it to linear or wired A20 operation */
+void
+gateA20 (int linear)
+{
+  /* Nothing to do in the simulator. */
+}
+
+/* Set up the int15 handler.  */
+void
+set_int15_handler (void)
+{
+  /* Nothing to do in the simulator.  */
+}
+
+/* Restore the original int15 handler.  */
+void
+unset_int15_handler (void)
+{
+  /* Nothing to do in the simulator.  */
+}
+
+/* The key map.  */
+unsigned short bios_key_map[KEY_MAP_SIZE + 1];
+unsigned short ascii_key_map[KEY_MAP_SIZE + 1];
+
+/* Copy MAP to the drive map and set up the int13 handler.  */
+void
+set_int13_handler (unsigned short *map)
+{
+  /* Nothing to do in the simulator.  */
+}
+
+int
+get_code_end (void)
+{
+  /* Just return a little area for simulation. */
+  return BOOTSEC_LOCATION + (60 * 1024);
+}
+
+
+/* memory probe routines */
+int
+get_memsize (int type)
+{
+  if (! type)
+    return CONVENTIONAL_MEMSIZE >> 10;
+  else
+    return EXTENDED_MEMSIZE >> 10;
+}
+
+
+/* get_eisamemsize() :  return packed EISA memory map, lower 16 bits is
+ *		memory between 1M and 16M in 1K parts, upper 16 bits is
+ *		memory above 16M in 64K parts.  If error, return -1.
+ */
+int
+get_eisamemsize (void)
+{
+  return (EXTENDED_MEMSIZE >> 10);
+}
+
+
+#define MMAR_DESC_TYPE_AVAILABLE 1 /* available to OS */
+#define MMAR_DESC_TYPE_RESERVED 2 /* not available */
+#define MMAR_DESC_TYPE_ACPI_RECLAIM 3 /* usable by OS after reading ACPI */
+#define MMAR_DESC_TYPE_ACPI_NVS 4 /* required to save between NVS sessions */
+
+#define MMAR_DESC_LENGTH	20
+
+/* Fetch the next entry in the memory map and return the continuation
+   value.  DESC is a pointer to the descriptor buffer, and CONT is the
+   previous continuation value (0 to get the first entry in the
+   map).  */
+int
+get_mmap_entry (struct mmar_desc *desc, int cont)
+{
+  /* Record the memory map statically.  */
+  static struct mmar_desc desc_table[] =
+  {
+    /* The conventional memory.  */
+    {
+      MMAR_DESC_LENGTH,
+      0,
+      CONVENTIONAL_MEMSIZE,
+      MMAR_DESC_TYPE_AVAILABLE
+    },
+    /* BIOS RAM and ROM (such as video memory).  */
+    {
+      MMAR_DESC_LENGTH,
+      CONVENTIONAL_MEMSIZE,
+      0x100000 - CONVENTIONAL_MEMSIZE,
+      MMAR_DESC_TYPE_RESERVED
+    },
+    /* The extended memory.  */
+    {
+      MMAR_DESC_LENGTH,
+      0x100000,
+      EXTENDED_MEMSIZE,
+      MMAR_DESC_TYPE_AVAILABLE
+    }
+  };
+  
+  int num = sizeof (desc_table) / sizeof (*desc_table);
+
+  if (cont < 0 || cont >= num)
+    {
+      /* Should not happen.  */
+      desc->desc_len = 0;
+    }
+  else
+    {
+      /* Copy the entry.  */
+      *desc = desc_table[cont++];
+
+      /* If the next entry exists, return the index.  */
+      if (cont < num)
+	return cont;
+    }
+  
+  return 0;
+}
+
+/* Track the int13 handler.  */
+void
+track_int13 (int drive)
+{
+  /* Nothing to do in the simulator.  */
+}
+
+/* Get the ROM configuration table.  */
+unsigned long
+get_rom_config_table (void)
+{
+  return 0;
+}
+
+/* Get APM BIOS information.  */
+void
+get_apm_info (void)
+{
+  /* Nothing to do in the simulator.  */
+}
+
+/* Get VBE controller information.  */
+int
+get_vbe_controller_info (struct vbe_controller *controller)
+{
+  /* Always fails.  */
+  return 0;
+}
+
+/* Get VBE mode information.  */
+int
+get_vbe_mode_info (int mode_number, struct vbe_mode *mode)
+{
+  /* Always fails.  */
+  return 0;
+}
+
+/* Set VBE mode.  */
+int
+set_vbe_mode (int mode_number)
+{
+  /* Always fails.  */
+  return 0;
+}
+
+/* graphical menu functions .  */
+int
+gfx_init (gfx_data_t *gfx_data)
+{
+  return 0;
+}
+
+int
+gfx_done (gfx_data_t *gfx_data)
+{
+  return 0;
+}
+
+int
+gfx_input (gfx_data_t *gfx_data, int *menu_entry)
+{
+  return 0;
+}
+
+int
+gfx_setup_menu (gfx_data_t *gfx_data)
+{
+  return 0;
+}
+
+
+/* low-level timing info */
+int
+getrtsecs (void)
+{
+  /* FIXME: exact value is not important, so just return time_t for now. */
+  return time (0);
+}
+
+int
+currticks (void)
+{
+  struct timeval tv;
+  long csecs;
+  int ticks_per_csec, ticks_per_usec;
+
+  /* Note: 18.2 ticks/sec.  */
+
+  /* Get current time.  */
+  gettimeofday (&tv, 0);
+
+  /* Compute centiseconds.  */
+  csecs = tv.tv_sec / 10;
+
+  /* Ticks per centisecond.  */
+  ticks_per_csec = csecs * 182;
+
+  /* Ticks per microsecond.  */
+  ticks_per_usec = (((tv.tv_sec - csecs * 10) * 1000000 + tv.tv_usec)
+		    * 182 / 10000000);
+
+  /* Sum them.  */
+  return ticks_per_csec + ticks_per_usec;
+}
+
+/* displays an ASCII character.  IBM displays will translate some
+   characters to special graphical ones */
+void
+console_putchar (int c)
+{
+  /* Curses doesn't have VGA fonts.  */
+  switch (c)
+    {
+    case DISP_UL:
+      c = ACS_ULCORNER;
+      break;
+    case DISP_UR:
+      c = ACS_URCORNER;
+      break;
+    case DISP_LL:
+      c = ACS_LLCORNER;
+      break;
+    case DISP_LR:
+      c = ACS_LRCORNER;
+      break;
+    case DISP_HORIZ:
+      c = ACS_HLINE;
+      break;
+    case DISP_VERT:
+      c = ACS_VLINE;
+      break;
+    case DISP_LEFT:
+      c = ACS_LARROW;
+      break;
+    case DISP_RIGHT:
+      c = ACS_RARROW;
+      break;
+    case DISP_UP:
+      c = ACS_UARROW;
+      break;
+    case DISP_DOWN:
+      c = ACS_DARROW;
+      break;
+    default:
+      break;
+    }
+
+#ifdef HAVE_LIBCURSES
+  if (use_curses)
+    {
+      /* In ncurses, a newline is treated badly, so we emulate it in our
+	 own way.  */
+      if (c == '\n')
+	{
+	  int x, y;
+
+	  getyx (stdscr, y, x);
+	  if (y + 1 == LINES)
+	    scroll (stdscr);
+	  else
+	    move (y + 1, x);
+	}
+      else if (isprint (c))
+	{
+	  int x, y;
+
+	  getyx (stdscr, y, x);
+	  if (x + 1 == COLS)
+	    {
+	      console_putchar ('\r');
+	      console_putchar ('\n');
+	    }
+	  addch (c | console_current_color);
+	}
+      else
+	{
+	  addch (c);
+	}
+      
+#ifdef REFRESH_IMMEDIATELY
+      refresh ();
+#endif
+    }
+  else
+#endif
+    {
+      /* CR is not used in Unix.  */
+      if (c != '\r')
+	putchar (c);
+    }
+}
+
+/* The store for ungetch simulation. This is necessary, because
+   ncurses-1.9.9g is still used in the world and its ungetch is
+   completely broken.  */
+#ifdef HAVE_LIBCURSES
+static int save_char = ERR;
+#endif
+
+static int
+console_translate_key (int c)
+{
+  switch (c)
+    {
+    case KEY_LEFT:
+      return 2;
+    case KEY_RIGHT:
+      return 6;
+    case KEY_UP:
+      return 16;
+    case KEY_DOWN:
+      return 14;
+    case KEY_DC:
+      return 4;
+    case KEY_BACKSPACE:
+      return 8;
+    case KEY_HOME:
+      return 1;
+    case KEY_END:
+      return 5;
+    case KEY_PPAGE:
+      return 7;
+    case KEY_NPAGE:
+      return 3;
+    default:
+      break;
+    }
+
+  return c;
+}
+
+/* like 'getkey', but doesn't wait, returns -1 if nothing available */
+int
+console_checkkey (void)
+{
+#ifdef HAVE_LIBCURSES
+  if (use_curses)
+    {
+      int c;
+
+      /* Check for SAVE_CHAR. This should not be true, because this
+	 means checkkey is called twice continuously.  */
+      if (save_char != ERR)
+	return save_char;
+
+      c = getch ();
+      /* If C is not ERR, then put it back in the input queue.  */
+      if (c != ERR)
+	save_char = c;
+      return console_translate_key (c);
+    }
+#endif
+
+  /* Just pretend they hit the space bar, then read the real key when
+     they call getkey. */
+  return ' ';
+}
+
+/* returns packed BIOS/ASCII code */
+int
+console_getkey (void)
+{
+  int c;
+
+#ifdef HAVE_LIBCURSES
+  if (use_curses)
+    {
+      /* If checkkey has already got a character, then return it.  */
+      if (save_char != ERR)
+	{
+	  c = save_char;
+	  save_char = ERR;
+	  return console_translate_key (c);
+	}
+
+      wtimeout (stdscr, -1);
+      c = getch ();
+      wtimeout (stdscr, 100);
+    }
+  else
+#endif
+    c = getchar ();
+
+  /* Quit if we get EOF. */
+  if (c == -1)
+    stop ();
+  
+  return console_translate_key (c);
+}
+
+/* returns packed values, LSB+1 is x, LSB is y */
+int
+console_getxy (void)
+{
+  int y, x;
+#ifdef HAVE_LIBCURSES
+  if (use_curses)
+    getyx (stdscr, y, x);
+  else
+#endif
+  y = x = 0;
+  return (x << 8) | (y & 0xff);
+}
+
+void
+console_gotoxy (int x, int y)
+{
+#ifdef HAVE_LIBCURSES
+  if (use_curses)
+    move (y, x);
+#endif
+}
+
+/* low-level character I/O */
+void
+console_cls (void)
+{
+#ifdef HAVE_LIBCURSES
+  if (use_curses)
+    clear ();
+#endif
+}
+
+void
+console_setcolorstate (color_state state)
+{
+  console_current_color = 
+    (state == COLOR_STATE_HIGHLIGHT) ? A_REVERSE : A_NORMAL;
+}
+
+void
+console_setcolor (int normal_color, int highlight_color)
+{
+  /* Nothing to do.  */
+}
+
+int
+console_setcursor (int on)
+{
+  return 1;
+}
+
+/* Low-level disk I/O.  Our stubbed version just returns a file
+   descriptor, not the actual geometry. */
+int
+get_diskinfo (int drive, struct geometry *geometry)
+{
+  /* FIXME: this function is truly horrid.  We try opening the device,
+     then severely abuse the GEOMETRY->flags field to pass a file
+     descriptor to biosdisk.  Thank God nobody's looking at this comment,
+     or my reputation would be ruined. --Gord */
+
+  /* See if we have a cached device. */
+  if (disks[drive].flags == -1)
+    {
+      /* The unpartitioned device name: /dev/XdX */
+      char *devname = device_map[drive];
+      char buf[512];
+
+      if (! devname)
+	return -1;
+
+      if (verbose)
+	grub_printf ("Attempt to open drive 0x%x (%s)\n",
+		     drive, devname);
+
+      /* Open read/write, or read-only if that failed. */
+      if (! read_only)
+	disks[drive].flags = open (devname, O_RDWR);
+
+      if (disks[drive].flags == -1)
+	{
+	  if (read_only || errno == EACCES || errno == EROFS || errno == EPERM)
+	    {
+	      disks[drive].flags = open (devname, O_RDONLY);
+	      if (disks[drive].flags == -1)
+		{
+		  assign_device_name (drive, 0);
+		  return -1;
+		}
+	    }
+	  else
+	    {
+	      assign_device_name (drive, 0);
+	      return -1;
+	    }
+	}
+
+      /* Attempt to read the first sector.  */
+      if (read (disks[drive].flags, buf, 512) != 512)
+	{
+	  close (disks[drive].flags);
+	  disks[drive].flags = -1;
+	  assign_device_name (drive, 0);
+	  return -1;
+	}
+
+      if (disks[drive].flags != -1)
+	get_drive_geometry (&disks[drive], device_map, drive);
+    }
+
+  if (disks[drive].flags == -1)
+    return -1;
+
+#ifdef __linux__
+  /* In Linux, invalidate the buffer cache, so that left overs
+     from other program in the cache are flushed and seen by us */
+  ioctl (disks[drive].flags, BLKFLSBUF, 0);
+#endif
+
+  *geometry = disks[drive];
+  return 0;
+}
+
+/* Read LEN bytes from FD in BUF. Return less than or equal to zero if an
+   error occurs, otherwise return LEN.  */
+static int
+nread (int fd, char *buf, size_t len)
+{
+  int size = len;
+
+  while (len)
+    {
+      int ret = read (fd, buf, len);
+
+      if (ret <= 0)
+	{
+	  if (errno == EINTR)
+	    continue;
+	  else
+	    return ret;
+	}
+
+      len -= ret;
+      buf += ret;
+    }
+
+  return size;
+}
+
+/* Write LEN bytes from BUF to FD. Return less than or equal to zero if an
+   error occurs, otherwise return LEN.  */
+static int
+nwrite (int fd, char *buf, size_t len)
+{
+  int size = len;
+
+  while (len)
+    {
+      int ret = write (fd, buf, len);
+
+      if (ret <= 0)
+	{
+	  if (errno == EINTR)
+	    continue;
+	  else
+	    return ret;
+	}
+
+      len -= ret;
+      buf += ret;
+    }
+
+  return size;
+}
+
+/* Dump BUF in the format of hexadecimal numbers.  */
+static void
+hex_dump (void *buf, size_t size)
+{
+  /* FIXME: How to determine which length is readable?  */
+#define MAX_COLUMN	70
+
+  /* use unsigned char for numerical computations */
+  unsigned char *ptr = buf;
+  /* count the width of the line */
+  int column = 0;
+  /* how many bytes written */
+  int count = 0;
+
+  while (size > 0)
+    {
+      /* high 4 bits */
+      int hi = *ptr >> 4;
+      /* low 4 bits */
+      int low = *ptr & 0xf;
+
+      /* grub_printf does not handle prefix number, such as %2x, so
+	 format the number by hand...  */
+      grub_printf ("%x%x", hi, low);
+      column += 2;
+      count++;
+      ptr++;
+      size--;
+
+      /* Insert space or newline with the interval 4 bytes.  */
+      if (size != 0 && (count % 4) == 0)
+	{
+	  if (column < MAX_COLUMN)
+	    {
+	      grub_printf (" ");
+	      column++;
+	    }
+	  else
+	    {
+	      grub_printf ("\n");
+	      column = 0;
+	    }
+	}
+    }
+
+  /* Add a newline at the end for readability.  */
+  grub_printf ("\n");
+}
+
+int
+biosdisk (int subfunc, int drive, struct geometry *geometry,
+	  int sector, int nsec, int segment)
+{
+  char *buf;
+  int fd = geometry->flags;
+
+  /* Get the file pointer from the geometry, and make sure it matches. */
+  if (fd == -1 || fd != disks[drive].flags)
+    return BIOSDISK_ERROR_GEOMETRY;
+
+  /* Seek to the specified location. */
+#if defined(__linux__) && (!defined(__GLIBC__) || \
+	((__GLIBC__ < 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ < 1))))
+  /* Maybe libc doesn't have large file support.  */
+  {
+    loff_t offset, result;
+    static int _llseek (uint filedes, ulong hi, ulong lo,
+			loff_t *res, uint wh);
+    _syscall5 (int, _llseek, uint, filedes, ulong, hi, ulong, lo,
+	       loff_t *, res, uint, wh);
+
+    offset = (loff_t) sector * (loff_t) SECTOR_SIZE;
+    if (_llseek (fd, offset >> 32, offset & 0xffffffff, &result, SEEK_SET))
+      return -1;
+  }
+#else
+  {
+    off_t offset = (off_t) sector * (off_t) SECTOR_SIZE;
+
+    if (lseek (fd, offset, SEEK_SET) != offset)
+      return -1;
+  }
+#endif
+
+  buf = (char *) (segment << 4);
+
+  switch (subfunc)
+    {
+    case BIOSDISK_READ:
+#ifdef __linux__
+      if (sector == 0 && nsec > 1)
+	{
+	  /* Work around a bug in linux's ez remapping.  Linux remaps all
+	     sectors that are read together with the MBR in one read.  It
+	     should only remap the MBR, so we split the read in two 
+	     parts. -jochen  */
+	  if (nread (fd, buf, SECTOR_SIZE) != SECTOR_SIZE)
+	    return -1;
+	  buf += SECTOR_SIZE;
+	  nsec--;
+	}
+#endif
+      if (nread (fd, buf, nsec * SECTOR_SIZE) != nsec * SECTOR_SIZE)
+	return -1;
+      break;
+
+    case BIOSDISK_WRITE:
+      if (verbose)
+	{
+	  grub_printf ("Write %d sectors starting from %d sector"
+		       " to drive 0x%x (%s)\n",
+		       nsec, sector, drive, device_map[drive]);
+	  hex_dump (buf, nsec * SECTOR_SIZE);
+	}
+      if (! read_only)
+	if (nwrite (fd, buf, nsec * SECTOR_SIZE) != nsec * SECTOR_SIZE)
+	  return -1;
+      break;
+
+    default:
+      grub_printf ("unknown subfunc %d\n", subfunc);
+      break;
+    }
+
+  return 0;
+}
+
+
+void
+stop_floppy (void)
+{
+  /* NOTUSED */
+}
+
+/* Fetch a key from a serial device.  */
+int
+serial_hw_fetch (void)
+{
+  fd_set fds;
+  struct timeval to;
+  char c;
+
+  /* Wait only for the serial device.  */
+  FD_ZERO (&fds);
+  FD_SET (serial_fd, &fds);
+
+  to.tv_sec = 0;
+  to.tv_usec = 0;
+  
+  if (select (serial_fd + 1, &fds, 0, 0, &to) > 0)
+    {
+      if (nread (serial_fd, &c, 1) != 1)
+	stop ();
+
+      return c;
+    }
+  
+  return -1;
+}
+
+/* Put a character to a serial device.  */
+void
+serial_hw_put (int c)
+{
+  char ch = (char) c;
+  
+  if (nwrite (serial_fd, &ch, 1) != 1)
+    stop ();
+}
+
+void
+serial_hw_delay (void)
+{
+#ifdef SIMULATE_SLOWNESS_OF_SERIAL
+  struct timeval otv, tv;
+
+  gettimeofday (&otv, 0);
+
+  while (1)
+    {
+      long delta;
+      
+      gettimeofday (&tv, 0);
+      delta = tv.tv_usec - otv.tv_usec;
+      if (delta < 0)
+	delta += 1000000;
+      
+      if (delta >= 1000000 / (serial_speed >> 3))
+	break;
+    }
+#endif /* SIMULATE_SLOWNESS_OF_SERIAL */
+}
+
+static speed_t
+get_termios_speed (int speed)
+{
+  switch (speed)
+    {
+    case 2400: return B2400;
+    case 4800: return B4800;
+    case 9600: return B9600;
+    case 19200: return B19200;
+    case 38400: return B38400;
+#ifdef B57600
+    case 57600: return B57600;
+#endif
+#ifdef B115200      
+    case 115200: return B115200;
+#endif
+    }
+
+  return B0;
+}
+
+/* Get the port number of the unit UNIT. In the grub shell, this doesn't
+   make sense.  */
+unsigned short
+serial_hw_get_port (int unit)
+{
+  return 0;
+}
+
+/* Initialize a serial device. In the grub shell, PORT is unused.  */
+int
+serial_hw_init (unsigned short port, unsigned int speed,
+		int word_len, int parity, int stop_bit_len)
+{
+  struct termios termios;
+  speed_t termios_speed;
+  int i;
+  
+  /* Check if the file name is specified.  */
+  if (! serial_device)
+    return 0;
+
+  /* If a serial device is already opened, close it first.  */
+  if (serial_fd >= 0)
+    close (serial_fd);
+  
+  /* Open the device file.  */
+  serial_fd = open (serial_device,
+		    O_RDWR | O_NOCTTY
+#if defined(O_SYNC)
+		    /* O_SYNC is used in Linux (and some others?).  */
+		    | O_SYNC
+#elif defined(O_FSYNC)
+		    /* O_FSYNC is used in FreeBSD.  */
+		    | O_FSYNC
+#endif
+		    );
+  if (serial_fd < 0)
+    return 0;
+
+  /* Get the termios parameters.  */
+  if (tcgetattr (serial_fd, &termios))
+    goto fail;
+
+  /* Raw mode.  */
+  cfmakeraw (&termios);
+
+  /* Set the speed.  */
+  termios_speed = get_termios_speed (speed);
+  if (termios_speed == B0)
+    goto fail;
+  
+  cfsetispeed (&termios, termios_speed);
+  cfsetospeed (&termios, termios_speed);
+
+  /* Set the word length.  */
+  termios.c_cflag &= ~CSIZE;
+  switch (word_len)
+    {
+    case UART_5BITS_WORD:
+      termios.c_cflag |= CS5;
+      break;
+    case UART_6BITS_WORD:
+      termios.c_cflag |= CS6;
+      break;
+    case UART_7BITS_WORD:
+      termios.c_cflag |= CS7;
+      break;
+    case UART_8BITS_WORD:
+      termios.c_cflag |= CS8;
+      break;
+    default:
+      goto fail;
+    }
+
+  /* Set the parity.  */
+  switch (parity)
+    {
+    case UART_NO_PARITY:
+      termios.c_cflag &= ~PARENB;
+      break;
+    case UART_ODD_PARITY:
+      termios.c_cflag |= PARENB;
+      termios.c_cflag |= PARODD;
+      break;
+    case UART_EVEN_PARITY:
+      termios.c_cflag |= PARENB;
+      termios.c_cflag &= ~PARODD;
+      break;
+    default:
+      goto fail;
+    }
+
+  /* Set the length of stop bit.  */
+  switch (stop_bit_len)
+    {
+    case UART_1_STOP_BIT:
+      termios.c_cflag &= ~CSTOPB;
+      break;
+    case UART_2_STOP_BITS:
+      termios.c_cflag |= CSTOPB;
+      break;
+    default:
+      goto fail;
+    }
+
+  /* Set the parameters.  */
+  if (tcsetattr (serial_fd, TCSANOW, &termios))
+    goto fail;
+
+#ifdef SIMULATE_SLOWNESS_OF_SERIAL
+  serial_speed = speed;
+#endif /* SIMUATE_SLOWNESS_OF_SERIAL */
+
+  /* Get rid of the flag TERM_NEED_INIT from the serial terminal.  */
+  for (i = 0; term_table[i].name; i++)
+    {
+      if (strcmp (term_table[i].name, "serial") == 0)
+	{
+	  term_table[i].flags &= ~(TERM_NEED_INIT);
+	  break;
+	}
+    }
+  
+  return 1;
+
+ fail:
+  close (serial_fd);
+  serial_fd = -1;
+  return 0;
+}
+
+/* Set the file name of a serial device (or a pty device). This is a
+   function specific to the grub shell.  */
+void
+serial_set_device (const char *device)
+{
+  if (serial_device)
+    free (serial_device);
+  
+  serial_device = strdup (device);
+}
+
+/* There is no difference between console and hercules in the grub shell.  */
+void
+hercules_putchar (int c)
+{
+  console_putchar (c);
+}
+
+int
+hercules_getxy (void)
+{
+  return console_getxy ();
+}
+
+void
+hercules_gotoxy (int x, int y)
+{
+  console_gotoxy (x, y);
+}
+
+void
+hercules_cls (void)
+{
+  console_cls ();
+}
+
+void
+hercules_setcolorstate (color_state state)
+{
+  console_setcolorstate (state);
+}
+
+void
+hercules_setcolor (int normal_color, int highlight_color)
+{
+  console_setcolor (normal_color, highlight_color);
+}
+
+int
+hercules_setcursor (int on)
+{
+  return 1;
+}
diff -Naur grub-0.97/grub/main.c grub-0.97-suse/grub/main.c
--- grub-0.97/grub/main.c	2003-07-09 08:45:36.000000000 -0300
+++ grub-0.97-suse/grub/main.c	2006-09-09 17:00:12.000000000 -0300
@@ -44,7 +44,7 @@
 int verbose = 0;
 int read_only = 0;
 int floppy_disks = 1;
-char *device_map_file = 0;
+char *device_map_file = "/boot/grub/device.map";
 static int default_boot_drive;
 static int default_install_partition;
 static char *default_config_file;
diff -Naur grub-0.97/lib/device.c grub-0.97-suse/lib/device.c
--- grub-0.97/lib/device.c	2005-03-27 20:14:25.000000000 -0300
+++ grub-0.97-suse/lib/device.c	2006-09-09 17:00:12.000000000 -0300
@@ -515,6 +515,7 @@
      probing devices.  */
   char buf[1024];		/* XXX */
   int line_number = 0;
+  int retval = 0;		/* default to failure */
   
   while (fgets (buf, sizeof (buf), fp))
     {
@@ -541,14 +542,14 @@
       if (*ptr != '(')
 	{
 	  show_error (line_number, "No open parenthesis found");
-	  return 0;
+	  continue;
 	}
       
       ptr++;
       if ((*ptr != 'f' && *ptr != 'h') || *(ptr + 1) != 'd')
 	{
 	  show_error (line_number, "Bad drive name");
-	  return 0;
+	  continue;
 	}
       
       if (*ptr == 'f')
@@ -559,7 +560,7 @@
       if (drive < 0)
 	{
 	  show_error (line_number, "Bad device number");
-	  return 0;
+	  continue;
 	}
       else if (drive > 127)
 	{
@@ -575,7 +576,7 @@
       if (*ptr != ')')
 	{
 	  show_error (line_number, "No close parenthesis found");
-	  return 0;
+	  continue;
 	}
       
       ptr++;
@@ -586,7 +587,7 @@
       if (! *ptr)
 	{
 	  show_error (line_number, "No filename found");
-	  return 0;
+	  continue;
 	}
       
       /* Terminate the filename.  */
@@ -604,9 +605,11 @@
       
       map[drive] = strdup (ptr);
       assert (map[drive]);
+
+      retval = 1;	/* at least 1 drive configured successfully */
     }
   
-  return 1;
+  return retval;
 }
 
 /* Initialize the device map MAP. *MAP will be allocated from the heap
@@ -831,9 +834,11 @@
 is_disk_device (char **map, int drive)
 {
   struct stat st;
+  int retval;
   
   assert (map[drive] != 0);
-  assert (stat (map[drive], &st) == 0);
+  retval = stat (map[drive], &st);
+  assert (retval == 0);
   /* For now, disk devices under Linux are all block devices.  */
   return S_ISBLK (st.st_mode);
 }
@@ -843,7 +848,7 @@
 		    int sector, int size, const char *buf)
 {
   char dev[PATH_MAX];	/* XXX */
-  int fd;
+  int fd, len, pnum;
   
   if ((partition & 0x00FF00) != 0x00FF00)
     {
@@ -861,7 +866,16 @@
       if (strcmp (dev + strlen(dev) - 5, "/disc") == 0)
 	strcpy (dev + strlen(dev) - 5, "/part");
     }
-  sprintf (dev + strlen(dev), "%d", ((partition >> 16) & 0xFF) + 1);
+
+  len = strlen(dev);
+  pnum = ((partition >> 16) & 0xFF);
+  if (isdigit(dev[len-1]))
+    {
+      /* It is obviously some RAID disk: "/dev/<dsk>/c0d0" . "p1" */
+      sprintf (dev + len, "p%d",  pnum + 1);
+    }
+  else
+    sprintf (dev + len, "%d",  pnum + 1);
   
   /* Open the partition.  */
   fd = open (dev, O_RDWR);
diff -Naur grub-0.97/lib/device.c~ grub-0.97-suse/lib/device.c~
--- grub-0.97/lib/device.c~	1969-12-31 21:00:00.000000000 -0300
+++ grub-0.97-suse/lib/device.c~	2006-09-09 17:00:12.000000000 -0300
@@ -0,0 +1,917 @@
+/* device.c - Some helper functions for OS devices and BIOS drives */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 1999,2000,2001,2002,2003,2004,2005  Free Software Foundation, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* Try to use glibc's transparant LFS support. */
+#define _LARGEFILE_SOURCE       1
+/* lseek becomes synonymous with lseek64.  */
+#define _FILE_OFFSET_BITS       64
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <assert.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdarg.h>
+
+#ifdef __linux__
+# if !defined(__GLIBC__) || \
+        ((__GLIBC__ < 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ < 1)))
+/* Maybe libc doesn't have large file support.  */
+#  include <linux/unistd.h>     /* _llseek */
+# endif /* (GLIBC < 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR < 1)) */
+# include <sys/ioctl.h>		/* ioctl */
+# ifndef HDIO_GETGEO
+#  define HDIO_GETGEO	0x0301	/* get device geometry */
+/* If HDIO_GETGEO is not defined, it is unlikely that hd_geometry is
+   defined.  */
+struct hd_geometry
+{
+  unsigned char heads;
+  unsigned char sectors;
+  unsigned short cylinders;
+  unsigned long start;
+};
+# endif /* ! HDIO_GETGEO */
+# ifndef FLOPPY_MAJOR
+#  define FLOPPY_MAJOR	2	/* the major number for floppy */
+# endif /* ! FLOPPY_MAJOR */
+# ifndef MAJOR
+#  define MAJOR(dev)	\
+  ({ \
+     unsigned long long __dev = (dev); \
+     (unsigned) ((__dev >> 8) & 0xfff) \
+                 | ((unsigned int) (__dev >> 32) & ~0xfff); \
+  })
+# endif /* ! MAJOR */
+# ifndef CDROM_GET_CAPABILITY
+#  define CDROM_GET_CAPABILITY	0x5331	/* get capabilities */
+# endif /* ! CDROM_GET_CAPABILITY */
+# ifndef BLKGETSIZE
+#  define BLKGETSIZE	_IO(0x12,96)	/* return device size */
+# endif /* ! BLKGETSIZE */
+#endif /* __linux__ */
+
+/* Use __FreeBSD_kernel__ instead of __FreeBSD__ for compatibility with
+   kFreeBSD-based non-FreeBSD systems (e.g. GNU/kFreeBSD) */
+#if defined(__FreeBSD__) && ! defined(__FreeBSD_kernel__)
+# define __FreeBSD_kernel__
+#endif
+#ifdef __FreeBSD_kernel__
+  /* Obtain version of kFreeBSD headers */
+# include <osreldate.h>
+# ifndef __FreeBSD_kernel_version
+#  define __FreeBSD_kernel_version __FreeBSD_version
+# endif
+
+  /* Runtime detection of kernel */
+# include <sys/utsname.h>
+int
+get_kfreebsd_version ()
+{
+  struct utsname uts;
+  int major; int minor, v[2];
+
+  uname (&uts);
+  sscanf (uts.release, "%d.%d", &major, &minor);
+
+  if (major >= 9)
+    major = 9;
+  if (major >= 5)
+    {
+      v[0] = minor/10; v[1] = minor%10;
+    }
+  else
+    {
+      v[0] = minor%10; v[1] = minor/10;
+    }
+  return major*100000+v[0]*10000+v[1]*1000;
+}
+#endif /* __FreeBSD_kernel__ */
+
+#if defined(__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__OpenBSD__)
+# include <sys/ioctl.h>		/* ioctl */
+# include <sys/disklabel.h>
+# include <sys/cdio.h>		/* CDIOCCLRDEBUG */
+# if defined(__FreeBSD_kernel__)
+#  include <sys/param.h>
+#  if __FreeBSD_kernel_version >= 500040
+#   include <sys/disk.h>
+#  endif
+# endif /* __FreeBSD_kernel__ */
+#endif /* __FreeBSD_kernel__ || __NetBSD__ || __OpenBSD__ */
+
+#ifdef HAVE_OPENDISK
+# include <util.h>
+#endif /* HAVE_OPENDISK */
+
+#define WITHOUT_LIBC_STUBS	1
+#include <shared.h>
+#include <device.h>
+
+/* Get the geometry of a drive DRIVE.  */
+void
+get_drive_geometry (struct geometry *geom, char **map, int drive)
+{
+  int fd;
+
+  if (geom->flags == -1)
+    {
+      fd = open (map[drive], O_RDONLY);
+      assert (fd >= 0);
+    }
+  else
+    fd = geom->flags;
+
+  /* XXX This is the default size.  */
+  geom->sector_size = SECTOR_SIZE;
+  
+#if defined(__linux__)
+  /* Linux */
+  {
+    struct hd_geometry hdg;
+    unsigned long nr;
+    
+    if (ioctl (fd, HDIO_GETGEO, &hdg))
+      goto fail;
+
+    if (ioctl (fd, BLKGETSIZE, &nr))
+      goto fail;
+    
+    /* Got the geometry, so save it. */
+    geom->cylinders = hdg.cylinders;
+    geom->heads = hdg.heads;
+    geom->sectors = hdg.sectors;
+    geom->total_sectors = nr;
+    
+    goto success;
+  }
+
+#elif defined(__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__OpenBSD__)
+# if defined(__FreeBSD_kernel__) && __FreeBSD_kernel_version >= 500040
+  /* kFreeBSD version 5 or later */
+  if (get_kfreebsd_version () >= 500040)
+  {
+    unsigned int sector_size;
+    off_t media_size;
+    unsigned int tmp;
+    
+    if(ioctl (fd, DIOCGSECTORSIZE, &sector_size) != 0)
+      sector_size = 512;
+    
+    if (ioctl (fd, DIOCGMEDIASIZE, &media_size) != 0)
+      goto fail;
+
+    geom->total_sectors = media_size / sector_size;
+    
+    if (ioctl (fd, DIOCGFWSECTORS, &tmp) == 0)
+      geom->sectors = tmp;
+    else
+      geom->sectors = 63;
+    if (ioctl (fd, DIOCGFWHEADS, &tmp) == 0)
+      geom->heads = tmp;
+    else if (geom->total_sectors <= 63 * 1 * 1024)
+      geom->heads = 1;
+    else if (geom->total_sectors <= 63 * 16 * 1024)
+      geom->heads = 16;
+    else
+      geom->heads = 255;
+
+    geom->cylinders = (geom->total_sectors
+			   / geom->heads
+			   / geom->sectors);
+    
+    goto success;
+  }
+  else
+#endif /* defined(__FreeBSD_kernel__) && __FreeBSD_kernel_version >= 500040 */
+
+  /* kFreeBSD < 5, NetBSD or OpenBSD */
+  {
+    struct disklabel hdg;
+    if (ioctl (fd, DIOCGDINFO, &hdg))
+      goto fail;
+    
+    geom->cylinders = hdg.d_ncylinders;
+    geom->heads = hdg.d_ntracks;
+    geom->sectors = hdg.d_nsectors;
+    geom->total_sectors = hdg.d_secperunit;
+
+    goto success;
+  }
+  
+#else
+  /* Notably, defined(__GNU__) */
+# warning "Automatic detection of geometries will be performed only \
+partially. This is not fatal."
+#endif
+
+ fail:
+  {
+    struct stat st;
+
+    /* FIXME: It would be nice to somehow compute fake C/H/S settings,
+       given a proper st_blocks size. */
+    if (drive & 0x80)
+      {
+	geom->cylinders = DEFAULT_HD_CYLINDERS;
+	geom->heads = DEFAULT_HD_HEADS;
+	geom->sectors = DEFAULT_HD_SECTORS;
+      }
+    else
+      {
+	geom->cylinders = DEFAULT_FD_CYLINDERS;
+	geom->heads = DEFAULT_FD_HEADS;
+	geom->sectors = DEFAULT_FD_SECTORS;
+      }
+
+    /* Set the total sectors properly, if we can. */
+    if (! fstat (fd, &st) && st.st_size)
+      geom->total_sectors = st.st_size >> SECTOR_BITS;
+    else
+      geom->total_sectors = geom->cylinders * geom->heads * geom->sectors;
+  }
+
+ success:
+  if (geom->flags == -1)
+    close (fd);
+}
+
+#ifdef __linux__
+/* Check if we have devfs support.  */
+static int
+have_devfs (void)
+{
+  static int dev_devfsd_exists = -1;
+  
+  if (dev_devfsd_exists < 0)
+    {
+      struct stat st;
+      
+      dev_devfsd_exists = stat ("/dev/.devfsd", &st) == 0;
+    }
+  
+  return dev_devfsd_exists;
+}
+#endif /* __linux__ */
+
+/* These three functions are quite different among OSes.  */
+static void
+get_floppy_disk_name (char *name, int unit)
+{
+#if defined(__linux__)
+  /* GNU/Linux */
+  if (have_devfs ())
+    sprintf (name, "/dev/floppy/%d", unit);
+  else
+    sprintf (name, "/dev/fd%d", unit);
+#elif defined(__GNU__)
+  /* GNU/Hurd */
+  sprintf (name, "/dev/fd%d", unit);
+#elif defined(__FreeBSD_kernel__)
+  /* kFreeBSD */
+  if (get_kfreebsd_version () >= 400000)
+    sprintf (name, "/dev/fd%d", unit);
+  else
+    sprintf (name, "/dev/rfd%d", unit);
+#elif defined(__NetBSD__)
+  /* NetBSD */
+  /* opendisk() doesn't work for floppies.  */
+  sprintf (name, "/dev/rfd%da", unit);
+#elif defined(__OpenBSD__)
+  /* OpenBSD */
+  sprintf (name, "/dev/rfd%dc", unit);
+#elif defined(__QNXNTO__)
+  /* QNX RTP */
+  sprintf (name, "/dev/fd%d", unit);
+#else
+# warning "BIOS floppy drives cannot be guessed in your operating system."
+  /* Set NAME to a bogus string.  */
+  *name = 0;
+#endif
+}
+
+static void
+get_ide_disk_name (char *name, int unit)
+{
+#if defined(__linux__)
+  /* GNU/Linux */
+  sprintf (name, "/dev/hd%c", unit + 'a');
+#elif defined(__GNU__)
+  /* GNU/Hurd */
+  sprintf (name, "/dev/hd%d", unit);
+#elif defined(__FreeBSD_kernel__)
+  /* kFreeBSD */
+  if (get_kfreebsd_version () >= 400000)
+    sprintf (name, "/dev/ad%d", unit);
+  else
+    sprintf (name, "/dev/rwd%d", unit);
+#elif defined(__NetBSD__) && defined(HAVE_OPENDISK)
+  /* NetBSD */
+  char shortname[16];
+  int fd;
+  
+  sprintf (shortname, "wd%d", unit);
+  fd = opendisk (shortname, O_RDONLY, name,
+		 16,	/* length of NAME */
+		 0	/* char device */
+		 );
+  close (fd);
+#elif defined(__OpenBSD__)
+  /* OpenBSD */
+  sprintf (name, "/dev/rwd%dc", unit);
+#elif defined(__QNXNTO__)
+  /* QNX RTP */
+  /* Actually, QNX RTP doesn't distinguish IDE from SCSI, so this could
+     contain SCSI disks.  */
+  sprintf (name, "/dev/hd%d", unit);
+#else
+# warning "BIOS IDE drives cannot be guessed in your operating system."
+  /* Set NAME to a bogus string.  */
+  *name = 0;
+#endif
+}
+
+static void
+get_scsi_disk_name (char *name, int unit)
+{
+#if defined(__linux__)
+  /* GNU/Linux */
+  sprintf (name, "/dev/sd%c", unit + 'a');
+#elif defined(__GNU__)
+  /* GNU/Hurd */
+  sprintf (name, "/dev/sd%d", unit);
+#elif defined(__FreeBSD_kernel__)
+  /* kFreeBSD */
+  if (get_kfreebsd_version () >= 400000)
+    sprintf (name, "/dev/da%d", unit);
+  else
+    sprintf (name, "/dev/rda%d", unit);
+#elif defined(__NetBSD__) && defined(HAVE_OPENDISK)
+  /* NetBSD */
+  char shortname[16];
+  int fd;
+  
+  sprintf (shortname, "sd%d", unit);
+  fd = opendisk (shortname, O_RDONLY, name,
+		 16,	/* length of NAME */
+		 0	/* char device */
+		 );
+  close (fd);
+#elif defined(__OpenBSD__)
+  /* OpenBSD */
+  sprintf (name, "/dev/rsd%dc", unit);
+#elif defined(__QNXNTO__)
+  /* QNX RTP */
+  /* QNX RTP doesn't distinguish SCSI from IDE, so it is better to
+     disable the detection of SCSI disks here.  */
+  *name = 0;
+#else
+# warning "BIOS SCSI drives cannot be guessed in your operating system."
+  /* Set NAME to a bogus string.  */
+  *name = 0;
+#endif
+}
+
+#ifdef __linux__
+static void
+get_dac960_disk_name (char *name, int controller, int drive)
+{
+  sprintf (name, "/dev/rd/c%dd%d", controller, drive);
+}
+
+static void
+get_ataraid_disk_name (char *name, int unit)
+{
+  sprintf (name, "/dev/ataraid/d%c", unit + '0');
+}
+#endif
+
+/* Check if DEVICE can be read. If an error occurs, return zero,
+   otherwise return non-zero.  */
+int
+check_device (const char *device)
+{
+  char buf[512];
+  FILE *fp;
+
+  /* If DEVICE is empty, just return 1.  */
+  if (*device == 0)
+    return 1;
+  
+  fp = fopen (device, "r");
+  if (! fp)
+    {
+      switch (errno)
+	{
+#ifdef ENOMEDIUM
+	case ENOMEDIUM:
+# if 0
+	  /* At the moment, this finds only CDROMs, which can't be
+	     read anyway, so leave it out. Code should be
+	     reactivated if `removable disks' and CDROMs are
+	     supported.  */
+	  /* Accept it, it may be inserted.  */
+	  return 1;
+# endif
+	  break;
+#endif /* ENOMEDIUM */
+	default:
+	  /* Break case and leave.  */
+	  break;
+	}
+      /* Error opening the device.  */
+      return 0;
+    }
+  
+  /* Make sure CD-ROMs don't get assigned a BIOS disk number 
+     before SCSI disks!  */
+#ifdef __linux__
+# ifdef CDROM_GET_CAPABILITY
+  if (ioctl (fileno (fp), CDROM_GET_CAPABILITY, 0) >= 0)
+    return 0;
+# else /* ! CDROM_GET_CAPABILITY */
+  /* Check if DEVICE is a CD-ROM drive by the HDIO_GETGEO ioctl.  */
+  {
+    struct hd_geometry hdg;
+    struct stat st;
+
+    if (fstat (fileno (fp), &st))
+      return 0;
+
+    /* If it is a block device and isn't a floppy, check if HDIO_GETGEO
+       succeeds.  */
+    if (S_ISBLK (st.st_mode)
+	&& MAJOR (st.st_rdev) != FLOPPY_MAJOR
+	&& ioctl (fileno (fp), HDIO_GETGEO, &hdg))
+      return 0;
+  }
+# endif /* ! CDROM_GET_CAPABILITY */
+#endif /* __linux__ */
+
+#if defined(__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__OpenBSD__)
+# ifdef CDIOCCLRDEBUG
+  if (ioctl (fileno (fp), CDIOCCLRDEBUG, 0) >= 0)
+    return 0;
+# endif /* CDIOCCLRDEBUG */
+#endif /* __FreeBSD_kernel__ || __NetBSD__ || __OpenBSD__ */
+  
+  /* Attempt to read the first sector.  */
+  if (fread (buf, 1, 512, fp) != 512)
+    {
+      fclose (fp);
+      return 0;
+    }
+  
+  fclose (fp);
+  return 1;
+}
+
+/* Read mapping information from FP, and write it to MAP.  */
+static int
+read_device_map (FILE *fp, char **map, const char *map_file)
+{
+  auto void show_error (int no, const char *msg);
+  auto void show_warning (int no, const char *msg, ...);
+  
+  auto void show_error (int no, const char *msg)
+    {
+      fprintf (stderr, "%s:%d: error: %s\n", map_file, no, msg);
+    }
+  
+  auto void show_warning (int no, const char *msg, ...)
+    {
+      va_list ap;
+      
+      va_start (ap, msg);
+      fprintf (stderr, "%s:%d: warning: ", map_file, no);
+      vfprintf (stderr, msg, ap);
+      va_end (ap);
+    }
+  
+  /* If there is the device map file, use the data in it instead of
+     probing devices.  */
+  char buf[1024];		/* XXX */
+  int line_number = 0;
+  
+  while (fgets (buf, sizeof (buf), fp))
+    {
+      char *ptr, *eptr;
+      int drive;
+      int is_floppy = 0;
+      
+      /* Increase the number of lines.  */
+      line_number++;
+      
+      /* If the first character is '#', skip it.  */
+      if (buf[0] == '#')
+	continue;
+      
+      ptr = buf;
+      /* Skip leading spaces.  */
+      while (*ptr && isspace (*ptr))
+	ptr++;
+
+      /* Skip empty lines.  */
+      if (! *ptr)
+	continue;
+      
+      if (*ptr != '(')
+	{
+	  show_error (line_number, "No open parenthesis found");
+	  return 0;
+	}
+      
+      ptr++;
+      if ((*ptr != 'f' && *ptr != 'h') || *(ptr + 1) != 'd')
+	{
+	  show_error (line_number, "Bad drive name");
+	  return 0;
+	}
+      
+      if (*ptr == 'f')
+	is_floppy = 1;
+      
+      ptr += 2;
+      drive = strtoul (ptr, &ptr, 10);
+      if (drive < 0)
+	{
+	  show_error (line_number, "Bad device number");
+	  return 0;
+	}
+      else if (drive > 127)
+	{
+	  show_warning (line_number,
+			"Ignoring %cd%d due to a BIOS limitation",
+			is_floppy ? 'f' : 'h', drive);
+	  continue;
+	}
+      
+      if (! is_floppy)
+	drive += 0x80;
+      
+      if (*ptr != ')')
+	{
+	  show_error (line_number, "No close parenthesis found");
+	  return 0;
+	}
+      
+      ptr++;
+      /* Skip spaces.  */
+      while (*ptr && isspace (*ptr))
+	ptr++;
+      
+      if (! *ptr)
+	{
+	  show_error (line_number, "No filename found");
+	  return 0;
+	}
+      
+      /* Terminate the filename.  */
+      eptr = ptr;
+      while (*eptr && ! isspace (*eptr))
+	eptr++;
+      *eptr = 0;
+
+      /* Multiple entries for a given drive is not allowed.  */
+      if (map[drive])
+	{
+	  show_error (line_number, "Duplicated entry found");
+	  return 0;
+	}
+      
+      map[drive] = strdup (ptr);
+      assert (map[drive]);
+    }
+  
+  return 1;
+}
+
+/* Initialize the device map MAP. *MAP will be allocated from the heap
+   space. If MAP_FILE is not NULL, then read mappings from the file
+   MAP_FILE if it exists, otherwise, write guessed mappings to the file.
+   FLOPPY_DISKS is the number of floppy disk drives which will be probed.
+   If it is zero, don't probe any floppy at all. If it is one, probe one
+   floppy. If it is two, probe two floppies. And so on.  */
+int
+init_device_map (char ***map, const char *map_file, int floppy_disks)
+{
+  int i;
+  int num_hd = 0;
+  FILE *fp = 0;
+
+  assert (map);
+  assert (*map == 0);
+  *map = malloc (NUM_DISKS * sizeof (char *));
+  assert (*map);
+  
+  /* Probe devices for creating the device map.  */
+  
+  /* Initialize DEVICE_MAP.  */
+  for (i = 0; i < NUM_DISKS; i++)
+    (*map)[i] = 0;
+  
+  if (map_file)
+    {
+      /* Open the device map file.  */
+      fp = fopen (map_file, "r");
+      if (fp)
+	{
+	  int ret;
+
+	  ret = read_device_map (fp, *map, map_file);
+	  fclose (fp);
+	  return ret;
+	}
+    }
+  
+  /* Print something so that the user does not think GRUB has been
+     crashed.  */
+  fprintf (stderr,
+	   "Probing devices to guess BIOS drives. "
+	   "This may take a long time.\n");
+  
+  if (map_file)
+    /* Try to open the device map file to write the probed data.  */
+    fp = fopen (map_file, "w");
+  
+  /* Floppies.  */
+  for (i = 0; i < floppy_disks; i++)
+    {
+      char name[16];
+      
+      get_floppy_disk_name (name, i);
+      /* In floppies, write the map, whether check_device succeeds
+	 or not, because the user just does not insert floppies.  */
+      if (fp)
+	fprintf (fp, "(fd%d)\t%s\n", i, name);
+      
+      if (check_device (name))
+	{
+	  (*map)[i] = strdup (name);
+	  assert ((*map)[i]);
+	}
+    }
+  
+#ifdef __linux__
+  if (have_devfs ())
+    {
+      while (1)
+	{
+	  char discn[32];
+	  char name[PATH_MAX];
+	  struct stat st;
+
+	  /* Linux creates symlinks "/dev/discs/discN" for convenience.
+	     The way to number disks is the same as GRUB's.  */
+	  sprintf (discn, "/dev/discs/disc%d", num_hd);
+	  if (stat (discn, &st) < 0)
+	    break;
+	  
+	  if (realpath (discn, name))
+	    {
+	      strcat (name, "/disc");
+	      (*map)[num_hd + 0x80] = strdup (name);
+	      assert ((*map)[num_hd + 0x80]);
+	      
+	      /* If the device map file is opened, write the map.  */
+	      if (fp)
+		fprintf (fp, "(hd%d)\t%s\n", num_hd, name);
+	    }
+	  
+	  num_hd++;
+	}
+      
+      /* OK, close the device map file if opened.  */
+      if (fp)
+	fclose (fp);
+      
+      return 1;
+    }
+#endif /* __linux__ */
+    
+  /* IDE disks.  */
+  for (i = 0; i < 8; i++)
+    {
+      char name[16];
+      
+      get_ide_disk_name (name, i);
+      if (check_device (name))
+	{
+	  (*map)[num_hd + 0x80] = strdup (name);
+	  assert ((*map)[num_hd + 0x80]);
+	  
+	  /* If the device map file is opened, write the map.  */
+	  if (fp)
+	    fprintf (fp, "(hd%d)\t%s\n", num_hd, name);
+	  
+	  num_hd++;
+	}
+    }
+  
+#ifdef __linux__
+  /* ATARAID disks.  */
+  for (i = 0; i < 8; i++)
+    {
+      char name[20];
+
+      get_ataraid_disk_name (name, i);
+      if (check_device (name))
+        {
+          (*map)[num_hd + 0x80] = strdup (name);
+          assert ((*map)[num_hd + 0x80]);
+
+          /* If the device map file is opened, write the map.  */
+          if (fp)
+            fprintf (fp, "(hd%d)\t%s\n", num_hd, name);
+
+          num_hd++;
+        }
+    }
+#endif /* __linux__ */
+
+  /* The rest is SCSI disks.  */
+  for (i = 0; i < 16; i++)
+    {
+      char name[16];
+      
+      get_scsi_disk_name (name, i);
+      if (check_device (name))
+	{
+	  (*map)[num_hd + 0x80] = strdup (name);
+	  assert ((*map)[num_hd + 0x80]);
+	  
+	  /* If the device map file is opened, write the map.  */
+	  if (fp)
+	    fprintf (fp, "(hd%d)\t%s\n", num_hd, name);
+	  
+	  num_hd++;
+	}
+    }
+  
+#ifdef __linux__
+  /* This is for DAC960 - we have
+     /dev/rd/c<controller>d<logical drive>p<partition>.
+     
+     DAC960 driver currently supports up to 8 controllers, 32 logical
+     drives, and 7 partitions.  */
+  {
+    int controller, drive;
+    
+    for (controller = 0; controller < 8; controller++)
+      {
+	for (drive = 0; drive < 15; drive++)
+	  {
+	    char name[24];
+	    
+	    get_dac960_disk_name (name, controller, drive);
+	    if (check_device (name))
+	      {
+		(*map)[num_hd + 0x80] = strdup (name);
+		assert ((*map)[num_hd + 0x80]);
+		
+		/* If the device map file is opened, write the map.  */
+		if (fp)
+		  fprintf (fp, "(hd%d)\t%s\n", num_hd, name);
+		
+		num_hd++;
+	      }
+	  }
+      }
+  }
+#endif /* __linux__ */
+  
+  /* OK, close the device map file if opened.  */
+  if (fp)
+    fclose (fp);
+
+  return 1;
+}
+
+/* Restore the memory consumed for MAP.  */
+void
+restore_device_map (char **map)
+{
+  int i;
+
+  for (i = 0; i < NUM_DISKS; i++)
+    if (map[i])
+      free (map[i]);
+
+  free (map);
+}
+
+#ifdef __linux__
+/* Linux-only functions, because Linux has a bug that the disk cache for
+   a whole disk is not consistent with the one for a partition of the
+   disk.  */
+int
+is_disk_device (char **map, int drive)
+{
+  struct stat st;
+  int retval;
+  
+  assert (map[drive] != 0);
+  retval = stat (map[drive], &st);
+  assert (retval == 0);
+  /* For now, disk devices under Linux are all block devices.  */
+  return S_ISBLK (st.st_mode);
+}
+
+int
+write_to_partition (char **map, int drive, int partition,
+		    int sector, int size, const char *buf)
+{
+  char dev[PATH_MAX];	/* XXX */
+  int fd;
+  
+  if ((partition & 0x00FF00) != 0x00FF00)
+    {
+      /* If the partition is a BSD partition, it is difficult to
+	 obtain the representation in Linux. So don't support that.  */
+      errnum = ERR_DEV_VALUES;
+      return 1;
+    }
+  
+  assert (map[drive] != 0);
+  
+  strcpy (dev, map[drive]);
+  if (have_devfs ())
+    {
+      if (strcmp (dev + strlen(dev) - 5, "/disc") == 0)
+	strcpy (dev + strlen(dev) - 5, "/part");
+    }
+  sprintf (dev + strlen(dev), "%d", ((partition >> 16) & 0xFF) + 1);
+  
+  /* Open the partition.  */
+  fd = open (dev, O_RDWR);
+  if (fd < 0)
+    {
+      errnum = ERR_NO_PART;
+      return 0;
+    }
+  
+#if defined(__linux__) && (!defined(__GLIBC__) || \
+        ((__GLIBC__ < 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ < 1))))
+  /* Maybe libc doesn't have large file support.  */
+  {
+    loff_t offset, result;
+    static int _llseek (uint filedes, ulong hi, ulong lo,
+                        loff_t *res, uint wh);
+    _syscall5 (int, _llseek, uint, filedes, ulong, hi, ulong, lo,
+               loff_t *, res, uint, wh);
+
+    offset = (loff_t) sector * (loff_t) SECTOR_SIZE;
+    if (_llseek (fd, offset >> 32, offset & 0xffffffff, &result, SEEK_SET))
+      {
+	errnum = ERR_DEV_VALUES;
+	return 0;
+      }
+  }
+#else
+  {
+    off_t offset = (off_t) sector * (off_t) SECTOR_SIZE;
+
+    if (lseek (fd, offset, SEEK_SET) != offset)
+      {
+	errnum = ERR_DEV_VALUES;
+	return 0;
+      }
+  }
+#endif
+  
+  if (write (fd, buf, size * SECTOR_SIZE) != (size * SECTOR_SIZE))
+    {
+      close (fd);
+      errnum = ERR_WRITE;
+      return 0;
+    }
+  
+  sync ();	/* Paranoia.  */
+  close (fd);
+  
+  return 1;
+}
+#endif /* __linux__ */
diff -Naur grub-0.97/netboot/main.c grub-0.97-suse/netboot/main.c
--- grub-0.97/netboot/main.c	2004-05-20 19:19:33.000000000 -0300
+++ grub-0.97-suse/netboot/main.c	2006-09-09 17:00:12.000000000 -0300
@@ -54,9 +54,9 @@
 
 static int vendorext_isvalid;
 static unsigned long netmask;
-static struct bootpd_t bootp_data;
+struct bootpd_t bootp_data;
 static unsigned long xid;
-static unsigned char *end_of_rfc1533 = NULL;
+unsigned char *end_of_rfc1533 = NULL;
 
 #ifndef	NO_DHCP_SUPPORT
 #endif /* NO_DHCP_SUPPORT */
diff -Naur grub-0.97/stage1/Makefile.am grub-0.97-suse/stage1/Makefile.am
--- grub-0.97/stage1/Makefile.am	2004-07-16 08:44:56.000000000 -0300
+++ grub-0.97-suse/stage1/Makefile.am	2006-09-09 17:00:12.000000000 -0300
@@ -1,4 +1,4 @@
-pkglibdir = $(libdir)/$(PACKAGE)/$(host_cpu)-$(host_vendor)
+pkglibdir = /usr/lib/grub
 nodist_pkglib_DATA = stage1
 
 CLEANFILES = $(nodist_pkglib_DATA)
diff -Naur grub-0.97/stage1/stage1.S grub-0.97-suse/stage1/stage1.S
--- grub-0.97/stage1/stage1.S	2005-02-15 19:54:31.000000000 -0200
+++ grub-0.97-suse/stage1/stage1.S	2006-09-09 17:00:12.000000000 -0300
@@ -177,7 +177,11 @@
 	/* check if AH=0x42 is supported if FORCE_LBA is zero */
 	MOV_MEM_TO_AL(ABS(force_lba))	/* movb	ABS(force_lba), %al */
 	testb	%al, %al
+	/* check if LBA is forced OFF 0x80 <= %al <= 0xff */
+	js	chs_mode
+	/* or forced ON 0x01 <= %al <= 0x7f */
 	jnz	lba_mode
+	/* otherwise trust BIOS int's result */
 	andw	$1, %cx
 	jz	chs_mode
 	
diff -Naur grub-0.97/stage1/stage1.S~ grub-0.97-suse/stage1/stage1.S~
--- grub-0.97/stage1/stage1.S~	1969-12-31 21:00:00.000000000 -0300
+++ grub-0.97-suse/stage1/stage1.S~	2005-02-15 19:54:31.000000000 -0200
@@ -0,0 +1,499 @@
+/* -*-Asm-*- */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 1999,2000,2001,2002,2004   Free Software Foundation, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <stage1.h>
+	
+/*
+ *  defines for the code go here
+ */
+
+	/* Absolute addresses
+	   This makes the assembler generate the address without support
+	   from the linker. (ELF can't relocate 16-bit addresses!) */
+#define ABS(x) (x-_start+0x7c00)
+
+	/* Print message string */
+#define MSG(x)	movw $ABS(x), %si; call message
+
+	/* XXX:	binutils-2.9.1.0.x doesn't produce a short opcode for this. */
+#define	MOV_MEM_TO_AL(x)	.byte 0xa0;  .word x
+	
+	.file	"stage1.S"
+
+	.text
+
+	/* Tell GAS to generate 16-bit instructions so that this code works
+	   in real mode. */
+	.code16
+
+.globl _start; _start:
+	/*
+	 * _start is loaded at 0x7c00 and is jumped to with CS:IP 0:0x7c00
+	 */
+
+	/*
+	 * Beginning of the sector is compatible with the FAT/HPFS BIOS
+	 * parameter block.
+	 */
+
+	jmp	after_BPB
+	nop	/* do I care about this ??? */
+
+	/*
+	 * This space is for the BIOS parameter block!!!!  Don't change
+	 * the first jump, nor start the code anywhere but right after
+	 * this area.
+	 */
+
+	. = _start + 4
+
+	/* scratch space */
+mode:
+	.byte	0
+disk_address_packet:	
+sectors:
+	.long	0
+heads:
+	.long	0
+cylinders:
+	.word	0
+sector_start:
+	.byte	0
+head_start:
+	.byte	0
+cylinder_start:
+	.word	0
+	/* more space... */
+
+	. = _start + STAGE1_BPBEND
+
+	/*
+	 * End of BIOS parameter block.
+	 */
+
+stage1_version:	
+	.byte	COMPAT_VERSION_MAJOR, COMPAT_VERSION_MINOR
+boot_drive:	
+	.byte	GRUB_INVALID_DRIVE	/* the disk to load stage2 from */
+force_lba:
+	.byte	0
+stage2_address:
+	.word	0x8000
+stage2_sector:
+	.long	1
+stage2_segment:
+	.word	0x800
+
+after_BPB:
+
+/* general setup */
+	cli		/* we're not safe here! */
+
+	/*
+	 * This is a workaround for buggy BIOSes which don't pass boot
+	 * drive correctly. If GRUB is installed into a HDD, check if
+	 * DL is masked correctly. If not, assume that the BIOS passed
+	 * a bogus value and set DL to 0x80, since this is the only
+	 * possible boot drive. If GRUB is installed into a floppy,
+	 * this does nothing (only jump).
+	 */
+boot_drive_check:	
+	jmp	1f
+	testb	$0x80, %dl
+	jnz	1f
+	movb	$0x80, %dl
+1:	
+
+	/*
+	 * ljmp to the next instruction because some bogus BIOSes
+	 * jump to 07C0:0000 instead of 0000:7C00.
+	 */
+	ljmp	$0, $ABS(real_start)
+
+real_start:	
+
+	/* set up %ds and %ss as offset from 0 */
+	xorw	%ax, %ax
+	movw	%ax, %ds
+	movw	%ax, %ss
+
+	/* set up the REAL stack */
+	movw	$STAGE1_STACKSEG, %sp
+
+	sti		/* we're safe again */
+
+	/*
+	 *  Check if we have a forced disk reference here
+	 */
+	MOV_MEM_TO_AL(ABS(boot_drive))	/* movb	ABS(boot_drive), %al */
+	cmpb	$GRUB_INVALID_DRIVE, %al
+	je	1f
+	movb	%al, %dl
+1:
+	/* save drive reference first thing! */
+	pushw	%dx
+
+	/* print a notification message on the screen */
+	MSG(notification_string)
+
+	/* do not probe LBA if the drive is a floppy */
+	testb	$STAGE1_BIOS_HD_FLAG, %dl
+	jz	chs_mode
+			
+	/* check if LBA is supported */
+	movb	$0x41, %ah
+	movw	$0x55aa, %bx
+	int	$0x13
+
+	/* 
+	 *  %dl may have been clobbered by INT 13, AH=41H.
+	 *  This happens, for example, with AST BIOS 1.04.
+	 */
+	popw	%dx
+	pushw	%dx
+
+	/* use CHS if fails */
+	jc	chs_mode
+	cmpw	$0xaa55, %bx
+	jne	chs_mode
+
+	/* check if AH=0x42 is supported if FORCE_LBA is zero */
+	MOV_MEM_TO_AL(ABS(force_lba))	/* movb	ABS(force_lba), %al */
+	testb	%al, %al
+	jnz	lba_mode
+	andw	$1, %cx
+	jz	chs_mode
+	
+lba_mode:
+	/* save the total number of sectors */
+	movl	0x10(%si), %ecx
+
+	/* set %si to the disk address packet */
+	movw	$ABS(disk_address_packet), %si
+
+	/* set the mode to non-zero */
+	movb	$1, -1(%si)
+	
+	movl	ABS(stage2_sector), %ebx
+
+	/* the size and the reserved byte */
+	movw	$0x0010, (%si)
+
+	/* the blocks */
+	movw	$1, 2(%si)
+	
+	/* the absolute address (low 32 bits) */
+	movl	%ebx, 8(%si)
+
+	/* the segment of buffer address */
+	movw	$STAGE1_BUFFERSEG, 6(%si)
+
+	xorl	%eax, %eax
+	movw	%ax, 4(%si)
+	movl	%eax, 12(%si)
+	
+/*
+ * BIOS call "INT 0x13 Function 0x42" to read sectors from disk into memory
+ *	Call with	%ah = 0x42
+ *			%dl = drive number
+ *			%ds:%si = segment:offset of disk address packet
+ *	Return:
+ *			%al = 0x0 on success; err code on failure
+ */
+
+	movb	$0x42, %ah
+	int	$0x13
+
+	/* LBA read is not supported, so fallback to CHS.  */
+	jc	chs_mode
+
+	movw	$STAGE1_BUFFERSEG, %bx
+	jmp	copy_buffer
+		
+chs_mode:	
+	/*
+	 *  Determine the hard disk geometry from the BIOS!
+	 *  We do this first, so that LS-120 IDE floppies work correctly.
+	 */
+	movb	$8, %ah
+	int	$0x13
+	jnc	final_init
+
+	/*
+	 *  The call failed, so maybe use the floppy probe instead.
+	 */
+	testb	$STAGE1_BIOS_HD_FLAG, %dl
+	jz	floppy_probe
+
+	/* Nope, we definitely have a hard disk, and we're screwed. */
+	jmp	hd_probe_error
+
+final_init:
+	
+	movw	$ABS(sectors), %si
+
+	/* set the mode to zero */
+	movb	$0, -1(%si)
+	
+	/* save number of heads */
+	xorl	%eax, %eax
+	movb	%dh, %al
+	incw	%ax
+	movl	%eax, 4(%si)
+
+	xorw	%dx, %dx
+	movb	%cl, %dl
+	shlw	$2, %dx
+	movb	%ch, %al
+	movb	%dh, %ah
+
+	/* save number of cylinders */
+	incw	%ax
+	movw	%ax, 8(%si)
+
+	xorw	%ax, %ax
+	movb	%dl, %al
+	shrb	$2, %al
+
+	/* save number of sectors */
+	movl	%eax, (%si)
+
+setup_sectors:
+	/* load logical sector start (bottom half) */
+	movl	ABS(stage2_sector), %eax
+
+	/* zero %edx */
+	xorl	%edx, %edx
+
+	/* divide by number of sectors */
+	divl	(%si)
+
+	/* save sector start */
+	movb	%dl, 10(%si)
+
+	xorl	%edx, %edx	/* zero %edx */
+	divl	4(%si)		/* divide by number of heads */
+
+	/* save head start */
+	movb	%dl, 11(%si)
+
+	/* save cylinder start */
+	movw	%ax, 12(%si)
+
+	/* do we need too many cylinders? */
+	cmpw	8(%si), %ax
+	jge	geometry_error
+
+/*
+ *  This is the loop for taking care of BIOS geometry translation (ugh!)
+ */
+
+	/* get high bits of cylinder */
+	movb	13(%si), %dl
+
+	shlb	$6, %dl		/* shift left by 6 bits */
+	movb	10(%si), %cl	/* get sector */
+
+	incb	%cl		/* normalize sector (sectors go
+					from 1-N, not 0-(N-1) ) */
+	orb	%dl, %cl	/* composite together */
+	movb	12(%si), %ch	/* sector+hcyl in cl, cylinder in ch */
+
+	/* restore %dx */
+	popw	%dx
+	
+	/* head number */
+	movb	11(%si), %dh
+
+/*
+ * BIOS call "INT 0x13 Function 0x2" to read sectors from disk into memory
+ *	Call with	%ah = 0x2
+ *			%al = number of sectors
+ *			%ch = cylinder
+ *			%cl = sector (bits 6-7 are high bits of "cylinder")
+ *			%dh = head
+ *			%dl = drive (0x80 for hard disk, 0x0 for floppy disk)
+ *			%es:%bx = segment:offset of buffer
+ *	Return:
+ *			%al = 0x0 on success; err code on failure
+ */
+
+	movw	$STAGE1_BUFFERSEG, %bx
+	movw	%bx, %es	/* load %es segment with disk buffer */
+
+	xorw	%bx, %bx	/* %bx = 0, put it at 0 in the segment */
+	movw	$0x0201, %ax	/* function 2 */
+	int	$0x13
+
+	jc	read_error
+
+	movw	%es, %bx
+	
+copy_buffer:
+	movw	ABS(stage2_segment), %es
+
+	/*
+	 * We need to save %cx and %si because the startup code in
+	 * stage2 uses them without initializing them.
+	 */
+	pusha
+	pushw	%ds
+	
+	movw	$0x100, %cx
+	movw	%bx, %ds
+	xorw	%si, %si
+	xorw	%di, %di
+	
+	cld
+	
+	rep
+	movsw
+
+	popw	%ds
+	popa
+
+	/* boot stage2 */
+	jmp	*(stage2_address)
+
+/* END OF MAIN LOOP */
+
+/*
+ * BIOS Geometry translation error (past the end of the disk geometry!).
+ */
+geometry_error:
+	MSG(geometry_error_string)
+	jmp	general_error
+
+/*
+ * Disk probe failure.
+ */
+hd_probe_error:
+	MSG(hd_probe_error_string)
+	jmp	general_error
+
+/*
+ * Read error on the disk.
+ */
+read_error:
+	MSG(read_error_string)
+
+general_error:
+	MSG(general_error_string)
+
+/* go here when you need to stop the machine hard after an error condition */
+stop:	jmp	stop
+
+notification_string:	.string "GRUB "
+geometry_error_string:	.string "Geom"
+hd_probe_error_string:	.string "Hard Disk"
+read_error_string:	.string "Read"
+general_error_string:	.string " Error"
+
+/*
+ * message: write the string pointed to by %si
+ *
+ *   WARNING: trashes %si, %ax, and %bx
+ */
+
+	/*
+	 * Use BIOS "int 10H Function 0Eh" to write character in teletype mode
+	 *	%ah = 0xe	%al = character
+	 *	%bh = page	%bl = foreground color (graphics modes)
+	 */
+1:
+	movw	$0x0001, %bx
+	movb	$0xe, %ah
+	int	$0x10		/* display a byte */
+message:
+	lodsb
+	cmpb	$0, %al
+	jne	1b	/* if not end of string, jmp to display */
+	ret
+
+	/*
+	 *  Windows NT breaks compatibility by embedding a magic
+	 *  number here.
+	 */
+
+	. = _start + STAGE1_WINDOWS_NT_MAGIC
+nt_magic:	
+	.long 0
+	.word 0
+
+	/*
+	 *  This is where an MBR would go if on a hard disk.  The code
+	 *  here isn't even referenced unless we're on a floppy.  Kinda
+	 *  sneaky, huh?
+	 */
+
+part_start:	
+	. = _start + STAGE1_PARTSTART
+
+probe_values:
+	.byte	36, 18, 15, 9, 0
+
+floppy_probe:
+/*
+ *  Perform floppy probe.
+ */
+
+	movw	$ABS(probe_values-1), %si
+
+probe_loop:
+	/* reset floppy controller INT 13h AH=0 */
+	xorw	%ax, %ax
+	int	$0x13
+
+	incw	%si
+	movb	(%si), %cl
+
+	/* if number of sectors is 0, display error and die */
+	cmpb	$0, %cl
+	jne	1f
+
+/*
+ * Floppy disk probe failure.
+ */
+	MSG(fd_probe_error_string)
+	jmp	general_error
+
+fd_probe_error_string:	.string "Floppy"
+
+1:
+	/* perform read */
+	movw	$STAGE1_BUFFERSEG, %bx
+	movw	$0x201, %ax
+	movb	$0, %ch
+	movb	$0, %dh
+	int	$0x13
+
+	/* if error, jump to "probe_loop" */
+	jc	probe_loop
+
+	/* %cl is already the correct value! */
+	movb	$1, %dh
+	movb	$79, %ch
+
+	jmp	final_init
+
+	. = _start + STAGE1_PARTEND
+
+/* the last 2 bytes in the sector 0 contain the signature */
+	.word	STAGE1_SIGNATURE
diff -Naur grub-0.97/stage2/Makefile.am grub-0.97-suse/stage2/Makefile.am
--- grub-0.97/stage2/Makefile.am	2005-02-02 18:37:35.000000000 -0200
+++ grub-0.97-suse/stage2/Makefile.am	2006-09-09 17:00:12.000000000 -0300
@@ -27,7 +27,7 @@
 	-DUSE_MD5_PASSWORDS=1 -DSUPPORT_SERIAL=1 -DSUPPORT_HERCULES=1
 
 # Stage 2 and Stage 1.5's.
-pkglibdir = $(libdir)/$(PACKAGE)/$(host_cpu)-$(host_vendor)
+pkglibdir = /usr/lib/grub
 
 EXTRA_PROGRAMS = nbloader.exec pxeloader.exec diskless.exec
 
diff -Naur grub-0.97/stage2/Makefile.am~ grub-0.97-suse/stage2/Makefile.am~
--- grub-0.97/stage2/Makefile.am~	1969-12-31 21:00:00.000000000 -0300
+++ grub-0.97-suse/stage2/Makefile.am~	2005-02-02 18:37:35.000000000 -0200
@@ -0,0 +1,272 @@
+# For test target.
+TESTS = size_test
+noinst_SCRIPTS = $(TESTS)
+
+# For dist target.
+noinst_HEADERS = apic.h defs.h dir.h disk_inode.h disk_inode_ffs.h \
+        fat.h filesys.h freebsd.h fs.h hercules.h i386-elf.h \
+	imgact_aout.h iso9660.h jfs.h mb_header.h mb_info.h md5.h \
+	nbi.h pc_slice.h serial.h shared.h smp-imps.h term.h \
+	terminfo.h tparm.h nbi.h ufs2.h vstafs.h xfs.h
+EXTRA_DIST = setjmp.S apm.S $(noinst_SCRIPTS)
+
+# For <stage1.h>.
+INCLUDES = -I$(top_srcdir)/stage1
+
+# The library for /sbin/grub.
+noinst_LIBRARIES = libgrub.a
+libgrub_a_SOURCES = boot.c builtins.c char_io.c cmdline.c common.c \
+	disk_io.c fsys_ext2fs.c fsys_fat.c fsys_ffs.c fsys_iso9660.c \
+	fsys_jfs.c fsys_minix.c fsys_reiserfs.c fsys_ufs2.c \
+	fsys_vstafs.c fsys_xfs.c gunzip.c md5.c serial.c stage2.c \
+	terminfo.c tparm.c
+libgrub_a_CFLAGS = $(GRUB_CFLAGS) -I$(top_srcdir)/lib \
+	-DGRUB_UTIL=1 -DFSYS_EXT2FS=1 -DFSYS_FAT=1 -DFSYS_FFS=1 \
+	-DFSYS_ISO9660=1 -DFSYS_JFS=1 -DFSYS_MINIX=1 -DFSYS_REISERFS=1 \
+	-DFSYS_UFS2=1 -DFSYS_VSTAFS=1 -DFSYS_XFS=1 \
+	-DUSE_MD5_PASSWORDS=1 -DSUPPORT_SERIAL=1 -DSUPPORT_HERCULES=1
+
+# Stage 2 and Stage 1.5's.
+pkglibdir = $(libdir)/$(PACKAGE)/$(host_cpu)-$(host_vendor)
+
+EXTRA_PROGRAMS = nbloader.exec pxeloader.exec diskless.exec
+
+if DISKLESS_SUPPORT
+pkglib_DATA = stage2 stage2_eltorito e2fs_stage1_5 fat_stage1_5 \
+	ffs_stage1_5 iso9660_stage1_5 jfs_stage1_5 minix_stage1_5 \
+	reiserfs_stage1_5 ufs2_stage1_5 vstafs_stage1_5 xfs_stage1_5 \
+	nbgrub pxegrub
+noinst_DATA = pre_stage2 start start_eltorito nbloader pxeloader diskless
+noinst_PROGRAMS = pre_stage2.exec start.exec start_eltorito.exec \
+	e2fs_stage1_5.exec fat_stage1_5.exec ffs_stage1_5.exec \
+	iso9660_stage1_5.exec jfs_stage1_5.exec minix_stage1_5.exec \
+	reiserfs_stage1_5.exec ufs2_stage1_5.exec vstafs_stage1_5.exec \
+	xfs_stage1_5.exec nbloader.exec pxeloader.exec diskless.exec
+else
+pkglib_DATA = stage2 stage2_eltorito e2fs_stage1_5 fat_stage1_5 \
+	ffs_stage1_5 iso9660_stage1_5 jfs_stage1_5 minix_stage1_5 \
+	reiserfs_stage1_5 ufs2_stage1_5 vstafs_stage1_5 xfs_stage1_5
+noinst_DATA = pre_stage2 start start_eltorito
+noinst_PROGRAMS = pre_stage2.exec start.exec start_eltorito.exec \
+	e2fs_stage1_5.exec fat_stage1_5.exec ffs_stage1_5.exec \
+	iso9660_stage1_5.exec jfs_stage1_5.exec minix_stage1_5.exec \
+	reiserfs_stage1_5.exec ufs2_stage1_5.exec vstafs_stage1_5.exec \
+	xfs_stage1_5.exec
+endif
+MOSTLYCLEANFILES = $(noinst_PROGRAMS)
+
+PRE_STAGE2_LINK = -nostdlib -Wl,-N -Wl,-Ttext -Wl,8200
+START_LINK = -nostdlib -Wl,-N -Wl,-Ttext -Wl,8000
+NBLOADER_LINK = -nostdlib -Wl,-N -Wl,-Ttext -Wl,0
+PXELOADER_LINK = -nostdlib -Wl,-N -Wl,-Ttext -Wl,7C00
+START_ELTORITO_LINK = -nostdlib -Wl,-N -Wl,-Ttext -Wl,7C00
+
+if NETBOOT_SUPPORT
+NETBOOT_FLAGS = -I$(top_srcdir)/netboot -DSUPPORT_NETBOOT=1
+else
+NETBOOT_FLAGS =
+endif
+
+if SERIAL_SUPPORT
+SERIAL_FLAGS = -DSUPPORT_SERIAL=1
+else
+SERIAL_FLAGS =
+endif
+
+if HERCULES_SUPPORT
+HERCULES_FLAGS = -DSUPPORT_HERCULES=1
+else
+HERCULES_FLAGS =
+endif
+
+STAGE2_COMPILE = $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+	$(NETBOOT_FLAGS) $(SERIAL_FLAGS) $(HERCULES_FLAGS)
+
+STAGE1_5_LINK = -nostdlib -Wl,-N -Wl,-Ttext -Wl,2000
+STAGE1_5_COMPILE = $(STAGE2_COMPILE) -DNO_DECOMPRESSION=1 -DSTAGE1_5=1
+
+# For stage2 target.
+pre_stage2_exec_SOURCES = asm.S bios.c boot.c builtins.c char_io.c \
+	cmdline.c common.c console.c disk_io.c fsys_ext2fs.c \
+	fsys_fat.c fsys_ffs.c fsys_iso9660.c fsys_jfs.c fsys_minix.c \
+	fsys_reiserfs.c fsys_ufs2.c fsys_vstafs.c fsys_xfs.c gunzip.c \
+	hercules.c md5.c serial.c smp-imps.c stage2.c terminfo.c tparm.c
+pre_stage2_exec_CFLAGS = $(STAGE2_COMPILE) $(FSYS_CFLAGS)
+pre_stage2_exec_CCASFLAGS = $(STAGE2_COMPILE) $(FSYS_CFLAGS)
+pre_stage2_exec_LDFLAGS = $(PRE_STAGE2_LINK)
+
+if NETBOOT_SUPPORT
+pre_stage2_exec_LDADD = ../netboot/libdrivers.a
+endif
+
+if DISKLESS_SUPPORT
+BUILT_SOURCES = stage2_size.h diskless_size.h
+else
+BUILT_SOURCES = stage2_size.h
+endif
+
+CLEANFILES = $(pkglib_DATA) $(noinst_DATA) $(BUILT_SOURCES)
+
+stage2_size.h: pre_stage2
+	-rm -f stage2_size.h
+	set dummy `ls -l pre_stage2`; \
+	echo "#define STAGE2_SIZE $$6" > stage2_size.h
+
+start_exec_SOURCES = start.S
+start_exec_CCASFLAGS = $(STAGE2_COMPILE)
+start_exec_LDFLAGS = $(START_LINK)
+
+# XXX: automake doesn't provide a way to specify dependencies for object
+# files explicitly, so we must write this by a general Makefile scheme.
+# If automake change the naming scheme for per-executable objects, this
+# will be broken.
+start_exec-start.$(OBJEXT): stage2_size.h
+
+stage2: pre_stage2 start
+	-rm -f stage2
+	cat start pre_stage2 > stage2
+
+start_eltorito_exec_SOURCES = start_eltorito.S
+start_eltorito_exec_CCASFLAGS = $(STAGE2_COMPILE)
+start_eltorito_exec_LDFLAGS = $(START_ELTORITO_LINK)
+
+start_eltorito_exec-start.$(OBJEXT): stage2_size.h
+
+stage2_eltorito: pre_stage2 start_eltorito
+	-rm -f stage2_eltorito
+	cat start_eltorito pre_stage2 > stage2_eltorito
+
+# For e2fs_stage1_5 target.
+e2fs_stage1_5_exec_SOURCES = start.S asm.S common.c char_io.c disk_io.c \
+	stage1_5.c fsys_ext2fs.c bios.c
+e2fs_stage1_5_exec_CFLAGS = $(STAGE1_5_COMPILE) -DFSYS_EXT2FS=1 \
+	-DNO_BLOCK_FILES=1
+e2fs_stage1_5_exec_CCASFLAGS = $(STAGE1_5_COMPILE) -DFSYS_EXT2FS=1 \
+	-DNO_BLOCK_FILES=1
+e2fs_stage1_5_exec_LDFLAGS = $(STAGE1_5_LINK)
+
+# For fat_stage1_5 target.
+fat_stage1_5_exec_SOURCES = start.S asm.S common.c char_io.c disk_io.c \
+	stage1_5.c fsys_fat.c bios.c
+fat_stage1_5_exec_CFLAGS = $(STAGE1_5_COMPILE) -DFSYS_FAT=1 \
+	-DNO_BLOCK_FILES=1
+fat_stage1_5_exec_CCASFLAGS = $(STAGE1_5_COMPILE) -DFSYS_FAT=1 \
+	-DNO_BLOCK_FILES=1
+fat_stage1_5_exec_LDFLAGS = $(STAGE1_5_LINK)
+
+# For ffs_stage1_5 target.
+ffs_stage1_5_exec_SOURCES = start.S asm.S common.c char_io.c disk_io.c \
+	stage1_5.c fsys_ffs.c bios.c
+ffs_stage1_5_exec_CFLAGS = $(STAGE1_5_COMPILE) -DFSYS_FFS=1 \
+	-DNO_BLOCK_FILES=1
+ffs_stage1_5_exec_CCASFLAGS = $(STAGE1_5_COMPILE) -DFSYS_FFS=1 \
+	-DNO_BLOCK_FILES=1
+ffs_stage1_5_exec_LDFLAGS = $(STAGE1_5_LINK)
+
+# For ufs2_stage1_5 target.
+ufs2_stage1_5_exec_SOURCES = start.S asm.S common.c char_io.c disk_io.c \
+	stage1_5.c fsys_ufs2.c bios.c
+ufs2_stage1_5_exec_CFLAGS = $(STAGE1_5_COMPILE) -DFSYS_UFS2=1 \
+	-DNO_BLOCK_FILES=1
+ufs2_stage1_5_exec_CCASFLAGS = $(STAGE1_5_COMPILE) -DFSYS_UFS2=1 \
+	-DNO_BLOCK_FILES=1
+ufs2_stage1_5_exec_LDFLAGS = $(STAGE1_5_LINK)
+
+# For minix_stage1_5 target.
+minix_stage1_5_exec_SOURCES = start.S asm.S common.c char_io.c disk_io.c \
+	stage1_5.c fsys_minix.c bios.c
+minix_stage1_5_exec_CFLAGS = $(STAGE1_5_COMPILE) -DFSYS_MINIX=1 \
+	-DNO_BLOCK_FILES=1
+minix_stage1_5_exec_CCASFLAGS = $(STAGE1_5_COMPILE) -DFSYS_MINIX=1 \
+	-DNO_BLOCK_FILES=1
+minix_stage1_5_exec_LDFLAGS = $(STAGE1_5_LINK)
+
+# For reiserfs_stage1_5 target.
+reiserfs_stage1_5_exec_SOURCES = start.S asm.S common.c char_io.c \
+	disk_io.c stage1_5.c fsys_reiserfs.c bios.c
+reiserfs_stage1_5_exec_CFLAGS = $(STAGE1_5_COMPILE) -DFSYS_REISERFS=1 \
+	-DNO_BLOCK_FILES=1
+reiserfs_stage1_5_exec_CCASFLAGS = $(STAGE1_5_COMPILE) -DFSYS_REISERFS=1 \
+	-DNO_BLOCK_FILES=1
+reiserfs_stage1_5_exec_LDFLAGS = $(STAGE1_5_LINK)
+
+# For vstafs_stage1_5 target.
+vstafs_stage1_5_exec_SOURCES = start.S asm.S common.c char_io.c \
+	disk_io.c stage1_5.c fsys_vstafs.c bios.c
+vstafs_stage1_5_exec_CFLAGS = $(STAGE1_5_COMPILE) -DFSYS_VSTAFS=1 \
+	-DNO_BLOCK_FILES=1
+vstafs_stage1_5_exec_CCASFLAGS = $(STAGE1_5_COMPILE) -DFSYS_VSTAFS=1 \
+	-DNO_BLOCK_FILES=1
+vstafs_stage1_5_exec_LDFLAGS = $(STAGE1_5_LINK)
+
+# For jfs_stage1_5 target.
+jfs_stage1_5_exec_SOURCES = start.S asm.S common.c char_io.c \
+	disk_io.c stage1_5.c fsys_jfs.c bios.c
+jfs_stage1_5_exec_CFLAGS = $(STAGE1_5_COMPILE) -DFSYS_JFS=1 \
+	-DNO_BLOCK_FILES=1
+jfs_stage1_5_exec_CCASFLAGS = $(STAGE1_5_COMPILE) -DFSYS_JFS=1 \
+	-DNO_BLOCK_FILES=1
+jfs_stage1_5_exec_LDFLAGS = $(STAGE1_5_LINK)
+
+# For xfs_stage1_5 target.
+xfs_stage1_5_exec_SOURCES = start.S asm.S common.c char_io.c \
+	disk_io.c stage1_5.c fsys_xfs.c bios.c
+xfs_stage1_5_exec_CFLAGS = $(STAGE1_5_COMPILE) -DFSYS_XFS=1 \
+	-DNO_BLOCK_FILES=1
+xfs_stage1_5_exec_CCASFLAGS = $(STAGE1_5_COMPILE) -DFSYS_XFS=1 \
+	-DNO_BLOCK_FILES=1
+xfs_stage1_5_exec_LDFLAGS = $(STAGE1_5_LINK)
+
+# For iso9660_stage1_5 target.
+iso9660_stage1_5_exec_SOURCES = start_eltorito.S asm.S common.c char_io.c \
+	disk_io.c stage1_5.c fsys_iso9660.c bios.c
+iso9660_stage1_5_exec_CFLAGS = $(STAGE1_5_COMPILE) -DFSYS_ISO9660=1 \
+	-DNO_BLOCK_FILES=1
+iso9660_stage1_5_exec_CCASFLAGS = $(STAGE1_5_COMPILE) -DFSYS_ISO9660=1 \
+	-DNO_BLOCK_FILES=1
+iso9660_stage1_5_exec_LDFLAGS = $(STAGE1_5_LINK)
+
+# For diskless target.
+diskless_exec_SOURCES = $(pre_stage2_exec_SOURCES)
+diskless_exec_CFLAGS = $(STAGE2_COMPILE) $(FSYS_CFLAGS) \
+	-DSUPPORT_DISKLESS=1
+diskless_exec_CCASFLAGS = $(STAGE2_COMPILE) $(FSYS_CFLAGS) \
+	-DSUPPORT_DISKLESS=1
+diskless_exec_LDFLAGS = $(PRE_STAGE2_LINK)
+diskless_exec_LDADD = ../netboot/libdrivers.a
+
+diskless_size.h: diskless
+	-rm -f $@
+	set dummy `ls -l $^`; \
+	echo "#define DISKLESS_SIZE $$6" > $@
+
+# For nbloader target.
+nbloader_exec_SOURCES = nbloader.S
+nbloader_exec_CCASFLAGS = $(STAGE2_COMPILE)
+nbloader_exec_LDFLAGS = $(NBLOADER_LINK)
+
+# XXX: See the comment for start_exec-start.o.
+nbloader_exec-nbloader.$(OBJEXT): diskless_size.h
+
+# For nbgrub target.
+nbgrub: nbloader diskless
+	-rm -f $@
+	cat $^ > $@
+
+# For pxeloader target.
+pxeloader_exec_SOURCES = pxeloader.S
+pxeloader_exec_CCASFLAGS = $(STAGE2_COMPILE)
+pxeloader_exec_LDFLAGS = $(PXELOADER_LINK)
+
+# XXX: See the comment for start_exec-start.o.
+pxeloader_exec-pxeloader.$(OBJEXT): diskless_size.h
+
+# For pxegrub target.
+pxegrub: pxeloader diskless
+	-rm -f $@
+	cat $^ > $@
+
+# General rule for making a raw binary.
+SUFFIXES = .exec
+.exec:
+	$(OBJCOPY) -O binary $< $@
diff -Naur grub-0.97/stage2/asm.S grub-0.97-suse/stage2/asm.S
--- grub-0.97/stage2/asm.S	2004-06-19 13:55:22.000000000 -0300
+++ grub-0.97-suse/stage2/asm.S	2006-09-09 17:00:12.000000000 -0300
@@ -1091,7 +1091,11 @@
 	/* check if AH=0x42 is supported if FORCE_LBA is zero */
 	movb	EXT_C(force_lba), %al
 	testb	%al, %al
+	/* check if LBA is forced OFF 0x80 <= %al <= 0xff */
+	js	1f
+	/* or forced ON 0x01 <= %al <= 0x7f */
 	jnz	2f
+	/* otherwise trust BIOS int's result */
 	andw	$1, %cx
 	jnz	2f
 	
@@ -1610,6 +1614,301 @@
 	popl	%ebp
 	ret
 
+
+/*
+ * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+ *
+ * graphical menu functions
+ *
+ */
+
+/*
+ * int gfx_init (gfx_data_t *gfx_data)
+ *
+ * init gfx things
+ *
+ * return vales:
+ *   0: ok
+ *   1: failed
+ *   sets gfx_data->ok
+ */
+
+ENTRY(gfx_init)
+	pushl	%ebp
+	movl	%esp, %ebp
+	
+	pushl	%edi
+	pushl	%esi
+	pushl	%ebx
+
+	movl	8(%ebp),%edx
+	movl	%edx,%edi
+	andl	$0xf,%edi
+	shrl	$4,%edx
+
+	pushl	%ebp
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	pushw	%ds
+
+	movw	%dx,%ds
+	leal	gfx_ofs_sys_cfg(%di),%esi
+	movl	gfx_ofs_mem_file(%di),%eax
+	movl	gfx_ofs_mem_cur(%di),%ebx
+	movl	gfx_ofs_mem_max(%di),%ecx
+	movw	%ds,%dx
+
+	/* basically just a lcall, but we need %edi */
+	pushw	%cs
+	pushw	$gfx_init_50
+	pushl	gfx_ofs_jmp_table + 4 * 0 (%di)
+
+	movl	gfx_ofs_mem_align(%di),%edi
+
+	lret
+
+gfx_init_50:
+	movl	$0,%ebx
+	adcl	$0,%ebx
+
+	popw	%ds
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	popl	%ebp
+
+	movl	%ebx,%eax
+	negl	%ebx
+	incl	%ebx
+	movl	8(%ebp),%edx
+	movl	%ebx,gfx_ofs_ok(%edx)
+
+	popl	%ebx
+	popl	%esi
+	popl	%edi
+
+	popl	%ebp
+	ret
+
+
+/*
+ * int gfx_done (gfx_data_t *gfx_data)
+ *
+ * shut down gfx things
+ *
+ * return vales:
+ *   always 0
+ *   sets gfx_data->ok
+ */
+
+ENTRY(gfx_done)
+	pushl	%ebp
+	movl	%esp, %ebp
+	
+	pushl	%edi
+	pushl	%esi
+	pushl	%ebx
+
+	movl	8(%ebp),%edx
+	movl	%edx,%ebx
+	andl	$0xf,%ebx
+	shrl	$4,%edx
+
+	pushl	%ebp
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	pushw	%ds
+
+	movw	%dx,%ds
+
+	lcall	*gfx_ofs_jmp_table + 4 * 1 (%bx)
+
+	popw	%ds
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	popl	%ebp
+
+	xorl	%eax,%eax
+	movl	8(%ebp),%edx
+	movl	%eax,gfx_ofs_ok(%edx)
+
+	popl	%ebx
+	popl	%esi
+	popl	%edi
+
+	popl	%ebp
+	ret
+
+
+/*
+ * int gfx_input (gfx_data_t *gfx_data, int *menu_entry)
+ *
+ * let user enter a command line
+ *
+ * uses gfx_data->cmdline as buffer
+ *
+ * return values:
+ *   1: abort
+ *   2: boot
+ *   menu_entry: selected entry
+ */
+
+ENTRY(gfx_input)
+	pushl	%ebp
+	movl	%esp, %ebp
+	
+	pushl	%edi
+	pushl	%esi
+	pushl	%ebx
+
+	movl	8(%ebp),%edx
+	movl	%edx,%ebx
+	andl	$0xf,%ebx
+	shrl	$4,%edx
+
+	pushl	%ebp
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	pushw	%ds
+
+	movw	%dx,%ds
+	shll	$4,%edx
+	movl	gfx_ofs_cmdline(%bx),%edi
+	subl	%edx,%edi
+	movw	gfx_ofs_cmdline_len(%bx),%cx
+	movw	gfx_ofs_timeout(%bx),%ax
+	imulw	$18,%ax
+
+	pushl	%ebp
+	lcall	*gfx_ofs_jmp_table + 4 * 2 (%bx)
+	popl	%ebp
+	movl	%eax,%ecx
+
+	popw	%ds
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	popl	%ebp
+
+	movl	12(%ebp),%edx
+	movl	%ebx,(%edx)
+
+	movl	%ecx,%eax
+
+	popl	%ebx
+	popl	%esi
+	popl	%edi
+
+	popl	%ebp
+	ret
+
+
+/*
+ * int gfx_setup_menu (gfx_data_t *gfx_data)
+ *
+ * draw boot menu
+ *
+ * return values:
+ *   always 0
+ */
+
+/* menu entry descriptor */
+#define menu_entries		0
+#define menu_default		2	/* seg:ofs */
+#define menu_ent_list		6	/* seg:ofs */
+#define menu_ent_size		10
+#define menu_arg_list		12	/* seg:ofs */
+#define menu_arg_size		16
+#define sizeof_menu_desc	18
+
+ENTRY(gfx_setup_menu)
+	pushl	%ebp
+	movl	%esp, %ebp
+	
+	pushl	%edi
+	pushl	%esi
+	pushl	%ebx
+
+	movl	8(%ebp),%edx
+	movl	%edx,%ebx
+	andl	$0xf,%ebx
+	shrl	$4,%edx
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	pushw	%ds
+
+	movw	%dx,%ds
+	shll	$4,%edx
+
+	subw	$sizeof_menu_desc,%sp
+	movw	%sp,%bp
+
+	movl	gfx_ofs_menu_entries(%bx),%eax
+	movw	%ax,menu_entries(%bp)
+
+	movl	gfx_ofs_menu_default_entry(%bx),%eax
+	subl	%edx,%eax
+	movw	%ax,menu_default(%bp)
+	movw	%ds,menu_default+2(%bp)
+
+	movl	gfx_ofs_menu_list(%bx),%eax
+	subl	%edx,%eax
+	movw	%ax,menu_ent_list(%bp)
+	movw	%ds,menu_ent_list+2(%bp)
+
+	movl	gfx_ofs_menu_entry_len(%bx),%eax
+	movw	%ax,menu_ent_size(%bp)
+
+	movl	gfx_ofs_args_list(%bx),%eax
+	subl	%edx,%eax
+	movw	%ax,menu_arg_list(%bp)
+	movw	%ds,menu_arg_list+2(%bp)
+
+	movl	gfx_ofs_args_entry_len(%bx),%eax
+	movw	%ax,menu_arg_size(%bp)
+
+	movw	%bp,%si
+	pushw	%ss
+	popw	%es
+	
+	lcall	%ds: *gfx_ofs_jmp_table + 4 * 3 (%bx)
+
+	addw	$sizeof_menu_desc,%sp
+
+	popw	%ds
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	xorl	%eax,%eax
+
+	popl	%ebx
+	popl	%esi
+	popl	%edi
+
+	popl	%ebp
+	ret
+
+
+/*
+ *
+ * end graphics stuff
+ *
+ * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+ */
+
 		
 /*
  * gateA20(int linear)
diff -Naur grub-0.97/stage2/asm.S~ grub-0.97-suse/stage2/asm.S~
--- grub-0.97/stage2/asm.S~	1969-12-31 21:00:00.000000000 -0300
+++ grub-0.97-suse/stage2/asm.S~	2006-09-09 17:00:12.000000000 -0300
@@ -0,0 +1,2655 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 1999,2000,2001,2002,2004 Free Software Foundation, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+/*
+ * Note: These functions defined in this file may be called from C.
+ *       Be careful of that you must not modify some registers. Quote
+ *       from gcc-2.95.2/gcc/config/i386/i386.h:
+	
+   1 for registers not available across function calls.
+   These must include the FIXED_REGISTERS and also any
+   registers that can be used without being saved.
+   The latter must include the registers where values are returned
+   and the register where structure-value addresses are passed.
+   Aside from that, you can include as many other registers as you like.
+
+  ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg
+{  1, 1, 1, 0, 0, 0, 0, 1, 1,  1,  1,  1,  1,  1,  1,  1,  1 }
+ */
+
+#define ASM_FILE
+
+#include "shared.h"
+
+#ifdef STAGE1_5
+# define	ABS(x)	((x) - EXT_C(main) + 0x2200)
+#else
+# define	ABS(x)	((x) - EXT_C(main) + 0x8200)
+#endif
+	
+	.file	"asm.S"
+
+	.text
+
+	/* Tell GAS to generate 16-bit instructions so that this code works
+	   in real mode. */
+	.code16
+
+#ifndef STAGE1_5
+	/* 
+	 * In stage2, do not link start.S with the rest of the source
+	 * files directly, so define the start symbols here just to
+	 * force ld quiet. These are not referred anyway.
+	 */
+	.globl	start, _start
+start:
+_start:
+#endif /* ! STAGE1_5 */
+	
+ENTRY(main)
+	/*
+	 *  Guarantee that "main" is loaded at 0x0:0x8200 in stage2 and
+	 *  at 0x0:0x2200 in stage1.5.
+	 */
+	ljmp $0, $ABS(codestart)
+
+	/*
+	 *  Compatibility version number
+	 *
+	 *  These MUST be at byte offset 6 and 7 of the executable
+	 *  DO NOT MOVE !!!
+	 */
+	. = EXT_C(main) + 0x6
+	.byte	COMPAT_VERSION_MAJOR, COMPAT_VERSION_MINOR
+
+	/*
+	 *  This is a special data area 8 bytes from the beginning.
+	 */
+
+	. = EXT_C(main) + 0x8
+
+VARIABLE(install_partition)
+	.long	0xFFFFFF
+/* This variable is here only because of a historical reason.  */
+VARIABLE(saved_entryno)
+	.long	0
+VARIABLE(stage2_id)
+	.byte	STAGE2_ID
+VARIABLE(force_lba)
+	.byte	0
+VARIABLE(version_string)
+	.string VERSION
+VARIABLE(config_file)
+#ifndef STAGE1_5
+	.string "/boot/grub/menu.lst"
+#else   /* STAGE1_5 */
+	.long	0xffffffff
+	.string "/boot/grub/stage2"
+#endif  /* STAGE1_5 */
+
+	/*
+	 *  Leave some breathing room for the config file name.
+	 */
+
+	. = EXT_C(main) + 0x70
+
+/* the real mode code continues... */
+codestart:
+	cli		/* we're not safe here! */
+
+	/* set up %ds, %ss, and %es */
+	xorw	%ax, %ax
+	movw	%ax, %ds
+	movw	%ax, %ss
+	movw	%ax, %es
+
+#ifndef SUPPORT_DISKLESS
+	/*
+	 * Save the sector number of the second sector (i.e. this sector)
+	 * in INSTALL_SECOND_SECTOR. See also "stage2/start.S".
+	 */
+	ADDR32	movl	%ebp, EXT_C(install_second_sector)
+#endif
+	
+	/* set up the real mode/BIOS stack */
+	movl	$STACKOFF, %ebp
+	movl	%ebp, %esp
+
+	sti		/* we're safe again */
+
+#ifndef SUPPORT_DISKLESS
+	/* save boot drive reference */
+	ADDR32	movb	%dl, EXT_C(boot_drive)
+
+	/* reset disk system (%ah = 0) */
+	int	$0x13
+#endif
+
+	/* transition to protected mode */
+	DATA32	call EXT_C(real_to_prot)
+
+	/* The ".code32" directive takes GAS out of 16-bit mode. */
+	.code32
+
+	/* clean out the bss */
+
+	/* set %edi to the bss starting address */
+#if defined(HAVE_USCORE_USCORE_BSS_START_SYMBOL)
+	movl	$__bss_start, %edi
+#elif defined(HAVE_USCORE_EDATA_SYMBOL)
+	movl	$_edata, %edi
+#elif defined(HAVE_EDATA_SYMBOL)
+	movl	$edata, %edi
+#endif
+
+	/* set %ecx to the bss end */	
+#if defined(HAVE_END_SYMBOL)
+	movl	$end, %ecx
+#elif defined(HAVE_USCORE_END_SYMBOL)
+	movl	$_end, %ecx
+#endif
+
+	/* compute the bss length */
+	subl	%edi, %ecx
+	
+	/* zero %al */
+	xorb	%al, %al
+
+	/* set the direction */
+	cld
+	
+	/* clean out */
+	rep
+	stosb
+	
+	/*
+	 *  Call the start of main body of C code, which does some
+	 *  of it's own initialization before transferring to "cmain".
+	 */
+	call EXT_C(init_bios_info)
+
+
+/*
+ *  This call is special...  it never returns...  in fact it should simply
+ *  hang at this point!
+ */
+
+ENTRY(stop)
+	call	EXT_C(prot_to_real)
+
+	/*
+	 * This next part is sort of evil.  It takes advantage of the
+	 * byte ordering on the x86 to work in either 16-bit or 32-bit
+	 * mode, so think about it before changing it.
+	 */
+
+ENTRY(hard_stop)
+	hlt
+	jmp EXT_C(hard_stop)
+
+#ifndef STAGE1_5
+/*
+ * stop_floppy()
+ *
+ * Stops the floppy drive from spinning, so that other software is
+ * jumped to with a known state.
+ */
+ENTRY(stop_floppy)
+	pusha
+	call	EXT_C(prot_to_real)
+	.code16
+	xorb	%dl, %dl
+	int	$0x13
+	DATA32  call EXT_C(real_to_prot)
+	.code32
+	popa
+	ret
+
+/*
+ * grub_reboot()
+ *
+ * Reboot the system. At the moment, rely on BIOS.
+ */
+ENTRY(grub_reboot)
+	call	EXT_C(prot_to_real)
+	.code16
+	/* cold boot */
+	movw	$0x0472, %di
+	movw	%ax, (%di)
+	ljmp	$0xFFFF, $0x0000
+	.code32
+	
+/*
+ * grub_halt(int no_apm)
+ *
+ * Halt the system, using APM if possible. If NO_APM is true, don't use
+ * APM even if it is available.
+ */
+ENTRY(grub_halt)
+	/* get the argument */
+	movl	4(%esp), %eax
+	
+	/* see if zero */
+	testl	%eax, %eax
+	jnz	EXT_C(stop)
+
+	call	EXT_C(prot_to_real)
+	.code16
+	
+	/* detect APM */
+	movw	$0x5300, %ax
+	xorw	%bx, %bx
+	int	$0x15
+	jc	EXT_C(hard_stop)
+	/* don't check %bx for buggy BIOSes... */
+
+	/* disconnect APM first */
+	movw	$0x5304, %ax
+	xorw	%bx, %bx
+	int	$0x15
+
+	/* connect APM */
+	movw	$0x5301, %ax
+	xorw	%bx, %bx
+	int	$0x15
+	jc	EXT_C(hard_stop)
+
+	/* set APM protocol level - 1.1 or bust. (this covers APM 1.2 also) */
+	movw	$0x530E, %ax
+	xorw	%bx, %bx
+	movw	$0x0101, %cx
+	int	$0x15
+	jc	EXT_C(hard_stop)
+	
+	/* set the power state to off */
+	movw	$0x5307, %ax
+	movw	$1, %bx
+	movw	$3, %cx
+	int	$0x15
+
+	/* shouldn't reach here */
+	jmp	EXT_C(hard_stop)
+	.code32
+	
+/*
+ * track_int13(int drive)
+ *
+ * Track the int13 handler to probe I/O address space.
+ */
+ENTRY(track_int13)
+	pushl	%ebp
+	movl	%esp, %ebp
+
+	pushl	%ebx
+	pushl	%edi
+
+	/* copy the original int13 handler segment:offset */
+	movl	$0x4c, %edi
+	movl	(%edi), %eax
+	movl	%eax, track_int13_addr
+		
+	/* replace the int1 handler */
+	movl	$0x4, %edi
+	pushl	(%edi)
+	movl	$ABS(int1_handler), %eax
+	movl	%eax, (%edi)
+
+	/* read the MBR to call int13 successfully */
+	movb	8(%ebp), %dl
+	
+	call	EXT_C(prot_to_real)
+	.code16
+
+	movw	$SCRATCHSEG, %ax
+	movw	%ax, %es
+	xorw	%bx, %bx
+	movw	$1, %cx
+	xorb	%dh, %dh
+
+	/* save FLAGS on the stack to emulate int13 */
+	pushfw
+	
+	/* set the TF flag */
+	/* FIXME: this can be simplified not to use AX */
+	pushfw
+	popw	%ax
+	orw	$0x100, %ax
+	pushw	%ax
+	popfw
+
+	movw	$0x0201, %ax
+
+	.byte	0x9a		/* lcall */
+track_int13_addr:
+	.word	0		/* offset */
+	.word	0		/* segment */
+
+	/* TF is cleared here automatically */
+	
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	/* restore the int1 handler */
+	movl	$0x4, %edi
+	popl	(%edi)
+
+	popl	%edi
+	popl	%ebx
+	popl	%ebp
+	
+	ret
+
+
+/*
+ * Check if the next instruction is I/O, and if this is true, add the
+ * port into the io map.
+ *
+ * Note: Probably this will make the execution of int13 very slow.
+ *
+ * Note2: In this implementation, all we can know is I/O-mapped I/O. It
+ * is impossible to detect memory-mapped I/O.
+ */
+int1_handler:
+	.code16
+	
+	pushw	%bp
+	movw	%sp, %bp
+	pushw	%ds
+	pushw	%ax
+	pushw	%si
+	pushw	%dx
+	
+	/* IP */
+	movw	2(%bp), %si
+	/* CS */
+	movw	4(%bp), %ax
+	movw	%ax, %ds
+
+	/* examine the next instruction */
+1:	lodsb	(%si), %al
+	/* skip this code if it is a prefix */
+	cmpb	$0x2E, %al
+	je	1b
+	cmpb	$0x36, %al
+	je	1b
+	cmpb	$0x3E, %al
+	je	1b
+	cmpb	$0x26, %al
+	je	1b
+	cmpb	$0x64, %al
+	jl	2f
+	cmpb	$0x67, %al
+	jle	1b
+2:	cmpb	$0xF0, %al
+	jl	3f
+	cmpb	$0xF3, %al
+	jle	1b
+	
+3:	/* check if this code is out* or in* */
+
+	/* ins? or outs? */
+	cmpb	$0x6C, %al
+	jl	4f
+	cmpb	$0x6F, %al
+	jle	5f
+
+4:	/* in? or out? (register operand version) */
+	cmpb	$0xEC, %al
+	jl	6f
+	cmpb	$0xEF, %al
+	jle	5f
+	
+6:	/* in? or out? (immediate operand version) */
+	cmpb	$0xE4, %al
+	jl	8f
+	cmpb	$0xE7, %al
+	jg	8f
+
+7:	/* immediate has a port */
+	lodsb	(%si), %al
+	movzbw	%al, %dx
+	
+5:	/* %dx has a port */
+
+	/* set %ds to zero */
+	xorw	%ax, %ax
+	movw	%ax, %ds
+		
+	/* set %si to the io map */
+	movw	$ABS(EXT_C(io_map)), %si
+
+		
+9:	/* check if the io map already has the port */
+	lodsw	(%si), %ax
+	/* check if this is the end */
+	testw	%ax, %ax
+	jz	1f
+	/* check if this matches the port */
+	cmpw	%ax, %dx
+	jne	9b
+	/* if so, leave from this handler */
+	jmp	8f
+	
+1:	/* check for the buffer overrun */
+	cmpw	$(ABS(EXT_C(io_map)) + (IO_MAP_SIZE + 1) * 2), %si
+	je	8f
+	/* add the port into the io map */
+	movw	%dx, -2(%si)
+
+8:	/* restore registers */	
+	popw	%dx
+	popw	%si
+	popw	%ax
+	popw	%ds
+	popw	%bp
+
+	iret
+	
+	.code32
+
+ENTRY(io_map)
+	.space	(IO_MAP_SIZE + 1) * 2
+	
+	
+/*
+ * set_int15_handler(void)
+ *
+ * Set up int15_handler.
+ */
+ENTRY(set_int15_handler)
+	pushl	%edi
+	
+	/* save the original int15 handler */
+	movl	$0x54, %edi
+	movw	(%edi), %ax
+	movw	%ax, ABS(int15_offset)
+	movw	2(%edi), %ax
+	movw	%ax, ABS(int15_segment)
+
+	/* save the new int15 handler */
+	movw	$ABS(int15_handler), %ax
+	movw	%ax, (%edi)
+	xorw	%ax, %ax
+	movw	%ax, 2(%edi)
+
+	popl	%edi
+	ret
+
+
+/*
+ * unset_int15_handler(void)
+ *
+ * Restore the original int15 handler
+ */
+ENTRY(unset_int15_handler)
+	pushl	%edi
+	
+	/* check if int15_handler is set */
+	movl	$0x54, %edi
+	movw	$ABS(int15_handler), %ax
+	cmpw	%ax, (%edi)
+	jne	1f
+	xorw	%ax, %ax
+	cmpw	%ax, 2(%edi)
+	jne	1f
+
+	/* restore the original */
+	movw	ABS(int15_offset), %ax
+	movw	%ax, (%edi)
+	movw	ABS(int15_segment), %ax
+	movw	%ax, 2(%edi)
+
+1:
+	popl	%edi
+	ret
+
+
+/*
+ * Translate a key code to another.
+ *
+ * Note: This implementation cannot handle more than one length
+ * scancodes (such as Right Ctrl).
+ */
+	.code16
+int15_handler:
+	/* if non-carrier, ignore it */
+	jnc	1f
+	/* check if AH=4F */
+	cmpb	$0x4F, %ah
+	jne	1f
+
+	/* E0 and E1 are special */
+	cmpb	$0xE1, %al
+	je	4f
+	cmpb	$0xE0, %al
+	/* this flag is actually the machine code (je or jmp) */
+int15_skip_flag:	
+	je	4f
+	
+	pushw	%bp
+	movw	%sp, %bp
+	
+	pushw	%bx
+	pushw	%dx
+	pushw	%ds
+	pushw	%si
+
+	/* save bits 0-6 of %al in %dl */
+	movw	%ax, %dx
+	andb	$0x7f, %dl
+	/* save the highest bit in %bl */
+	movb	%al, %bl
+	xorb	%dl, %bl
+	/* set %ds to 0 */
+	xorw	%ax, %ax
+	movw	%ax, %ds
+	/* set %si to the key map */
+	movw	$ABS(EXT_C(bios_key_map)), %si
+
+	/* find the key code from the key map */
+2:
+	lodsw
+	/* check if this is the end */
+	testw	%ax, %ax
+	jz	3f
+	/* check if this matches the key code */
+	cmpb	%al, %dl
+	jne	2b
+	/* if so, perform the mapping */
+	movb	%ah, %dl
+3:
+	/* restore %ax */
+	movw	%dx, %ax
+	orb	%bl, %al
+	/* make sure that CF is set */
+	orw	$1, 6(%bp)
+	/* restore other registers */
+	popw	%si
+	popw	%ds
+	popw	%dx
+	popw	%bx
+	popw	%bp
+	iret
+	
+4:
+	/* tricky: jmp (0x74) <-> je (0xeb) */
+	xorb	$(0x74 ^ 0xeb), ABS(int15_skip_flag)
+1:
+	/* just cascade to the original */
+	/* ljmp */
+	.byte	0xea
+int15_offset:	.word	0
+int15_segment:	.word	0
+
+	.code32
+
+	.align	4	
+ENTRY(bios_key_map)
+	.space	(KEY_MAP_SIZE + 1) * 2
+	
+	
+/*
+ * set_int13_handler(map)
+ *
+ * Copy MAP to the drive map and set up int13_handler.
+ */
+ENTRY(set_int13_handler)
+	pushl	%ebp
+	movl	%esp, %ebp
+
+	pushl	%edi
+	pushl	%esi
+
+	/* copy MAP to the drive map */
+	movl	$(DRIVE_MAP_SIZE * 2), %ecx
+	movl	$ABS(drive_map), %edi
+	movl	8(%ebp), %esi
+	cld
+	rep
+	movsb
+
+	/* save the original int13 handler */
+	movl	$0x4c, %edi
+	movw	(%edi), %ax
+	movw	%ax, ABS(int13_offset)
+	movw	2(%edi), %ax
+	movw	%ax, ABS(int13_segment)
+	
+	/* decrease the lower memory size and set it to the BIOS memory */
+	movl	$0x413, %edi
+	decw	(%edi)
+	xorl	%eax, %eax
+	movw	(%edi), %ax
+	
+	/* compute the segment */
+	shll	$6, %eax
+
+	/* save the new int13 handler */
+	movl	$0x4c, %edi
+	movw	%ax, 2(%edi)
+	xorw	%cx, %cx
+	movw	%cx, (%edi)
+
+	/* copy int13_handler to the reserved area */
+	shll	$4, %eax
+	movl	%eax, %edi
+	movl	$ABS(int13_handler), %esi
+	movl	$(int13_handler_end - int13_handler), %ecx
+	rep
+	movsb
+
+	popl	%esi
+	popl	%edi
+	popl	%ebp
+	ret
+
+	
+/* 
+ * Map a drive to another drive.
+ */
+	
+	.code16
+	
+int13_handler:
+	pushw	%ax
+	pushw	%bp
+	movw	%sp, %bp
+	
+	pushw	%si
+
+	/* set %si to the drive map */
+	movw	$(drive_map - int13_handler), %si
+	/* find the drive number from the drive map */
+	cld
+1:	
+	lodsw	%cs:(%si), %ax
+	/* check if this is the end */
+	testw	%ax, %ax
+	jz	2f
+	/* check if this matches the drive number */
+	cmpb	%al, %dl
+	jne	1b
+	/* if so, perform the mapping */
+	movb	%ah, %dl
+2:
+	/* restore %si */
+	popw	%si
+	/* save %ax in the stack */
+	pushw	%ax
+	/* simulate the interrupt call */
+	pushw	8(%bp)
+	/* set %ax and %bp to the original values */
+	movw	2(%bp), %ax
+	movw	(%bp), %bp
+	/* lcall */
+	.byte	0x9a
+int13_offset:	.word	0
+int13_segment:	.word	0
+	/* save flags */
+	pushf
+	/* restore %bp */
+	movw	%sp, %bp
+	/* save %ax */
+	pushw	%ax
+	/* set the flags in the stack to the value returned by int13 */
+	movw	(%bp), %ax
+	movw	%ax, 0xc(%bp)
+	/* check if should map the drive number */
+	movw	6(%bp), %ax
+	cmpw	$0x8, %ax
+	jne	3f
+	cmpw	$0x15, %ax
+	jne	3f
+	/* check if the mapping was performed */
+	movw	2(%bp), %ax
+	testw	%ax, %ax
+	jz	3f
+	/* perform the mapping */
+	movb	%al, %dl
+3:
+	popw	%ax
+	movw	4(%bp), %bp
+	addw	$8, %sp
+	iret
+
+	.align	4
+drive_map:	.space	(DRIVE_MAP_SIZE + 1) * 2
+int13_handler_end:
+	
+	.code32
+	
+	
+/*
+ * chain_stage1(segment, offset, part_table_addr)
+ *
+ *  This starts another stage1 loader, at segment:offset.
+ */
+
+ENTRY(chain_stage1)
+	/* no need to save anything, just use %esp */
+
+	/* store %ESI, presuming %ES is 0 */
+	movl	0xc(%esp), %esi
+
+	/* store new offset */
+	movl	0x8(%esp), %eax
+	movl	%eax, offset
+
+	/* store new segment */
+	movw	0x4(%esp), %ax
+	movw	%ax, segment
+
+	/* set up to pass boot drive */
+	movb	EXT_C(boot_drive), %dl
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+	DATA32	ADDR32	ljmp	(offset)
+#else
+	DATA32	ADDR32	ljmp	*(offset)
+#endif
+	.code32
+#endif /* STAGE1_5 */
+
+
+#ifdef STAGE1_5
+/*
+ * chain_stage2(segment, offset, second_sector)
+ *
+ *  This starts another stage2 loader, at segment:offset.  It presumes
+ *  that the other one starts with this same "asm.S" file, and passes
+ *  parameters by writing the embedded install variables.
+ */
+
+ENTRY(chain_stage2)
+	/* no need to save anything, just use %esp */
+
+	/* store new offset */
+	movl	0x8(%esp), %eax
+	movl	%eax, offset
+	movl	%eax, %ebx
+
+	/* store new segment */
+	movw	0x4(%esp), %ax
+	movw	%ax, segment
+	shll	$4, %eax
+
+	/* generate linear address */
+	addl	%eax, %ebx
+
+	/* set up to pass the partition where stage2 is located in */
+	movl	EXT_C(current_partition), %eax
+	movl	%eax, (EXT_C(install_partition)-EXT_C(main))(%ebx)
+
+	/* set up to pass the drive where stage2 is located in */
+	movb	EXT_C(current_drive), %dl
+
+	/* set up to pass the second sector of stage2 */
+	movl	0xc(%esp), %ecx
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	movl	%ecx, %ebp
+
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+	DATA32	ADDR32	ljmp	(offset)
+#else
+	DATA32	ADDR32	ljmp	*(offset)
+#endif
+
+	.code32
+#endif /* STAGE1_5 */
+	
+/*
+ *  These next two routines, "real_to_prot" and "prot_to_real" are structured
+ *  in a very specific way.  Be very careful when changing them.
+ *
+ *  NOTE:  Use of either one messes up %eax and %ebp.
+ */
+
+ENTRY(real_to_prot)
+	.code16
+	cli
+
+	/* load the GDT register */
+	DATA32	ADDR32	lgdt	gdtdesc
+
+	/* turn on protected mode */
+	movl	%cr0, %eax
+	orl	$CR0_PE_ON, %eax
+	movl	%eax, %cr0
+
+	/* jump to relocation, flush prefetch queue, and reload %cs */
+	DATA32	ljmp	$PROT_MODE_CSEG, $protcseg
+
+	/*
+	 *  The ".code32" directive only works in GAS, the GNU assembler!
+	 *  This gets out of "16-bit" mode.
+	 */
+	.code32
+
+protcseg:
+	/* reload other segment registers */
+	movw	$PROT_MODE_DSEG, %ax
+	movw	%ax, %ds
+	movw	%ax, %es
+	movw	%ax, %fs
+	movw	%ax, %gs
+	movw	%ax, %ss
+
+	/* put the return address in a known safe location */
+	movl	(%esp), %eax
+	movl	%eax, STACKOFF
+
+	/* get protected mode stack */
+	movl	protstack, %eax
+	movl	%eax, %esp
+	movl	%eax, %ebp
+
+	/* get return address onto the right stack */
+	movl	STACKOFF, %eax
+	movl	%eax, (%esp)
+
+	/* zero %eax */
+	xorl	%eax, %eax
+
+	/* return on the old (or initialized) stack! */
+	ret
+
+
+ENTRY(prot_to_real)
+	/* just in case, set GDT */
+	lgdt	gdtdesc
+
+	/* save the protected mode stack */
+	movl	%esp, %eax
+	movl	%eax, protstack
+
+	/* get the return address */
+	movl	(%esp), %eax
+	movl	%eax, STACKOFF
+
+	/* set up new stack */
+	movl	$STACKOFF, %eax
+	movl	%eax, %esp
+	movl	%eax, %ebp
+
+	/* set up segment limits */
+	movw	$PSEUDO_RM_DSEG, %ax
+	movw	%ax, %ds
+	movw	%ax, %es
+	movw	%ax, %fs
+	movw	%ax, %gs
+	movw	%ax, %ss
+
+	/* this might be an extra step */
+	ljmp	$PSEUDO_RM_CSEG, $tmpcseg	/* jump to a 16 bit segment */
+
+tmpcseg:
+	.code16
+
+	/* clear the PE bit of CR0 */
+	movl	%cr0, %eax
+	andl 	$CR0_PE_OFF, %eax
+	movl	%eax, %cr0
+
+	/* flush prefetch queue, reload %cs */
+	DATA32	ljmp	$0, $realcseg
+
+realcseg:
+	/* we are in real mode now
+	 * set up the real mode segment registers : DS, SS, ES
+	 */
+	/* zero %eax */
+	xorl	%eax, %eax
+
+	movw	%ax, %ds
+	movw	%ax, %es
+	movw	%ax, %fs
+	movw	%ax, %gs
+	movw	%ax, %ss
+
+	/* restore interrupts */
+	sti
+
+	/* return on new stack! */
+	DATA32	ret
+
+	.code32
+
+
+/*
+ *   int biosdisk_int13_extensions (int ax, int drive, void *dap)
+ *
+ *   Call IBM/MS INT13 Extensions (int 13 %ax=AX) for DRIVE. DAP
+ *   is passed for disk address packet. If an error occurs, return
+ *   non-zero, otherwise zero.
+ */
+
+ENTRY(biosdisk_int13_extensions)
+	pushl	%ebp
+	movl	%esp, %ebp
+
+	pushl	%esi
+	pushl	%ebx
+
+	/* compute the address of disk_address_packet */
+	movl	0x10(%ebp), %eax
+	movw	%ax, %si
+	xorw	%ax, %ax
+	shrl	$4, %eax
+	movw	%ax, %cx	/* save the segment to cx */
+
+	/* drive */
+	movb	0xc(%ebp), %dl
+	/* ax */
+	movw	0x8(%ebp), %bx
+	/* enter real mode */
+	call	EXT_C(prot_to_real)
+	
+	.code16
+	movw	%bx, %ax
+	movw	%cx, %ds
+	int	$0x13		/* do the operation */
+	movb	%ah, %dl	/* save return value */
+	/* clear the data segment */
+	xorw	%ax, %ax
+	movw	%ax, %ds
+	/* back to protected mode */
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	movb	%dl, %al	/* return value in %eax */
+
+	popl	%ebx
+	popl	%esi
+	popl	%ebp
+
+	ret
+	
+/*
+ *   int biosdisk_standard (int ah, int drive, int coff, int hoff, int soff,
+ *                          int nsec, int segment)
+ *
+ *   Call standard and old INT13 (int 13 %ah=AH) for DRIVE. Read/write
+ *   NSEC sectors from COFF/HOFF/SOFF into SEGMENT. If an error occurs,
+ *   return non-zero, otherwise zero.
+ */
+
+ENTRY(biosdisk_standard)
+	pushl	%ebp
+	movl	%esp, %ebp
+
+	pushl	%ebx
+	pushl	%edi
+	pushl	%esi
+
+	/* set up CHS information */
+	movl	0x10(%ebp), %eax
+	movb	%al, %ch
+	movb	0x18(%ebp), %al
+	shlb	$2, %al
+	shrw	$2, %ax
+	movb	%al, %cl
+	movb	0x14(%ebp), %dh
+	/* drive */
+	movb	0xc(%ebp), %dl
+	/* segment */
+	movw	0x20(%ebp), %bx
+	/* save nsec and ah to %di */
+	movb	0x8(%ebp), %ah
+	movb	0x1c(%ebp), %al
+	movw	%ax, %di
+	/* enter real mode */
+	call	EXT_C(prot_to_real)
+
+	.code16
+	movw	%bx, %es
+	xorw	%bx, %bx
+	movw	$3, %si		/* attempt at least three times */
+
+1:	
+	movw	%di, %ax
+	int	$0x13		/* do the operation */
+	jnc	2f		/* check if successful */
+
+	movb	%ah, %bl	/* save return value */
+	/* if fail, reset the disk system */
+	xorw	%ax, %ax
+	int	$0x13
+	
+	decw	%si
+	cmpw	$0, %si
+	je	2f
+	xorb	%bl, %bl
+	jmp	1b		/* retry */
+2:	
+	/* back to protected mode */
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	movb	%bl, %al	/* return value in %eax */
+	
+	popl	%esi
+	popl	%edi
+	popl	%ebx
+	popl	%ebp
+
+	ret
+
+
+/*
+ *   int check_int13_extensions (int drive)
+ *
+ *   Check if LBA is supported for DRIVE. If it is supported, then return
+ *   the major version of extensions, otherwise zero.
+ */
+
+ENTRY(check_int13_extensions)
+	pushl	%ebp
+	movl	%esp, %ebp
+
+	pushl	%ebx
+
+	/* drive */
+	movb	0x8(%ebp), %dl
+	/* enter real mode */
+	call	EXT_C(prot_to_real)
+
+	.code16
+	movb	$0x41, %ah
+	movw	$0x55aa, %bx
+	int	$0x13		/* do the operation */
+	
+	/* check the result */
+	jc	1f
+	cmpw	$0xaa55, %bx
+	jne	1f
+
+	movb	%ah, %bl	/* save the major version into %bl */
+
+	/* check if AH=0x42 is supported if FORCE_LBA is zero */
+	movb	EXT_C(force_lba), %al
+	testb	%al, %al
+	jnz	2f
+	andw	$1, %cx
+	jnz	2f
+	
+1:
+	xorb	%bl, %bl
+2:
+	/* back to protected mode */
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	movb	%bl, %al	/* return value in %eax */
+
+	popl	%ebx
+	popl	%ebp
+
+	ret
+
+
+/*
+ *   int get_diskinfo_standard (int drive, unsigned long *cylinders, 
+ *                              unsigned long *heads, unsigned long *sectors)
+ *
+ *   Return the geometry of DRIVE in CYLINDERS, HEADS and SECTORS. If an
+ *   error occurs, then return non-zero, otherwise zero.
+ */
+
+ENTRY(get_diskinfo_standard)
+	pushl	%ebp
+	movl	%esp, %ebp
+
+	pushl	%ebx
+	pushl	%edi
+
+	/* drive */
+	movb	0x8(%ebp), %dl
+	/* enter real mode */
+	call	EXT_C(prot_to_real)
+
+	.code16
+	movb	$0x8, %ah
+	int	$0x13		/* do the operation */
+	/* check if successful */
+	testb	%ah, %ah
+	jnz	1f
+	/* bogus BIOSes may not return an error number */
+	testb	$0x3f, %cl	/* 0 sectors means no disk */
+	jnz	1f		/* if non-zero, then succeed */
+	/* XXX 0x60 is one of the unused error numbers */
+	movb	$0x60, %ah
+1:
+	movb	%ah, %bl	/* save return value in %bl */
+	/* back to protected mode */
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	/* restore %ebp */
+	leal	0x8(%esp), %ebp
+	
+	/* heads */
+	movb	%dh, %al
+	incl	%eax		/* the number of heads is counted from zero */
+	movl	0x10(%ebp), %edi
+	movl	%eax, (%edi)
+
+	/* sectors */
+	xorl	%eax, %eax
+	movb	%cl, %al
+	andb	$0x3f, %al
+	movl	0x14(%ebp), %edi
+	movl	%eax, (%edi)
+
+	/* cylinders */
+	shrb	$6, %cl
+	movb	%cl, %ah
+	movb	%ch, %al
+	incl	%eax		/* the number of cylinders is 
+				   counted from zero */
+	movl	0xc(%ebp), %edi
+	movl	%eax, (%edi)
+
+	xorl	%eax, %eax
+	movb	%bl, %al	/* return value in %eax */
+
+	popl	%edi
+	popl	%ebx
+	popl	%ebp
+
+	ret
+
+
+#if 0		
+/*
+ *   int get_diskinfo_floppy (int drive, unsigned long *cylinders, 
+ *                            unsigned long *heads, unsigned long *sectors)
+ *
+ *   Return the geometry of DRIVE in CYLINDERS, HEADS and SECTORS. If an
+ *   error occurs, then return non-zero, otherwise zero.
+ */
+
+ENTRY(get_diskinfo_floppy)
+	pushl	%ebp
+	movl	%esp, %ebp
+
+	pushl	%ebx
+	pushl	%esi
+
+	/* drive */
+	movb	0x8(%ebp), %dl
+	/* enter real mode */
+	call	EXT_C(prot_to_real)
+
+	.code16
+	/* init probe value */
+	movl	$probe_values-1, %esi
+1:
+	xorw	%ax, %ax
+	int	$0x13		/* reset floppy controller */
+
+	incw	%si
+	movb	(%si), %cl
+	cmpb	$0, %cl		/* probe failed if zero */
+	je	2f
+
+	/* perform read */
+	movw	$SCRATCHSEG, %ax
+	movw	%ax, %es
+	xorw	%bx, %bx
+	movw	$0x0201, %ax
+	movb	$0, %ch
+	movb	$0, %dh
+	int	$0x13
+
+	/* FIXME: Read from floppy may fail even if the geometry is correct.
+	   So should retry at least three times.  */
+	jc	1b		/* next value */
+	
+	/* succeed */
+	jmp	2f
+	
+probe_values:
+	.byte	36, 18, 15, 9, 0
+	
+2:
+	/* back to protected mode */
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	/* restore %ebp */
+	leal	0x8(%esp), %ebp
+	
+	/* cylinders */
+	movl	0xc(%ebp), %eax
+	movl	$80, %ebx
+	movl	%ebx, (%eax)
+	/* heads */
+	movl	0x10(%ebp), %eax
+	movl	$2, %ebx
+	movl	%ebx, (%eax)
+	/* sectors */
+	movl	0x14(%ebp), %eax
+	movzbl	%cl, %ebx
+	movl	%ebx, (%eax)
+
+	/* return value in %eax */
+	xorl	%eax, %eax
+	cmpb	$0, %cl
+	jne	3f
+	incl	%eax		/* %eax = 1 (non-zero) */
+3:
+	popl	%esi
+	popl	%ebx
+	popl	%ebp
+
+	ret
+#endif
+	
+
+/* Source files are splitted, as they have different copyrights.  */
+#ifndef STAGE1_5
+# include "setjmp.S"
+# include "apm.S"
+#endif /* ! STAGE1_5 */
+		
+	
+
+#ifndef STAGE1_5
+/* get_code_end() :  return the address of the end of the code
+ * This is here so that it can be replaced by asmstub.c.
+ */
+ENTRY(get_code_end)
+	/* will be the end of the bss */
+# if defined(HAVE_END_SYMBOL)
+	movl	$end, %eax
+# elif defined(HAVE_USCORE_END_SYMBOL)
+	movl	$_end, %eax
+# endif
+	shrl	$2, %eax		/* Round up to the next word. */
+	incl	%eax
+	shll	$2, %eax
+	ret
+#endif /* ! STAGE1_5 */
+
+/*
+ *
+ * get_memsize(i) :  return the memory size in KB. i == 0 for conventional
+ *		memory, i == 1 for extended memory
+ *	BIOS call "INT 12H" to get conventional memory size
+ *	BIOS call "INT 15H, AH=88H" to get extended memory size
+ *		Both have the return value in AX.
+ *
+ */
+
+ENTRY(get_memsize)
+	push	%ebp
+	push	%ebx
+
+	mov	0xc(%esp), %ebx
+
+	call	EXT_C(prot_to_real)	/* enter real mode */
+	.code16
+
+	cmpb	$0x1, %bl
+	DATA32	je	xext
+
+	int	$0x12
+	DATA32	jmp	xdone
+
+xext:
+	movb	$0x88, %ah
+	int	$0x15
+
+xdone:
+	movw	%ax, %bx
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	movw	%bx, %ax
+	pop	%ebx
+	pop	%ebp
+	ret
+
+
+#ifndef STAGE1_5
+
+/*
+ *
+ * get_eisamemsize() :  return packed EISA memory map, lower 16 bits is
+ *		memory between 1M and 16M in 1K parts, upper 16 bits is
+ *		memory above 16M in 64K parts.  If error, return -1.
+ *	BIOS call "INT 15H, AH=E801H" to get EISA memory map,
+ *		AX = memory between 1M and 16M in 1K parts.
+ *		BX = memory above 16M in 64K parts.
+ *
+ */
+
+ENTRY(get_eisamemsize)
+	push	%ebp
+	push	%ebx
+
+	call	EXT_C(prot_to_real)	/* enter real mode */
+	.code16
+
+	movw	$0xe801, %ax
+	int	$0x15
+
+	shll	$16, %ebx
+	movw	%ax, %bx
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	movl	$0xFFFFFFFF, %eax
+	cmpb	$0x86, %bh
+	je	xnoteisa
+
+	movl	%ebx, %eax
+
+xnoteisa:
+	pop	%ebx
+	pop	%ebp
+	ret
+
+/*
+ *
+ * get_mmap_entry(addr, cont) :  address and old continuation value (zero to
+ *		start), for the Query System Address Map BIOS call.
+ *
+ *  Sets the first 4-byte int value of "addr" to the size returned by
+ *  the call.  If the call fails, sets it to zero.
+ *
+ *	Returns:  new (non-zero) continuation value, 0 if done.
+ *
+ * NOTE: Currently hard-coded for a maximum buffer length of 1024.
+ */
+
+ENTRY(get_mmap_entry)
+	push	%ebp
+	push	%ebx
+	push	%edi
+	push	%esi
+
+	/* place address (+4) in ES:DI */
+	movl	0x14(%esp), %eax
+	addl	$4, %eax
+	movl	%eax, %edi
+	andl	$0xf, %edi
+	shrl	$4, %eax
+	movl	%eax, %esi
+
+	/* set continuation value */
+	movl	0x18(%esp), %ebx
+
+	/* set default maximum buffer size */
+	movl	$0x14, %ecx
+
+	/* set EDX to 'SMAP' */
+	movl	$0x534d4150, %edx
+
+	call	EXT_C(prot_to_real)	/* enter real mode */
+	.code16
+
+	movw	%si, %es
+	movl	$0xe820, %eax
+	int	$0x15
+
+	DATA32	jc	xnosmap
+
+	cmpl	$0x534d4150, %eax
+	DATA32	jne	xnosmap
+
+	cmpl	$0x14, %ecx
+	DATA32	jl	xnosmap
+
+	cmpl	$0x400, %ecx
+	DATA32	jg	xnosmap
+
+	DATA32	jmp	xsmap
+
+xnosmap:
+	movl	$0, %ecx
+
+xsmap:
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	/* write length of buffer (zero if error) into "addr" */
+	movl	0x14(%esp), %eax
+	movl	%ecx, (%eax)
+
+	/* set return value to continuation */
+	movl	%ebx, %eax
+
+	pop	%esi
+	pop	%edi
+	pop	%ebx
+	pop	%ebp
+	ret
+
+/*
+ * get_rom_config_table()
+ *
+ * Get the linear address of a ROM configuration table. Return zero,
+ * if fails.
+ */
+	
+ENTRY(get_rom_config_table)
+	pushl	%ebp
+	pushl	%ebx
+
+	/* zero %ebx for simplicity */
+	xorl	%ebx, %ebx
+	
+	call	EXT_C(prot_to_real)
+	.code16
+
+	movw	$0xc0, %ax
+	int	$0x15
+
+	jc	no_rom_table
+	testb	%ah, %ah
+	jnz	no_rom_table
+	
+	movw	%es, %dx
+	jmp	found_rom_table
+	
+no_rom_table:
+	xorw	%dx, %dx
+	xorw	%bx, %bx
+	
+found_rom_table:
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	/* compute the linear address */
+	movw	%dx, %ax
+	shll	$4, %eax
+	addl	%ebx, %eax
+
+	popl	%ebx
+	popl	%ebp
+	ret
+
+
+/*
+ * int get_vbe_controller_info (struct vbe_controller *controller_ptr)
+ *
+ * Get VBE controller information.
+ */
+
+ENTRY(get_vbe_controller_info)
+	pushl	%ebp
+	movl	%esp, %ebp
+	
+	pushl	%edi
+	pushl	%ebx
+
+	/* Convert the linear address to segment:offset */
+	movl	8(%ebp), %eax
+	movl	%eax, %edi
+	andl	$0x0000000f, %edi
+	shrl	$4, %eax
+	movl	%eax, %ebx
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	movw	%bx, %es
+	movw	$0x4F00, %ax
+	int	$0x10
+
+	movw	%ax, %bx
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	movzwl	%bx, %eax
+
+	popl	%ebx
+	popl	%edi
+	popl	%ebp
+	ret
+
+	
+/*
+ * int get_vbe_mode_info (int mode_number, struct vbe_mode *mode_ptr)
+ *
+ * Get VBE mode information.
+ */
+
+ENTRY(get_vbe_mode_info)
+	pushl	%ebp
+	movl	%esp, %ebp
+	
+	pushl	%edi
+	pushl	%ebx
+
+	/* Convert the linear address to segment:offset */
+	movl	0xc(%ebp), %eax
+	movl	%eax, %edi
+	andl	$0x0000000f, %edi
+	shrl	$4, %eax
+	movl	%eax, %ebx
+
+	/* Save the mode number in %cx */
+	movl	0x8(%ebp), %ecx
+	
+	call	EXT_C(prot_to_real)
+	.code16
+
+	movw	%bx, %es
+	movw	$0x4F01, %ax
+	int	$0x10
+
+	movw	%ax, %bx
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	movzwl	%bx, %eax
+
+	popl	%ebx
+	popl	%edi
+	popl	%ebp
+	ret
+
+	
+/*
+ * int set_vbe_mode (int mode_number)
+ *
+ * Set VBE mode. Don't support user-specified CRTC information.
+ */
+
+ENTRY(set_vbe_mode)
+	pushl	%ebp
+	movl	%esp, %ebp
+	
+	pushl	%ebx
+
+	/* Save the mode number in %bx */
+	movl	0x8(%ebp), %ebx
+	/* Clear bit D11 */
+	andl	$0xF7FF, %ebx
+	
+	call	EXT_C(prot_to_real)
+	.code16
+
+	movw	$0x4F02, %ax
+	int	$0x10
+
+	movw	%ax, %bx
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	movzwl	%bx, %eax
+
+	popl	%ebx
+	popl	%ebp
+	ret
+
+
+/*
+ * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+ *
+ * graphical menu functions
+ *
+ */
+
+/*
+ * int gfx_init (gfx_data_t *gfx_data)
+ *
+ * init gfx things
+ *
+ * return vales:
+ *   0: ok
+ *   1: failed
+ *   sets gfx_data->ok
+ */
+
+ENTRY(gfx_init)
+	pushl	%ebp
+	movl	%esp, %ebp
+	
+	pushl	%edi
+	pushl	%esi
+	pushl	%ebx
+
+	movl	8(%ebp),%edx
+	movl	%edx,%edi
+	andl	$0xf,%edi
+	shrl	$4,%edx
+
+	pushl	%ebp
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	pushw	%ds
+
+	movw	%dx,%ds
+	shll	$4,%edx
+	leal	gfx_ofs_sys_cfg(%di),%esi
+	movl	gfx_ofs_mem_start(%di),%eax
+	movl	gfx_ofs_mem_cur(%di),%ebx
+	movl	gfx_ofs_mem_max(%di),%ecx
+	movw	%ds,%dx
+
+	lcall	*gfx_ofs_jmp_table + 4 * 0 (%di)
+
+	movl	$0,%ebx
+	adcl	$0,%ebx
+
+	popw	%ds
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	popl	%ebp
+
+	movl	%ebx,%eax
+	negl	%ebx
+	incl	%ebx
+	movl	8(%ebp),%edx
+	movl	%ebx,gfx_ofs_ok(%edx)
+
+	popl	%ebx
+	popl	%esi
+	popl	%edi
+
+	popl	%ebp
+	ret
+
+
+/*
+ * int gfx_done (gfx_data_t *gfx_data)
+ *
+ * shut down gfx things
+ *
+ * return vales:
+ *   always 0
+ *   sets gfx_data->ok
+ */
+
+ENTRY(gfx_done)
+	pushl	%ebp
+	movl	%esp, %ebp
+	
+	pushl	%edi
+	pushl	%esi
+	pushl	%ebx
+
+	movl	8(%ebp),%edx
+	movl	%edx,%ebx
+	andl	$0xf,%ebx
+	shrl	$4,%edx
+
+	pushl	%ebp
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	pushw	%ds
+
+	movw	%dx,%ds
+
+	lcall	*gfx_ofs_jmp_table + 4 * 1 (%bx)
+
+	popw	%ds
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	popl	%ebp
+
+	xorl	%eax,%eax
+	movl	8(%ebp),%edx
+	movl	%eax,gfx_ofs_ok(%edx)
+
+	popl	%ebx
+	popl	%esi
+	popl	%edi
+
+	popl	%ebp
+	ret
+
+
+/*
+ * int gfx_input (gfx_data_t *gfx_data, int *menu_entry)
+ *
+ * let user enter a command line
+ *
+ * uses gfx_data->cmdline as buffer
+ *
+ * return values:
+ *   1: abort
+ *   2: boot
+ *   menu_entry: selected entry
+ */
+
+ENTRY(gfx_input)
+	pushl	%ebp
+	movl	%esp, %ebp
+	
+	pushl	%edi
+	pushl	%esi
+	pushl	%ebx
+
+	movl	8(%ebp),%edx
+	movl	%edx,%ebx
+	andl	$0xf,%ebx
+	shrl	$4,%edx
+
+	pushl	%ebp
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	pushw	%ds
+
+	movw	%dx,%ds
+	shll	$4,%edx
+	movl	gfx_ofs_cmdline(%bx),%edi
+	subl	%edx,%edi
+	movw	gfx_ofs_cmdline_len(%bx),%cx
+	movw	gfx_ofs_timeout(%bx),%ax
+	imulw	$18,%ax
+
+	pushl	%ebp
+	lcall	*gfx_ofs_jmp_table + 4 * 2 (%bx)
+	popl	%ebp
+	movl	%eax,%ecx
+
+	popw	%ds
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	popl	%ebp
+
+	movl	12(%ebp),%edx
+	movl	%ebx,(%edx)
+
+	movl	%ecx,%eax
+
+	popl	%ebx
+	popl	%esi
+	popl	%edi
+
+	popl	%ebp
+	ret
+
+
+/*
+ * int gfx_setup_menu (gfx_data_t *gfx_data)
+ *
+ * draw boot menu
+ *
+ * return values:
+ *   always 0
+ */
+
+/* menu entry descriptor */
+#define menu_entries		0
+#define menu_default		2	/* seg:ofs */
+#define menu_ent_list		6	/* seg:ofs */
+#define menu_ent_size		10
+#define menu_arg_list		12	/* seg:ofs */
+#define menu_arg_size		16
+#define sizeof_menu_desc	18
+
+ENTRY(gfx_setup_menu)
+	pushl	%ebp
+	movl	%esp, %ebp
+	
+	pushl	%edi
+	pushl	%esi
+	pushl	%ebx
+
+	movl	8(%ebp),%edx
+	movl	%edx,%ebx
+	andl	$0xf,%ebx
+	shrl	$4,%edx
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	pushw	%ds
+
+	movw	%dx,%ds
+	shll	$4,%edx
+
+	subw	$sizeof_menu_desc,%sp
+	movw	%sp,%bp
+
+	movl	gfx_ofs_menu_entries(%bx),%eax
+	movw	%ax,menu_entries(%bp)
+
+	movl	gfx_ofs_menu_default_entry(%bx),%eax
+	subl	%edx,%eax
+	movw	%ax,menu_default(%bp)
+	movw	%ds,menu_default+2(%bp)
+
+	movl	gfx_ofs_menu_list(%bx),%eax
+	subl	%edx,%eax
+	movw	%ax,menu_ent_list(%bp)
+	movw	%ds,menu_ent_list+2(%bp)
+
+	movl	gfx_ofs_menu_entry_len(%bx),%eax
+	movw	%ax,menu_ent_size(%bp)
+
+	movl	gfx_ofs_args_list(%bx),%eax
+	subl	%edx,%eax
+	movw	%ax,menu_arg_list(%bp)
+	movw	%ds,menu_arg_list+2(%bp)
+
+	movl	gfx_ofs_args_entry_len(%bx),%eax
+	movw	%ax,menu_arg_size(%bp)
+
+	movw	%bp,%si
+	pushw	%ss
+	popw	%es
+	
+	lcall	%ds: *gfx_ofs_jmp_table + 4 * 3 (%bx)
+
+	addw	$sizeof_menu_desc,%sp
+
+	popw	%ds
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	xorl	%eax,%eax
+
+	popl	%ebx
+	popl	%esi
+	popl	%edi
+
+	popl	%ebp
+	ret
+
+
+/*
+ *
+ * end graphics stuff
+ *
+ * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+ */
+
+		
+/*
+ * gateA20(int linear)
+ *
+ * Gate address-line 20 for high memory.
+ *
+ * This routine is probably overconservative in what it does, but so what?
+ *
+ * It also eats any keystrokes in the keyboard buffer.  :-(
+ */
+
+ENTRY(gateA20)
+	/* first, try a BIOS call */
+	pushl	%ebp
+	movl	8(%esp), %edx
+	
+	call	EXT_C(prot_to_real)
+	
+	.code16
+	movw	$0x2400, %ax
+	testw	%dx, %dx
+	jz	1f
+	incw	%ax
+1:	stc
+	int	$0x15
+	jnc	2f
+
+	/* set non-zero if failed */
+	movb	$1, %ah
+
+	/* save the status */
+2:	movb	%ah, %dl
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	popl	%ebp
+	testb	%dl, %dl
+	jnz	3f
+	ret
+
+3:	/* use keyboard controller */
+	pushl	%eax
+
+	call    gloop1
+
+	movb	$KC_CMD_WOUT, %al
+	outb	$K_CMD
+
+gloopint1:
+	inb	$K_STATUS
+	andb	$K_IBUF_FUL, %al
+	jnz	gloopint1
+
+	movb	$KB_OUTPUT_MASK, %al
+	cmpb	$0, 0x8(%esp)
+	jz	gdoit
+
+	orb	$KB_A20_ENABLE, %al
+gdoit:
+	outb	$K_RDWR
+
+	call	gloop1
+
+	/* output a dummy command (USB keyboard hack) */
+	movb	$0xff, %al
+	outb	$K_CMD
+	call	gloop1
+	
+	popl	%eax
+	ret
+
+gloop1:
+	inb	$K_STATUS
+	andb	$K_IBUF_FUL, %al
+	jnz	gloop1
+
+gloop2:
+	inb	$K_STATUS
+	andb	$K_OBUF_FUL, %al
+	jz	gloop2ret
+	inb	$K_RDWR
+	jmp	gloop2
+
+gloop2ret:
+	ret
+
+
+ENTRY(patch_code)	/* labels start with "pc_" */
+	.code16
+
+	mov	%cs, %ax
+	mov	%ax, %ds
+	mov	%ax, %es
+	mov	%ax, %fs
+	mov	%ax, %gs
+	ADDR32	movl	$0, 0
+pc_stop:
+	hlt
+	DATA32	jmp	pc_stop
+ENTRY(patch_code_end)
+
+	.code32
+
+
+/*
+ * linux_boot()
+ *
+ * Does some funky things (including on the stack!), then jumps to the
+ * entry point of the Linux setup code.
+ */
+
+VARIABLE(linux_text_len)
+	.long	0
+	
+VARIABLE(linux_data_tmp_addr)
+	.long	0
+	
+VARIABLE(linux_data_real_addr)
+	.long	0
+	
+ENTRY(linux_boot)
+	/* don't worry about saving anything, we're committed at this point */
+	cld	/* forward copying */
+
+	/* copy kernel */
+	movl	EXT_C(linux_text_len), %ecx
+	addl	$3, %ecx
+	shrl	$2, %ecx
+	movl	$LINUX_BZIMAGE_ADDR, %esi
+	movl	$LINUX_ZIMAGE_ADDR, %edi
+
+	rep
+	movsl
+
+ENTRY(big_linux_boot)
+	movl	EXT_C(linux_data_real_addr), %ebx
+	
+	/* copy the real mode part */
+	movl	EXT_C(linux_data_tmp_addr), %esi
+	movl	%ebx, %edi
+	movl	$LINUX_SETUP_MOVE_SIZE, %ecx
+	cld
+	rep
+	movsb
+
+	/* change %ebx to the segment address */
+	shrl	$4, %ebx
+	movl	%ebx, %eax
+	addl	$0x20, %eax
+	movl	%eax, linux_setup_seg
+			
+	/* XXX new stack pointer in safe area for calling functions */
+	movl	$0x4000, %esp
+	call	EXT_C(stop_floppy)
+
+	/* final setup for linux boot */
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	/* final setup for linux boot */
+	cli
+	movw	%bx, %ss
+	movw	$LINUX_SETUP_STACK, %sp
+	
+	movw	%bx, %ds
+	movw	%bx, %es
+	movw	%bx, %fs
+	movw	%bx, %gs
+
+	/* jump to start */
+	/* ljmp */
+	.byte	0xea
+	.word	0
+linux_setup_seg:	
+	.word	0
+	.code32
+
+
+/*
+ * multi_boot(int start, int mb_info)
+ *
+ *  This starts a kernel in the manner expected of the multiboot standard.
+ */
+
+ENTRY(multi_boot)
+	/* no need to save anything */
+	call	EXT_C(stop_floppy)
+
+	movl	$0x2BADB002, %eax
+	movl	0x8(%esp), %ebx
+
+	/* boot kernel here (absolute address call) */
+	call	*0x4(%esp)
+
+	/* error */
+	call	EXT_C(stop)
+
+#endif /* ! STAGE1_5 */
+	
+/*
+ * void console_putchar (int c)
+ *
+ * Put the character C on the console. Because GRUB wants to write a
+ * character with an attribute, this implementation is a bit tricky.
+ * If C is a control character (CR, LF, BEL, BS), use INT 10, AH = 0Eh
+ * (TELETYPE OUTPUT). Otherwise, save the original position, put a space,
+ * save the current position, restore the original position, write the
+ * character and the attribute, and restore the current position.
+ *
+ * The reason why this is so complicated is that there is no easy way to
+ * get the height of the screen, and the TELETYPE OUPUT BIOS call doesn't
+ * support setting a background attribute.
+ */
+ENTRY(console_putchar)
+	movl	0x4(%esp), %edx
+	pusha
+#ifdef STAGE1_5
+	movb	$0x07, %bl
+#else
+	movl	EXT_C(console_current_color), %ebx
+#endif
+	
+	call	EXT_C(prot_to_real)
+	.code16
+	movb	%dl, %al
+	xorb	%bh, %bh
+
+#ifndef STAGE1_5
+	/* use teletype output if control character */
+	cmpb	$0x7, %al
+	je	1f
+	cmpb	$0x8, %al
+	je	1f
+	cmpb	$0xa, %al
+	je	1f
+	cmpb	$0xd, %al
+	je	1f
+
+	/* save the character and the attribute on the stack */
+	pushw	%ax
+	pushw	%bx
+	
+	/* get the current position */
+	movb	$0x3, %ah
+	int	$0x10
+
+	/* check the column with the width */
+	cmpb	$79, %dl
+	jl	2f
+	
+	/* print CR and LF, if next write will exceed the width */	
+	movw	$0x0e0d, %ax
+	int	$0x10
+	movb	$0x0a, %al
+	int	$0x10
+	
+	/* get the current position */
+	movb	$0x3, %ah
+	int	$0x10
+
+2:	
+	/* restore the character and the attribute */
+	popw	%bx
+	popw	%ax
+	
+	/* write the character with the attribute */
+	movb	$0x9, %ah
+	movw	$1, %cx
+	int	$0x10
+
+	/* move the cursor forward */
+	incb	%dl
+	movb	$0x2, %ah
+	int	$0x10
+
+	jmp	3f
+#endif /* ! STAGE1_5 */
+	
+1:	movb	$0xe, %ah
+	int	$0x10
+	
+3:	DATA32	call	EXT_C(real_to_prot)
+	.code32
+	
+	popa
+	ret
+
+
+#ifndef STAGE1_5
+
+/* this table is used in translate_keycode below */
+translation_table:
+	.word	KEY_LEFT, 2
+	.word	KEY_RIGHT, 6
+	.word	KEY_UP, 16
+	.word	KEY_DOWN, 14
+	.word	KEY_HOME, 1
+	.word	KEY_END, 5
+	.word	KEY_DC, 4
+	.word	KEY_BACKSPACE, 8
+	.word	KEY_PPAGE, 7
+	.word	KEY_NPAGE, 3
+	.word	0
+	
+/*
+ * translate_keycode translates the key code %dx to an ascii code.
+ */
+	.code16
+
+translate_keycode:
+	pushw	%bx
+	pushw	%si
+	
+	movw	$ABS(translation_table), %si
+	
+1:	lodsw
+	/* check if this is the end */
+	testw	%ax, %ax
+	jz	2f
+	/* load the ascii code into %ax */
+	movw	%ax, %bx
+	lodsw
+	/* check if this matches the key code */
+	cmpw	%bx, %dx
+	jne	1b
+	/* translate %dx, if successful */
+	movw	%ax, %dx
+
+2:	popw	%si
+	popw	%bx
+	ret
+
+	.code32
+	
+
+/*
+ * remap_ascii_char remaps the ascii code %dl to another if the code is
+ * contained in ASCII_KEY_MAP.
+ */
+	.code16
+	
+remap_ascii_char:
+	pushw	%si
+	
+	movw	$ABS(EXT_C(ascii_key_map)), %si
+1:
+	lodsw
+	/* check if this is the end */
+	testw	%ax, %ax
+	jz	2f
+	/* check if this matches the ascii code */
+	cmpb	%al, %dl
+	jne	1b
+	/* if so, perform the mapping */
+	movb	%ah, %dl
+2:
+	/* restore %si */
+	popw	%si
+
+	ret
+
+	.code32
+
+	.align	4
+ENTRY(ascii_key_map)
+	.space	(KEY_MAP_SIZE + 1) * 2
+	
+
+/*
+ * int console_getkey (void)
+ * BIOS call "INT 16H Function 00H" to read character from keyboard
+ *	Call with	%ah = 0x0
+ *	Return:		%ah = keyboard scan code
+ *			%al = ASCII character
+ */
+
+ENTRY(console_getkey)
+	push	%ebp
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	int	$0x16
+
+	movw	%ax, %dx		/* real_to_prot uses %eax */
+	call	translate_keycode
+	call	remap_ascii_char
+	
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	movw	%dx, %ax
+
+	pop	%ebp
+	ret
+
+
+/*
+ * int console_checkkey (void)
+ *	if there is a character pending, return it; otherwise return -1
+ * BIOS call "INT 16H Function 01H" to check whether a character is pending
+ *	Call with	%ah = 0x1
+ *	Return:
+ *		If key waiting to be input:
+ *			%ah = keyboard scan code
+ *			%al = ASCII character
+ *			Zero flag = clear
+ *		else
+ *			Zero flag = set
+ */
+ENTRY(console_checkkey)
+	push	%ebp
+	xorl	%edx, %edx
+	
+	call	EXT_C(prot_to_real)	/* enter real mode */
+	.code16
+
+	movb	$0x1, %ah
+	int	$0x16
+
+	DATA32	jz	notpending
+	
+	movw	%ax, %dx
+	call	translate_keycode
+	call	remap_ascii_char
+	DATA32	jmp	pending
+
+notpending:
+	movl	$0xFFFFFFFF, %edx
+
+pending:
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	mov	%edx, %eax
+
+	pop	%ebp
+	ret
+
+	
+/*
+ * int console_getxy (void)
+ * BIOS call "INT 10H Function 03h" to get cursor position
+ *	Call with	%ah = 0x03
+ *			%bh = page
+ *      Returns         %ch = starting scan line
+ *                      %cl = ending scan line
+ *                      %dh = row (0 is top)
+ *                      %dl = column (0 is left)
+ */
+
+
+ENTRY(console_getxy)
+	push	%ebp
+	push	%ebx                    /* save EBX */
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+        xorb	%bh, %bh                /* set page to 0 */
+	movb	$0x3, %ah
+	int	$0x10			/* get cursor position */
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	movb	%dl, %ah
+	movb	%dh, %al
+
+	pop	%ebx
+	pop	%ebp
+	ret
+
+
+/*
+ * void console_gotoxy(int x, int y)
+ * BIOS call "INT 10H Function 02h" to set cursor position
+ *	Call with	%ah = 0x02
+ *			%bh = page
+ *                      %dh = row (0 is top)
+ *                      %dl = column (0 is left)
+ */
+
+
+ENTRY(console_gotoxy)
+	push	%ebp
+	push	%ebx                    /* save EBX */
+
+	movb	0xc(%esp), %dl           /* %dl = x */
+	movb	0x10(%esp), %dh          /* %dh = y */
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+        xorb	%bh, %bh                /* set page to 0 */
+	movb	$0x2, %ah
+	int	$0x10			/* set cursor position */
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	pop	%ebx
+	pop	%ebp
+	ret
+
+	
+/*
+ * void console_cls (void)
+ * BIOS call "INT 10H Function 09h" to write character and attribute
+ *	Call with	%ah = 0x09
+ *                      %al = (character)
+ *                      %bh = (page number)
+ *                      %bl = (attribute)
+ *                      %cx = (number of times)
+ */
+
+
+ENTRY(console_cls)
+	push	%ebp
+	push	%ebx                    /* save EBX */
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	/* move the cursor to the beginning */
+	movb	$0x02, %ah
+	xorb	%bh, %bh
+	xorw	%dx, %dx
+	int	$0x10
+
+	/* write spaces to the entire screen */
+	movw	$0x0920, %ax
+	movw	$0x07, %bx
+	movw	$(80 * 25), %cx
+        int	$0x10
+
+	/* move back the cursor */
+	movb	$0x02, %ah
+	int	$0x10
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	pop	%ebx
+	pop	%ebp
+	ret
+
+	
+/*
+ * int console_setcursor (int on)
+ * BIOS call "INT 10H Function 01h" to set cursor type
+ *      Call with       %ah = 0x01
+ *                      %ch = cursor starting scanline
+ *                      %cl = cursor ending scanline
+ */
+
+console_cursor_state:
+	.byte	1
+console_cursor_shape:
+	.word	0
+	
+ENTRY(console_setcursor)
+	push	%ebp
+	push	%ebx
+
+	/* check if the standard cursor shape has already been saved */
+	movw	console_cursor_shape, %ax
+	testw	%ax, %ax
+	jne	1f
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	movb	$0x03, %ah
+	xorb	%bh, %bh
+	int	$0x10
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	movw	%cx, console_cursor_shape
+1:
+	/* set %cx to the designated cursor shape */
+	movw	$0x2000, %cx
+	movl	0xc(%esp), %ebx
+	testl	%ebx, %ebx
+	jz	2f
+	movw	console_cursor_shape, %cx
+2:	
+	call	EXT_C(prot_to_real)
+	.code16
+
+	movb    $0x1, %ah
+	int     $0x10 
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	movzbl	console_cursor_state, %eax
+	movb	%bl, console_cursor_state
+	
+	pop	%ebx
+	pop	%ebp
+	ret
+		
+/*
+ * getrtsecs()
+ *	if a seconds value can be read, read it and return it (BCD),
+ *      otherwise return 0xFF
+ * BIOS call "INT 1AH Function 02H" to check whether a character is pending
+ *	Call with	%ah = 0x2
+ *	Return:
+ *		If RT Clock can give correct values
+ *			%ch = hour (BCD)
+ *			%cl = minutes (BCD)
+ *                      %dh = seconds (BCD)
+ *                      %dl = daylight savings time (00h std, 01h daylight)
+ *			Carry flag = clear
+ *		else
+ *			Carry flag = set
+ *                         (this indicates that the clock is updating, or
+ *                          that it isn't running)
+ */
+ENTRY(getrtsecs)
+	push	%ebp
+
+	call	EXT_C(prot_to_real)	/* enter real mode */
+	.code16
+
+	movb	$0x2, %ah
+	int	$0x1a
+
+	DATA32	jnc	gottime
+	movb	$0xff, %dh
+
+gottime:
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	movb	%dh, %al
+
+	pop	%ebp
+	ret
+
+	
+/*
+ * currticks()
+ *	return the real time in ticks, of which there are about
+ *	18-20 per second
+ */
+ENTRY(currticks)
+	pushl	%ebp
+
+	call	EXT_C(prot_to_real)	/* enter real mode */
+	.code16
+
+	/* %ax is already zero */
+        int	$0x1a
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	movl	%ecx, %eax
+	shll	$16, %eax
+	movw	%dx, %ax
+
+	popl	%ebp
+	ret
+
+#endif /* STAGE1_5 */
+
+/*
+ *  This is the area for all of the special variables.
+ */
+
+	.p2align	2	/* force 4-byte alignment */
+
+protstack:
+	.long	PROTSTACKINIT
+
+VARIABLE(boot_drive)
+#ifdef SUPPORT_DISKLESS
+	.long	NETWORK_DRIVE
+#else
+	.long	0
+#endif
+
+VARIABLE(install_second_sector)
+	.long	0
+	
+	/* an address can only be long-jumped to if it is in memory, this
+	   is used by multiple routines */
+offset:
+	.long	0x8000
+segment:
+	.word	0
+
+VARIABLE(apm_bios_info)
+	.word	0	/* version */
+	.word	0	/* cseg */
+	.long	0	/* offset */
+	.word	0	/* cseg_16 */
+	.word	0	/* dseg_16 */
+	.word	0	/* cseg_len */
+	.word	0	/* cseg_16_len */
+	.word	0	/* dseg_16_len */
+	
+/*
+ * This is the Global Descriptor Table
+ *
+ *  An entry, a "Segment Descriptor", looks like this:
+ *
+ * 31          24         19   16                 7           0
+ * ------------------------------------------------------------
+ * |             | |B| |A|       | |   |1|0|E|W|A|            |
+ * | BASE 31..24 |G|/|0|V| LIMIT |P|DPL|  TYPE   | BASE 23:16 |
+ * |             | |D| |L| 19..16| |   |1|1|C|R|A|            |
+ * ------------------------------------------------------------
+ * |                             |                            |
+ * |        BASE 15..0           |       LIMIT 15..0          |
+ * |                             |                            |
+ * ------------------------------------------------------------
+ *
+ *  Note the ordering of the data items is reversed from the above
+ *  description.
+ */
+
+	.p2align	2	/* force 4-byte alignment */
+gdt:
+	.word	0, 0
+	.byte	0, 0, 0, 0
+
+	/* code segment */
+	.word	0xFFFF, 0
+	.byte	0, 0x9A, 0xCF, 0
+
+	/* data segment */
+	.word	0xFFFF, 0
+	.byte	0, 0x92, 0xCF, 0
+
+	/* 16 bit real mode CS */
+	.word	0xFFFF, 0
+	.byte	0, 0x9E, 0, 0
+
+	/* 16 bit real mode DS */
+	.word	0xFFFF, 0
+	.byte	0, 0x92, 0, 0
+
+
+/* this is the GDT descriptor */
+gdtdesc:
+	.word	0x27			/* limit */
+	.long	gdt			/* addr */
diff -Naur grub-0.97/stage2/boot.c grub-0.97-suse/stage2/boot.c
--- grub-0.97/stage2/boot.c	2004-03-30 08:44:08.000000000 -0300
+++ grub-0.97-suse/stage2/boot.c	2006-09-09 17:00:12.000000000 -0300
@@ -824,8 +824,11 @@
     moveto = (mbi.mem_upper + 0x400) << 10;
   
   moveto = (moveto - len) & 0xfffff000;
-  max_addr = (lh->header == LINUX_MAGIC_SIGNATURE && lh->version >= 0x0203
-	      ? lh->initrd_addr_max : LINUX_INITRD_MAX_ADDRESS);
+  max_addr = LINUX_INITRD_MAX_ADDRESS;
+  if (lh->header == LINUX_MAGIC_SIGNATURE &&
+      lh->version >= 0x0203 &&
+      lh->initrd_addr_max < max_addr)
+    max_addr = lh->initrd_addr_max;
   if (moveto + len >= max_addr)
     moveto = (max_addr - len) & 0xfffff000;
   
diff -Naur grub-0.97/stage2/builtins.c grub-0.97-suse/stage2/builtins.c
--- grub-0.97/stage2/builtins.c	2005-02-15 19:58:23.000000000 -0200
+++ grub-0.97-suse/stage2/builtins.c	2006-09-09 17:00:12.000000000 -0300
@@ -63,6 +63,8 @@
 int fallback_entries[MAX_FALLBACK_ENTRIES];
 /* The number of current entry.  */
 int current_entryno;
+/* graphics file */
+char graphics_file[64];
 /* The address for Multiboot command-line buffer.  */
 static char *mb_cmdline;
 /* The password.  */
@@ -766,11 +768,11 @@
 default_func (char *arg, int flags)
 {
 #ifndef SUPPORT_DISKLESS
-  if (grub_strcmp (arg, "saved") == 0)
+  if (grub_strcmp (arg, "saved") == 0 || (saved_entryno & 0x4000))
     {
-      default_entry = saved_entryno;
-      return 0;
+      default_entry = saved_entryno & 0x3fff;
     }
+  else
 #endif /* SUPPORT_DISKLESS */
   
   if (! safe_parse_maxint (&arg, &default_entry))
@@ -791,6 +793,22 @@
 #endif
 };
 
+#ifndef SUPPORT_DISKLESS
+static int savedefault_func (char *arg, int flags);
+void __savedefault_once_reset()
+{
+  if (saved_entryno & 0x4000)
+    {
+      int saved_current_entryno = current_entryno;
+      grub_timeout = 0;
+      current_entryno = default_entry;
+      savedefault_func("\0", BUILTIN_SCRIPT);
+      current_entryno = saved_current_entryno;
+      saved_entryno &= 0x3fff;
+    }
+}
+#endif /* SUPPORT_DISKLESS */
+
 
 #ifdef GRUB_UTIL
 /* device */
@@ -1331,6 +1349,26 @@
 };
 
 
+/* graphics */
+static int
+gfxmenu_func (char *arg, int flags)
+{
+  memmove(graphics_file, arg, sizeof graphics_file - 1);
+  graphics_file[sizeof graphics_file - 1] = 0;
+
+  return 0;
+}
+
+static struct builtin builtin_gfxmenu =
+{
+  "gfxmenu",
+  gfxmenu_func,
+  BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "gfxmenu FILE",
+  "Use the graphical menu from FILE."
+};
+
+
 /* geometry */
 static int
 geometry_func (char *arg, int flags)
@@ -1834,7 +1872,12 @@
   /* First, check the GNU-style long option.  */
   while (1)
     {
-      if (grub_memcmp ("--force-lba", arg, sizeof ("--force-lba") - 1) == 0)
+      if (grub_memcmp ("--force-lba=off", arg, sizeof ("--force-lba=off") - 1) == 0)
+	{
+	  is_force_lba = 0xff;
+	  arg = skip_to (0, arg);
+	}
+      else if (grub_memcmp ("--force-lba", arg, sizeof ("--force-lba") - 1) == 0)
 	{
 	  is_force_lba = 1;
 	  arg = skip_to (0, arg);
@@ -1842,9 +1885,23 @@
 #ifdef GRUB_UTIL
       else if (grub_memcmp ("--stage2=", arg, sizeof ("--stage2=") - 1) == 0)
 	{
+	  int fd;
 	  stage2_os_file = arg + sizeof ("--stage2=") - 1;
 	  arg = skip_to (0, arg);
 	  nul_terminate (stage2_os_file);
+
+#if defined(__linux__) && defined (FSYS_REISERFS)
+	  if ((fd=open(stage2_os_file, O_RDONLY)) >= 0)
+	    {
+	      struct statfs buf;
+	      /* see if the file sits on a reiserfs,
+		 and try do defragment it if so. */
+	      fstatfs(fd, &buf);
+	      if (buf.f_type == REISERFS_SUPER_MAGIC)
+		ioctl (fd, REISERFS_IOC_UNPACK, 1);
+	    }
+#endif	/* __linux__ && FSYS_REISERFS */
+
 	}
 #endif /* GRUB_UTIL */
       else
@@ -2263,7 +2320,7 @@
   "install",
   install_func,
   BUILTIN_CMDLINE,
-  "install [--stage2=STAGE2_FILE] [--force-lba] STAGE1 [d] DEVICE STAGE2 [ADDR] [p] [CONFIG_FILE] [REAL_CONFIG_FILE]",
+  "install [--stage2=STAGE2_FILE] [--force-lba[=off]] STAGE1 [d] DEVICE STAGE2 [ADDR] [p] [CONFIG_FILE] [REAL_CONFIG_FILE]",
   "Install STAGE1 on DEVICE, and install a blocklist for loading STAGE2"
   " as a Stage 2. If the option `d' is present, the Stage 1 will always"
   " look for the disk where STAGE2 was installed, rather than using"
@@ -2276,8 +2333,9 @@
   " 1.5 and REAL_CONFIG_FILE is present, then the Stage 2 CONFIG_FILE is"
   " patched with the configuration filename REAL_CONFIG_FILE."
   " If the option `--force-lba' is specified, disable some sanity checks"
-  " for LBA mode. If the option `--stage2' is specified, rewrite the Stage"
-  " 2 via your OS's filesystem instead of the raw device."
+  " for LBA mode, `--force-lba=off' will disable it completely. If the"
+  " option `--stage2' is specified, rewrite the Stage 2 via your OS's"
+  " filesystem instead of the raw device."
 };
 
 
@@ -3890,7 +3948,12 @@
   /* Check if the user specifies --force-lba.  */
   while (1)
     {
-      if (grub_memcmp ("--force-lba", arg, sizeof ("--force-lba") - 1) == 0)
+      if (grub_memcmp ("--force-lba=off", arg, sizeof ("--force-lba=off") - 1) == 0)
+	{
+	  is_force_lba = 0xff;
+	  arg = skip_to (0, arg);
+	}
+      else if (grub_memcmp ("--force-lba", arg, sizeof ("--force-lba") - 1) == 0)
 	{
 	  is_force_lba = 1;
 	  arg = skip_to (0, arg);
@@ -4011,6 +4074,9 @@
 	}
   }
 
+  /* force buffer cache invalidation after embedding */
+  buf_drive = -1;
+
   /* Construct a string that is used by the command "install" as its
      arguments.  */
   sprint_device (installed_drive, installed_partition);
@@ -4018,7 +4084,9 @@
 #if 1
   /* Don't embed a drive number unnecessarily.  */
   grub_sprintf (cmd_arg, "%s%s%s%s %s%s %s p %s %s",
-		is_force_lba? "--force-lba " : "",
+		is_force_lba ?
+		 (is_force_lba == 0xff ? "--force-lba=off " : "--force-lba ")
+		 : "",
 		stage2_arg? stage2_arg : "",
 		stage2_arg? " " : "",
 		stage1,
@@ -4071,17 +4139,18 @@
   "setup",
   setup_func,
   BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  "setup [--prefix=DIR] [--stage2=STAGE2_FILE] [--force-lba] INSTALL_DEVICE [IMAGE_DEVICE]",
+  "setup [--prefix=DIR] [--stage2=STAGE2_FILE] [--force-lba[=off]] INSTALL_DEVICE [IMAGE_DEVICE]",
   "Set up the installation of GRUB automatically. This command uses"
   " the more flexible command \"install\" in the backend and installs"
   " GRUB into the device INSTALL_DEVICE. If IMAGE_DEVICE is specified,"
   " then find the GRUB images in the device IMAGE_DEVICE, otherwise"
   " use the current \"root device\", which can be set by the command"
   " \"root\". If you know that your BIOS should support LBA but GRUB"
-  " doesn't work in LBA mode, specify the option `--force-lba'."
-  " If you install GRUB under the grub shell and you cannot unmount the"
-  " partition where GRUB images reside, specify the option `--stage2'"
-  " to tell GRUB the file name under your OS."
+  " doesn't work in LBA mode, specify the option `--force-lba'. If the"
+  " BIOS claims to support LBA mode but really doesn't, use"
+  " `--force-lba=off'. If you install GRUB under the grub shell and"
+  " you cannot unmount the partition where GRUB images reside, specify"
+  " the option `--stage2' to tell GRUB the file name under your OS."
 };
 
 
@@ -4823,6 +4892,7 @@
   &builtin_find,
   &builtin_fstest,
   &builtin_geometry,
+  &builtin_gfxmenu,
   &builtin_halt,
   &builtin_help,
   &builtin_hiddenmenu,
diff -Naur grub-0.97/stage2/builtins.c~ grub-0.97-suse/stage2/builtins.c~
--- grub-0.97/stage2/builtins.c~	1969-12-31 21:00:00.000000000 -0300
+++ grub-0.97-suse/stage2/builtins.c~	2006-09-09 17:00:12.000000000 -0300
@@ -0,0 +1,4940 @@
+/* builtins.c - the GRUB builtin commands */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 1999,2000,2001,2002,2003,2004  Free Software Foundation, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* Include stdio.h before shared.h, because we can't define
+   WITHOUT_LIBC_STUBS here.  */
+#ifdef GRUB_UTIL
+# include <stdio.h>
+#endif
+
+#include <shared.h>
+#include <filesys.h>
+#include <term.h>
+
+#ifdef SUPPORT_NETBOOT
+# define GRUB	1
+# include <etherboot.h>
+#endif
+
+#ifdef SUPPORT_SERIAL
+# include <serial.h>
+# include <terminfo.h>
+#endif
+
+#ifdef GRUB_UTIL
+# include <device.h>
+#else /* ! GRUB_UTIL */
+# include <apic.h>
+# include <smp-imps.h>
+#endif /* ! GRUB_UTIL */
+
+#ifdef USE_MD5_PASSWORDS
+# include <md5.h>
+#endif
+
+/* The type of kernel loaded.  */
+kernel_t kernel_type;
+/* The boot device.  */
+static int bootdev;
+/* True when the debug mode is turned on, and false
+   when it is turned off.  */
+int debug = 0;
+/* The default entry.  */
+int default_entry = 0;
+/* The fallback entry.  */
+int fallback_entryno;
+int fallback_entries[MAX_FALLBACK_ENTRIES];
+/* The number of current entry.  */
+int current_entryno;
+/* graphics file */
+char graphics_file[64];
+/* The address for Multiboot command-line buffer.  */
+static char *mb_cmdline;
+/* The password.  */
+char *password;
+/* The password type.  */
+password_t password_type;
+/* The flag for indicating that the user is authoritative.  */
+int auth = 0;
+/* The timeout.  */
+int grub_timeout = -1;
+/* Whether to show the menu or not.  */
+int show_menu = 1;
+/* The BIOS drive map.  */
+static unsigned short bios_drive_map[DRIVE_MAP_SIZE + 1];
+
+/* Prototypes for allowing straightfoward calling of builtins functions
+   inside other functions.  */
+static int configfile_func (char *arg, int flags);
+
+/* Initialize the data for builtins.  */
+void
+init_builtins (void)
+{
+  kernel_type = KERNEL_TYPE_NONE;
+  /* BSD and chainloading evil hacks!  */
+  bootdev = set_bootdev (0);
+  mb_cmdline = (char *) MB_CMDLINE_BUF;
+}
+
+/* Initialize the data for the configuration file.  */
+void
+init_config (void)
+{
+  default_entry = 0;
+  password = 0;
+  fallback_entryno = -1;
+  fallback_entries[0] = -1;
+  grub_timeout = -1;
+}
+
+/* Check a password for correctness.  Returns 0 if password was
+   correct, and a value != 0 for error, similarly to strcmp. */
+int
+check_password (char *entered, char* expected, password_t type)
+{
+  switch (type)
+    {
+    case PASSWORD_PLAIN:
+      return strcmp (entered, expected);
+
+#ifdef USE_MD5_PASSWORDS
+    case PASSWORD_MD5:
+      return check_md5_password (entered, expected);
+#endif
+    default: 
+      /* unsupported password type: be secure */
+      return 1;
+    }
+}
+
+/* Print which sector is read when loading a file.  */
+static void
+disk_read_print_func (int sector, int offset, int length)
+{
+  grub_printf ("[%d,%d,%d]", sector, offset, length);
+}
+
+
+/* blocklist */
+static int
+blocklist_func (char *arg, int flags)
+{
+  char *dummy = (char *) RAW_ADDR (0x100000);
+  int start_sector;
+  int num_sectors = 0;
+  int num_entries = 0;
+  int last_length = 0;
+
+  auto void disk_read_blocklist_func (int sector, int offset, int length);
+  
+  /* Collect contiguous blocks into one entry as many as possible,
+     and print the blocklist notation on the screen.  */
+  auto void disk_read_blocklist_func (int sector, int offset, int length)
+    {
+      if (num_sectors > 0)
+	{
+	  if (start_sector + num_sectors == sector
+	      && offset == 0 && last_length == SECTOR_SIZE)
+	    {
+	      num_sectors++;
+	      last_length = length;
+	      return;
+	    }
+	  else
+	    {
+	      if (last_length == SECTOR_SIZE)
+		grub_printf ("%s%d+%d", num_entries ? "," : "",
+			     start_sector - part_start, num_sectors);
+	      else if (num_sectors > 1)
+		grub_printf ("%s%d+%d,%d[0-%d]", num_entries ? "," : "",
+			     start_sector - part_start, num_sectors-1,
+			     start_sector + num_sectors-1 - part_start, 
+			     last_length);
+	      else
+		grub_printf ("%s%d[0-%d]", num_entries ? "," : "",
+			     start_sector - part_start, last_length);
+	      num_entries++;
+	      num_sectors = 0;
+	    }
+	}
+
+      if (offset > 0)
+	{
+	  grub_printf("%s%d[%d-%d]", num_entries ? "," : "",
+		      sector-part_start, offset, offset+length);
+	  num_entries++;
+	}
+      else
+	{
+	  start_sector = sector;
+	  num_sectors = 1;
+	  last_length = length;
+	}
+    }
+
+  /* Open the file.  */
+  if (! grub_open (arg))
+    return 1;
+
+  /* Print the device name.  */
+  grub_printf ("(%cd%d",
+	       (current_drive & 0x80) ? 'h' : 'f',
+	       current_drive & ~0x80);
+  
+  if ((current_partition & 0xFF0000) != 0xFF0000)
+    grub_printf (",%d", (current_partition >> 16) & 0xFF);
+  
+  if ((current_partition & 0x00FF00) != 0x00FF00)
+    grub_printf (",%c", 'a' + ((current_partition >> 8) & 0xFF));
+  
+  grub_printf (")");
+
+  /* Read in the whole file to DUMMY.  */
+  disk_read_hook = disk_read_blocklist_func;
+  if (! grub_read (dummy, -1))
+    goto fail;
+
+  /* The last entry may not be printed yet.  Don't check if it is a
+   * full sector, since it doesn't matter if we read too much. */
+  if (num_sectors > 0)
+    grub_printf ("%s%d+%d", num_entries ? "," : "",
+		 start_sector - part_start, num_sectors);
+
+  grub_printf ("\n");
+  
+ fail:
+  disk_read_hook = 0;
+  grub_close ();
+  return errnum;
+}
+
+static struct builtin builtin_blocklist =
+{
+  "blocklist",
+  blocklist_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "blocklist FILE",
+  "Print the blocklist notation of the file FILE."
+};
+
+/* boot */
+static int
+boot_func (char *arg, int flags)
+{
+  /* Clear the int15 handler if we can boot the kernel successfully.
+     This assumes that the boot code never fails only if KERNEL_TYPE is
+     not KERNEL_TYPE_NONE. Is this assumption is bad?  */
+  if (kernel_type != KERNEL_TYPE_NONE)
+    unset_int15_handler ();
+
+#ifdef SUPPORT_NETBOOT
+  /* Shut down the networking.  */
+  cleanup_net ();
+#endif
+  
+  switch (kernel_type)
+    {
+    case KERNEL_TYPE_FREEBSD:
+    case KERNEL_TYPE_NETBSD:
+      /* *BSD */
+      bsd_boot (kernel_type, bootdev, (char *) mbi.cmdline);
+      break;
+
+    case KERNEL_TYPE_LINUX:
+      /* Linux */
+      linux_boot ();
+      break;
+
+    case KERNEL_TYPE_BIG_LINUX:
+      /* Big Linux */
+      big_linux_boot ();
+      break;
+
+    case KERNEL_TYPE_CHAINLOADER:
+      /* Chainloader */
+      
+      /* Check if we should set the int13 handler.  */
+      if (bios_drive_map[0] != 0)
+	{
+	  int i;
+	  
+	  /* Search for SAVED_DRIVE.  */
+	  for (i = 0; i < DRIVE_MAP_SIZE; i++)
+	    {
+	      if (! bios_drive_map[i])
+		break;
+	      else if ((bios_drive_map[i] & 0xFF) == saved_drive)
+		{
+		  /* Exchage SAVED_DRIVE with the mapped drive.  */
+		  saved_drive = (bios_drive_map[i] >> 8) & 0xFF;
+		  break;
+		}
+	    }
+	  
+	  /* Set the handler. This is somewhat dangerous.  */
+	  set_int13_handler (bios_drive_map);
+	}
+      
+      gateA20 (0);
+      boot_drive = saved_drive;
+      chain_stage1 (0, BOOTSEC_LOCATION, boot_part_addr);
+      break;
+
+    case KERNEL_TYPE_MULTIBOOT:
+      /* Multiboot */
+      multi_boot ((int) entry_addr, (int) &mbi);
+      break;
+
+    default:
+      errnum = ERR_BOOT_COMMAND;
+      return 1;
+    }
+
+  return 0;
+}
+
+static struct builtin builtin_boot =
+{
+  "boot",
+  boot_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "boot",
+  "Boot the OS/chain-loader which has been loaded."
+};
+
+
+#ifdef SUPPORT_NETBOOT
+/* bootp */
+static int
+bootp_func (char *arg, int flags)
+{
+  int with_configfile = 0;
+
+  if (grub_memcmp (arg, "--with-configfile", sizeof ("--with-configfile") - 1)
+      == 0)
+    {
+      with_configfile = 1;
+      arg = skip_to (0, arg);
+    }
+  
+  if (! bootp ())
+    {
+      if (errnum == ERR_NONE)
+	errnum = ERR_DEV_VALUES;
+
+      return 1;
+    }
+
+  /* Notify the configuration.  */
+  print_network_configuration ();
+
+  /* XXX: this can cause an endless loop, but there is no easy way to
+     detect such a loop unfortunately.  */
+  if (with_configfile)
+    configfile_func (config_file, flags);
+  
+  return 0;
+}
+
+static struct builtin builtin_bootp =
+{
+  "bootp",
+  bootp_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "bootp [--with-configfile]",
+  "Initialize a network device via BOOTP. If the option `--with-configfile'"
+  " is given, try to load a configuration file specified by the 150 vendor"
+  " tag."
+};
+#endif /* SUPPORT_NETBOOT */
+
+
+/* cat */
+static int
+cat_func (char *arg, int flags)
+{
+  char c;
+
+  if (! grub_open (arg))
+    return 1;
+
+  while (grub_read (&c, 1))
+    {
+      /* Because running "cat" with a binary file can confuse the terminal,
+	 print only some characters as they are.  */
+      if (grub_isspace (c) || (c >= ' ' && c <= '~'))
+	grub_putchar (c);
+      else
+	grub_putchar ('?');
+    }
+  
+  grub_close ();
+  return 0;
+}
+
+static struct builtin builtin_cat =
+{
+  "cat",
+  cat_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "cat FILE",
+  "Print the contents of the file FILE."
+};
+
+
+/* chainloader */
+static int
+chainloader_func (char *arg, int flags)
+{
+  int force = 0;
+  char *file = arg;
+
+  /* If the option `--force' is specified?  */
+  if (substring ("--force", arg) <= 0)
+    {
+      force = 1;
+      file = skip_to (0, arg);
+    }
+
+  /* Open the file.  */
+  if (! grub_open (file))
+    {
+      kernel_type = KERNEL_TYPE_NONE;
+      return 1;
+    }
+
+  /* Read the first block.  */
+  if (grub_read ((char *) BOOTSEC_LOCATION, SECTOR_SIZE) != SECTOR_SIZE)
+    {
+      grub_close ();
+      kernel_type = KERNEL_TYPE_NONE;
+
+      /* This below happens, if a file whose size is less than 512 bytes
+	 is loaded.  */
+      if (errnum == ERR_NONE)
+	errnum = ERR_EXEC_FORMAT;
+      
+      return 1;
+    }
+
+  /* If not loading it forcibly, check for the signature.  */
+  if (! force
+      && (*((unsigned short *) (BOOTSEC_LOCATION + BOOTSEC_SIG_OFFSET))
+	  != BOOTSEC_SIGNATURE))
+    {
+      grub_close ();
+      errnum = ERR_EXEC_FORMAT;
+      kernel_type = KERNEL_TYPE_NONE;
+      return 1;
+    }
+
+  grub_close ();
+  kernel_type = KERNEL_TYPE_CHAINLOADER;
+
+  /* XXX: Windows evil hack. For now, only the first five letters are
+     checked.  */
+  if (IS_PC_SLICE_TYPE_FAT (current_slice)
+      && ! grub_memcmp ((char *) BOOTSEC_LOCATION + BOOTSEC_BPB_SYSTEM_ID,
+			"MSWIN", 5))
+    *((unsigned long *) (BOOTSEC_LOCATION + BOOTSEC_BPB_HIDDEN_SECTORS))
+      = part_start;
+
+  errnum = ERR_NONE;
+  
+  return 0;
+}
+
+static struct builtin builtin_chainloader =
+{
+  "chainloader",
+  chainloader_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "chainloader [--force] FILE",
+  "Load the chain-loader FILE. If --force is specified, then load it"
+  " forcibly, whether the boot loader signature is present or not."
+};
+
+
+/* This function could be used to debug new filesystem code. Put a file
+   in the new filesystem and the same file in a well-tested filesystem.
+   Then, run "cmp" with the files. If no output is obtained, probably
+   the code is good, otherwise investigate what's wrong...  */
+/* cmp FILE1 FILE2 */
+static int
+cmp_func (char *arg, int flags)
+{
+  /* The filenames.  */
+  char *file1, *file2;
+  /* The addresses.  */
+  char *addr1, *addr2;
+  int i;
+  /* The size of the file.  */
+  int size;
+
+  /* Get the filenames from ARG.  */
+  file1 = arg;
+  file2 = skip_to (0, arg);
+  if (! *file1 || ! *file2)
+    {
+      errnum = ERR_BAD_ARGUMENT;
+      return 1;
+    }
+
+  /* Terminate the filenames for convenience.  */
+  nul_terminate (file1);
+  nul_terminate (file2);
+
+  /* Read the whole data from FILE1.  */
+  addr1 = (char *) RAW_ADDR (0x100000);
+  if (! grub_open (file1))
+    return 1;
+  
+  /* Get the size.  */
+  size = filemax;
+  if (grub_read (addr1, -1) != size)
+    {
+      grub_close ();
+      return 1;
+    }
+  
+  grub_close ();
+
+  /* Read the whole data from FILE2.  */
+  addr2 = addr1 + size;
+  if (! grub_open (file2))
+    return 1;
+
+  /* Check if the size of FILE2 is equal to the one of FILE2.  */
+  if (size != filemax)
+    {
+      grub_printf ("Differ in size: 0x%x [%s], 0x%x [%s]\n",
+		   size, file1, filemax, file2);
+      grub_close ();
+      return 0;
+    }
+  
+  if (! grub_read (addr2, -1))
+    {
+      grub_close ();
+      return 1;
+    }
+  
+  grub_close ();
+
+  /* Now compare ADDR1 with ADDR2.  */
+  for (i = 0; i < size; i++)
+    {
+      if (addr1[i] != addr2[i])
+	grub_printf ("Differ at the offset %d: 0x%x [%s], 0x%x [%s]\n",
+		     i, (unsigned) addr1[i], file1,
+		     (unsigned) addr2[i], file2);
+    }
+  
+  return 0;
+}
+
+static struct builtin builtin_cmp =
+{
+  "cmp",
+  cmp_func,
+  BUILTIN_CMDLINE,
+  "cmp FILE1 FILE2",
+  "Compare the file FILE1 with the FILE2 and inform the different values"
+  " if any."
+};
+
+
+/* color */
+/* Set new colors used for the menu interface. Support two methods to
+   specify a color name: a direct integer representation and a symbolic
+   color name. An example of the latter is "blink-light-gray/blue".  */
+static int
+color_func (char *arg, int flags)
+{
+  char *normal;
+  char *highlight;
+  int new_normal_color;
+  int new_highlight_color;
+  static char *color_list[16] =
+  {
+    "black",
+    "blue",
+    "green",
+    "cyan",
+    "red",
+    "magenta",
+    "brown",
+    "light-gray",
+    "dark-gray",
+    "light-blue",
+    "light-green",
+    "light-cyan",
+    "light-red",
+    "light-magenta",
+    "yellow",
+    "white"
+  };
+
+  auto int color_number (char *str);
+  
+  /* Convert the color name STR into the magical number.  */
+  auto int color_number (char *str)
+    {
+      char *ptr;
+      int i;
+      int color = 0;
+      
+      /* Find the separator.  */
+      for (ptr = str; *ptr && *ptr != '/'; ptr++)
+	;
+
+      /* If not found, return -1.  */
+      if (! *ptr)
+	return -1;
+
+      /* Terminate the string STR.  */
+      *ptr++ = 0;
+
+      /* If STR contains the prefix "blink-", then set the `blink' bit
+	 in COLOR.  */
+      if (substring ("blink-", str) <= 0)
+	{
+	  color = 0x80;
+	  str += 6;
+	}
+      
+      /* Search for the color name.  */
+      for (i = 0; i < 16; i++)
+	if (grub_strcmp (color_list[i], str) == 0)
+	  {
+	    color |= i;
+	    break;
+	  }
+
+      if (i == 16)
+	return -1;
+
+      str = ptr;
+      nul_terminate (str);
+
+      /* Search for the color name.  */      
+      for (i = 0; i < 8; i++)
+	if (grub_strcmp (color_list[i], str) == 0)
+	  {
+	    color |= i << 4;
+	    break;
+	  }
+
+      if (i == 8)
+	return -1;
+
+      return color;
+    }
+      
+  normal = arg;
+  highlight = skip_to (0, arg);
+
+  new_normal_color = color_number (normal);
+  if (new_normal_color < 0 && ! safe_parse_maxint (&normal, &new_normal_color))
+    return 1;
+  
+  /* The second argument is optional, so set highlight_color
+     to inverted NORMAL_COLOR.  */
+  if (! *highlight)
+    new_highlight_color = ((new_normal_color >> 4)
+			   | ((new_normal_color & 0xf) << 4));
+  else
+    {
+      new_highlight_color = color_number (highlight);
+      if (new_highlight_color < 0
+	  && ! safe_parse_maxint (&highlight, &new_highlight_color))
+	return 1;
+    }
+
+  if (current_term->setcolor)
+    current_term->setcolor (new_normal_color, new_highlight_color);
+  
+  return 0;
+}
+
+static struct builtin builtin_color =
+{
+  "color",
+  color_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "color NORMAL [HIGHLIGHT]",
+  "Change the menu colors. The color NORMAL is used for most"
+  " lines in the menu, and the color HIGHLIGHT is used to highlight the"
+  " line where the cursor points. If you omit HIGHLIGHT, then the"
+  " inverted color of NORMAL is used for the highlighted line."
+  " The format of a color is \"FG/BG\". FG and BG are symbolic color names."
+  " A symbolic color name must be one of these: black, blue, green,"
+  " cyan, red, magenta, brown, light-gray, dark-gray, light-blue,"
+  " light-green, light-cyan, light-red, light-magenta, yellow and white."
+  " But only the first eight names can be used for BG. You can prefix"
+  " \"blink-\" to FG if you want a blinking foreground color."
+};
+
+
+/* configfile */
+static int
+configfile_func (char *arg, int flags)
+{
+  char *new_config = config_file;
+
+  /* Check if the file ARG is present.  */
+  if (! grub_open (arg))
+    return 1;
+
+  grub_close ();
+  
+  /* Copy ARG to CONFIG_FILE.  */
+  while ((*new_config++ = *arg++) != 0)
+    ;
+
+#ifdef GRUB_UTIL
+  /* Force to load the configuration file.  */
+  use_config_file = 1;
+#endif
+
+  /* Make sure that the user will not be authoritative.  */
+  auth = 0;
+  
+  /* Restart cmain.  */
+  grub_longjmp (restart_env, 0);
+
+  /* Never reach here.  */
+  return 0;
+}
+
+static struct builtin builtin_configfile =
+{
+  "configfile",
+  configfile_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "configfile FILE",
+  "Load FILE as the configuration file."
+};
+
+
+/* debug */
+static int
+debug_func (char *arg, int flags)
+{
+  if (debug)
+    {
+      debug = 0;
+      grub_printf (" Debug mode is turned off\n");
+    }
+  else
+    {
+      debug = 1;
+      grub_printf (" Debug mode is turned on\n");
+    }
+
+  return 0;
+}
+
+static struct builtin builtin_debug =
+{
+  "debug",
+  debug_func,
+  BUILTIN_CMDLINE,
+  "debug",
+  "Turn on/off the debug mode."
+};
+
+
+/* default */
+static int
+default_func (char *arg, int flags)
+{
+#ifndef SUPPORT_DISKLESS
+  if (grub_strcmp (arg, "saved") == 0 || (saved_entryno & 0x4000))
+    {
+      default_entry = saved_entryno & 0x3fff;
+    }
+  else
+#endif /* SUPPORT_DISKLESS */
+  
+  if (! safe_parse_maxint (&arg, &default_entry))
+    return 1;
+
+  return 0;
+}
+
+static struct builtin builtin_default =
+{
+  "default",
+  default_func,
+  BUILTIN_MENU,
+#if 0
+  "default [NUM | `saved']",
+  "Set the default entry to entry number NUM (if not specified, it is"
+  " 0, the first entry) or the entry number saved by savedefault."
+#endif
+};
+
+#ifndef SUPPORT_DISKLESS
+static int savedefault_func (char *arg, int flags);
+void __savedefault_once_reset()
+{
+  if (saved_entryno & 0x4000)
+    {
+      int saved_current_entryno = current_entryno;
+      grub_timeout = 0;
+      current_entryno = default_entry;
+      savedefault_func("\0", BUILTIN_SCRIPT);
+      current_entryno = saved_current_entryno;
+      saved_entryno &= 0x3fff;
+    }
+}
+#endif /* SUPPORT_DISKLESS */
+
+
+#ifdef GRUB_UTIL
+/* device */
+static int
+device_func (char *arg, int flags)
+{
+  char *drive = arg;
+  char *device;
+
+  /* Get the drive number from DRIVE.  */
+  if (! set_device (drive))
+    return 1;
+
+  /* Get the device argument.  */
+  device = skip_to (0, drive);
+  
+  /* Terminate DEVICE.  */
+  nul_terminate (device);
+
+  if (! *device || ! check_device (device))
+    {
+      errnum = ERR_FILE_NOT_FOUND;
+      return 1;
+    }
+
+  assign_device_name (current_drive, device);
+  
+  return 0;
+}
+
+static struct builtin builtin_device =
+{
+  "device",
+  device_func,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "device DRIVE DEVICE",
+  "Specify DEVICE as the actual drive for a BIOS drive DRIVE. This command"
+  " can be used only in the grub shell."
+};
+#endif /* GRUB_UTIL */
+
+
+#ifdef SUPPORT_NETBOOT
+/* dhcp */
+static int
+dhcp_func (char *arg, int flags)
+{
+  /* For now, this is an alias for bootp.  */
+  return bootp_func (arg, flags);
+}
+
+static struct builtin builtin_dhcp =
+{
+  "dhcp",
+  dhcp_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "dhcp",
+  "Initialize a network device via DHCP."
+};
+#endif /* SUPPORT_NETBOOT */
+
+
+/* displayapm */
+static int
+displayapm_func (char *arg, int flags)
+{
+  if (mbi.flags & MB_INFO_APM_TABLE)
+    {
+      grub_printf ("APM BIOS information:\n"
+		   " Version:          0x%x\n"
+		   " 32-bit CS:        0x%x\n"
+		   " Offset:           0x%x\n"
+		   " 16-bit CS:        0x%x\n"
+		   " 16-bit DS:        0x%x\n"
+		   " 32-bit CS length: 0x%x\n"
+		   " 16-bit CS length: 0x%x\n"
+		   " 16-bit DS length: 0x%x\n",
+		   (unsigned) apm_bios_info.version,
+		   (unsigned) apm_bios_info.cseg,
+		   apm_bios_info.offset,
+		   (unsigned) apm_bios_info.cseg_16,
+		   (unsigned) apm_bios_info.dseg_16,
+		   (unsigned) apm_bios_info.cseg_len,
+		   (unsigned) apm_bios_info.cseg_16_len,
+		   (unsigned) apm_bios_info.dseg_16_len);
+    }
+  else
+    {
+      grub_printf ("No APM BIOS found or probe failed\n");
+    }
+
+  return 0;
+}
+
+static struct builtin builtin_displayapm =
+{
+  "displayapm",
+  displayapm_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "displayapm",
+  "Display APM BIOS information."
+};
+
+
+/* displaymem */
+static int
+displaymem_func (char *arg, int flags)
+{
+  if (get_eisamemsize () != -1)
+    grub_printf (" EISA Memory BIOS Interface is present\n");
+  if (get_mmap_entry ((void *) SCRATCHADDR, 0) != 0
+      || *((int *) SCRATCHADDR) != 0)
+    grub_printf (" Address Map BIOS Interface is present\n");
+
+  grub_printf (" Lower memory: %uK, "
+	       "Upper memory (to first chipset hole): %uK\n",
+	       mbi.mem_lower, mbi.mem_upper);
+
+  if (mbi.flags & MB_INFO_MEM_MAP)
+    {
+      struct AddrRangeDesc *map = (struct AddrRangeDesc *) mbi.mmap_addr;
+      int end_addr = mbi.mmap_addr + mbi.mmap_length;
+
+      grub_printf (" [Address Range Descriptor entries "
+		   "immediately follow (values are 64-bit)]\n");
+      while (end_addr > (int) map)
+	{
+	  char *str;
+
+	  if (map->Type == MB_ARD_MEMORY)
+	    str = "Usable RAM";
+	  else
+	    str = "Reserved";
+	  grub_printf ("   %s:  Base Address:  0x%x X 4GB + 0x%x,\n"
+		       "      Length:   0x%x X 4GB + 0x%x bytes\n",
+		       str,
+		       (unsigned long) (map->BaseAddr >> 32),
+		       (unsigned long) (map->BaseAddr & 0xFFFFFFFF),
+		       (unsigned long) (map->Length >> 32),
+		       (unsigned long) (map->Length & 0xFFFFFFFF));
+
+	  map = ((struct AddrRangeDesc *) (((int) map) + 4 + map->size));
+	}
+    }
+
+  return 0;
+}
+
+static struct builtin builtin_displaymem =
+{
+  "displaymem",
+  displaymem_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "displaymem",
+  "Display what GRUB thinks the system address space map of the"
+  " machine is, including all regions of physical RAM installed."
+};
+
+
+/* dump FROM TO */
+#ifdef GRUB_UTIL
+static int
+dump_func (char *arg, int flags)
+{
+  char *from, *to;
+  FILE *fp;
+  char c;
+  
+  from = arg;
+  to = skip_to (0, arg);
+  if (! *from || ! *to)
+    {
+      errnum = ERR_BAD_ARGUMENT;
+      return 1;
+    }
+
+  nul_terminate (from);
+  nul_terminate (to);
+  
+  if (! grub_open (from))
+    return 1;
+
+  fp = fopen (to, "w");
+  if (! fp)
+    {
+      errnum = ERR_WRITE;
+      return 1;
+    }
+
+  while (grub_read (&c, 1))
+    if (fputc (c, fp) == EOF)
+      {
+	errnum = ERR_WRITE;
+	fclose (fp);
+	return 1;
+      }
+
+  if (fclose (fp) == EOF)
+    {
+      errnum = ERR_WRITE;
+      return 1;
+    }
+
+  grub_close ();
+  return 0;
+}
+
+static struct builtin builtin_dump =
+  {
+    "dump",
+    dump_func,
+    BUILTIN_CMDLINE,
+    "dump FROM TO",
+    "Dump the contents of the file FROM to the file TO. FROM must be"
+    " a GRUB file and TO must be an OS file."
+  };
+#endif /* GRUB_UTIL */
+
+
+static char embed_info[32];
+/* embed */
+/* Embed a Stage 1.5 in the first cylinder after MBR or in the
+   bootloader block in a FFS.  */
+static int
+embed_func (char *arg, int flags)
+{
+  char *stage1_5;
+  char *device;
+  char *stage1_5_buffer = (char *) RAW_ADDR (0x100000);
+  int len, size;
+  int sector;
+  
+  stage1_5 = arg;
+  device = skip_to (0, stage1_5);
+
+  /* Open a Stage 1.5.  */
+  if (! grub_open (stage1_5))
+    return 1;
+
+  /* Read the whole of the Stage 1.5.  */
+  len = grub_read (stage1_5_buffer, -1);
+  grub_close ();
+  
+  if (errnum)
+    return 1;
+  
+  size = (len + SECTOR_SIZE - 1) / SECTOR_SIZE;
+  
+  /* Get the device where the Stage 1.5 will be embedded.  */
+  set_device (device);
+  if (errnum)
+    return 1;
+
+  if (current_partition == 0xFFFFFF)
+    {
+      /* Embed it after the MBR.  */
+      
+      char mbr[SECTOR_SIZE];
+      char ezbios_check[2*SECTOR_SIZE];
+      int i;
+      
+      /* Open the partition.  */
+      if (! open_partition ())
+	return 1;
+
+      /* No floppy has MBR.  */
+      if (! (current_drive & 0x80))
+	{
+	  errnum = ERR_DEV_VALUES;
+	  return 1;
+	}
+      
+      /* Read the MBR of CURRENT_DRIVE.  */
+      if (! rawread (current_drive, PC_MBR_SECTOR, 0, SECTOR_SIZE, mbr))
+	return 1;
+      
+      /* Sanity check.  */
+      if (! PC_MBR_CHECK_SIG (mbr))
+	{
+	  errnum = ERR_BAD_PART_TABLE;
+	  return 1;
+	}
+
+      /* Check if the disk can store the Stage 1.5.  */
+      for (i = 0; i < 4; i++)
+	if (PC_SLICE_TYPE (mbr, i) && PC_SLICE_START (mbr, i) - 1 < size)
+	  {
+	    errnum = ERR_NO_DISK_SPACE;
+	    return 1;
+	  }
+      
+      /* Check for EZ-BIOS signature. It should be in the third
+       * sector, but due to remapping it can appear in the second, so
+       * load and check both.  
+       */
+      if (! rawread (current_drive, 1, 0, 2 * SECTOR_SIZE, ezbios_check))
+	return 1;
+
+      if (! memcmp (ezbios_check + 3, "AERMH", 5)
+	  || ! memcmp (ezbios_check + 512 + 3, "AERMH", 5))
+	{
+	  /* The space after the MBR is used by EZ-BIOS which we must 
+	   * not overwrite.
+	   */
+	  errnum = ERR_NO_DISK_SPACE;
+	  return 1;
+	}
+
+      sector = 1;
+    }
+  else
+    {
+      /* Embed it in the bootloader block in the filesystem.  */
+      int start_sector;
+      
+      /* Open the partition.  */
+      if (! open_device ())
+	return 1;
+
+      /* Check if the current slice supports embedding.  */
+      if (fsys_table[fsys_type].embed_func == 0
+	  || ! fsys_table[fsys_type].embed_func (&start_sector, size))
+	{
+	  errnum = ERR_DEV_VALUES;
+	  return 1;
+	}
+
+      sector = part_start + start_sector;
+    }
+
+  /* Clear the cache.  */
+  buf_track = -1;
+
+  /* Now perform the embedding.  */
+  if (! devwrite (sector - part_start, size, stage1_5_buffer))
+    return 1;
+  
+  grub_printf (" %d sectors are embedded.\n", size);
+  grub_sprintf (embed_info, "%d+%d", sector - part_start, size);
+  return 0;
+}
+
+static struct builtin builtin_embed =
+{
+  "embed",
+  embed_func,
+  BUILTIN_CMDLINE,
+  "embed STAGE1_5 DEVICE",
+  "Embed the Stage 1.5 STAGE1_5 in the sectors after MBR if DEVICE"
+  " is a drive, or in the \"bootloader\" area if DEVICE is a FFS partition."
+  " Print the number of sectors which STAGE1_5 occupies if successful."
+};
+
+
+/* fallback */
+static int
+fallback_func (char *arg, int flags)
+{
+  int i = 0;
+
+  while (*arg)
+    {
+      int entry;
+      int j;
+      
+      if (! safe_parse_maxint (&arg, &entry))
+	return 1;
+
+      /* Remove duplications to prevent infinite looping.  */
+      for (j = 0; j < i; j++)
+	if (entry == fallback_entries[j])
+	  break;
+      if (j != i)
+	continue;
+      
+      fallback_entries[i++] = entry;
+      if (i == MAX_FALLBACK_ENTRIES)
+	break;
+      
+      arg = skip_to (0, arg);
+    }
+
+  if (i < MAX_FALLBACK_ENTRIES)
+    fallback_entries[i] = -1;
+
+  fallback_entryno = (i == 0) ? -1 : 0;
+  
+  return 0;
+}
+
+static struct builtin builtin_fallback =
+{
+  "fallback",
+  fallback_func,
+  BUILTIN_MENU,
+#if 0
+  "fallback NUM...",
+  "Go into unattended boot mode: if the default boot entry has any"
+  " errors, instead of waiting for the user to do anything, it"
+  " immediately starts over using the NUM entry (same numbering as the"
+  " `default' command). This obviously won't help if the machine"
+  " was rebooted by a kernel that GRUB loaded."
+#endif
+};
+
+
+/* find */
+/* Search for the filename ARG in all of partitions.  */
+static int
+find_func (char *arg, int flags)
+{
+  char *filename = arg;
+  unsigned long drive;
+  unsigned long tmp_drive = saved_drive;
+  unsigned long tmp_partition = saved_partition;
+  int got_file = 0;
+  
+  /* Floppies.  */
+  for (drive = 0; drive < 8; drive++)
+    {
+      current_drive = drive;
+      current_partition = 0xFFFFFF;
+      
+      if (open_device ())
+	{
+	  saved_drive = current_drive;
+	  saved_partition = current_partition;
+	  if (grub_open (filename))
+	    {
+	      grub_close ();
+	      grub_printf (" (fd%d)\n", drive);
+	      got_file = 1;
+	    }
+	}
+
+      errnum = ERR_NONE;
+    }
+
+  /* Hard disks.  */
+  for (drive = 0x80; drive < 0x88; drive++)
+    {
+      unsigned long part = 0xFFFFFF;
+      unsigned long start, len, offset, ext_offset;
+      int type, entry;
+      char buf[SECTOR_SIZE];
+
+      current_drive = drive;
+      while (next_partition (drive, 0xFFFFFF, &part, &type,
+			     &start, &len, &offset, &entry,
+			     &ext_offset, buf))
+	{
+	  if (type != PC_SLICE_TYPE_NONE
+	      && ! IS_PC_SLICE_TYPE_BSD (type)
+	      && ! IS_PC_SLICE_TYPE_EXTENDED (type))
+	    {
+	      current_partition = part;
+	      if (open_device ())
+		{
+		  saved_drive = current_drive;
+		  saved_partition = current_partition;
+		  if (grub_open (filename))
+		    {
+		      int bsd_part = (part >> 8) & 0xFF;
+		      int pc_slice = part >> 16;
+		      
+		      grub_close ();
+		      
+		      if (bsd_part == 0xFF)
+			grub_printf (" (hd%d,%d)\n",
+				     drive - 0x80, pc_slice);
+		      else
+			grub_printf (" (hd%d,%d,%c)\n",
+				     drive - 0x80, pc_slice, bsd_part + 'a');
+
+		      got_file = 1;
+		    }
+		}
+	    }
+
+	  /* We want to ignore any error here.  */
+	  errnum = ERR_NONE;
+	}
+
+      /* next_partition always sets ERRNUM in the last call, so clear
+	 it.  */
+      errnum = ERR_NONE;
+    }
+
+  saved_drive = tmp_drive;
+  saved_partition = tmp_partition;
+
+  if (got_file)
+    {
+      errnum = ERR_NONE;
+      return 0;
+    }
+
+  errnum = ERR_FILE_NOT_FOUND;
+  return 1;
+}
+
+static struct builtin builtin_find =
+{
+  "find",
+  find_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "find FILENAME",
+  "Search for the filename FILENAME in all of partitions and print the list of"
+  " the devices which contain the file."
+};
+
+
+/* fstest */
+static int
+fstest_func (char *arg, int flags)
+{
+  if (disk_read_hook)
+    {
+      disk_read_hook = NULL;
+      printf (" Filesystem tracing is now off\n");
+    }
+  else
+    {
+      disk_read_hook = disk_read_print_func;
+      printf (" Filesystem tracing is now on\n");
+    }
+
+  return 0;
+}
+
+static struct builtin builtin_fstest =
+{
+  "fstest",
+  fstest_func,
+  BUILTIN_CMDLINE,
+  "fstest",
+  "Toggle filesystem test mode."
+};
+
+
+/* graphics */
+static int
+gfxmenu_func (char *arg, int flags)
+{
+  memmove(graphics_file, arg, sizeof graphics_file - 1);
+  graphics_file[sizeof graphics_file - 1] = 0;
+
+  return 0;
+}
+
+static struct builtin builtin_gfxmenu =
+{
+  "gfxmenu",
+  gfxmenu_func,
+  BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "gfxmenu FILE",
+  "Use the graphical menu from FILE."
+};
+
+
+/* geometry */
+static int
+geometry_func (char *arg, int flags)
+{
+  struct geometry geom;
+  char *msg;
+  char *device = arg;
+#ifdef GRUB_UTIL
+  char *ptr;
+#endif
+
+  /* Get the device number.  */
+  set_device (device);
+  if (errnum)
+    return 1;
+
+  /* Check for the geometry.  */
+  if (get_diskinfo (current_drive, &geom))
+    {
+      errnum = ERR_NO_DISK;
+      return 1;
+    }
+
+  /* Attempt to read the first sector, because some BIOSes turns out not
+     to support LBA even though they set the bit 0 in the support
+     bitmap, only after reading something actually.  */
+  if (biosdisk (BIOSDISK_READ, current_drive, &geom, 0, 1, SCRATCHSEG))
+    {
+      errnum = ERR_READ;
+      return 1;
+    }
+
+#ifdef GRUB_UTIL
+  ptr = skip_to (0, device);
+  if (*ptr)
+    {
+      char *cylinder, *head, *sector, *total_sector;
+      int num_cylinder, num_head, num_sector, num_total_sector;
+
+      cylinder = ptr;
+      head = skip_to (0, cylinder);
+      sector = skip_to (0, head);
+      total_sector = skip_to (0, sector);
+      if (! safe_parse_maxint (&cylinder, &num_cylinder)
+	  || ! safe_parse_maxint (&head, &num_head)
+	  || ! safe_parse_maxint (&sector, &num_sector))
+	return 1;
+
+      disks[current_drive].cylinders = num_cylinder;
+      disks[current_drive].heads = num_head;
+      disks[current_drive].sectors = num_sector;
+
+      if (safe_parse_maxint (&total_sector, &num_total_sector))
+	disks[current_drive].total_sectors = num_total_sector;
+      else
+	disks[current_drive].total_sectors
+	  = num_cylinder * num_head * num_sector;
+      errnum = 0;
+
+      geom = disks[current_drive];
+      buf_drive = -1;
+    }
+#endif /* GRUB_UTIL */
+
+#ifdef GRUB_UTIL
+  msg = device_map[current_drive];
+#else
+  if (geom.flags & BIOSDISK_FLAG_LBA_EXTENSION)
+    msg = "LBA";
+  else
+    msg = "CHS";
+#endif
+
+  grub_printf ("drive 0x%x: C/H/S = %d/%d/%d, "
+	       "The number of sectors = %d, %s\n",
+	       current_drive,
+	       geom.cylinders, geom.heads, geom.sectors,
+	       geom.total_sectors, msg);
+  real_open_partition (1);
+
+  return 0;
+}
+
+static struct builtin builtin_geometry =
+{
+  "geometry",
+  geometry_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "geometry DRIVE [CYLINDER HEAD SECTOR [TOTAL_SECTOR]]",
+  "Print the information for a drive DRIVE. In the grub shell, you can"
+  " set the geometry of the drive arbitrarily. The number of the cylinders,"
+  " the one of the heads, the one of the sectors and the one of the total"
+  " sectors are set to CYLINDER, HEAD, SECTOR and TOTAL_SECTOR,"
+  " respectively. If you omit TOTAL_SECTOR, then it will be calculated based"
+  " on the C/H/S values automatically."
+};
+
+
+/* halt */
+static int
+halt_func (char *arg, int flags)
+{
+  int no_apm;
+
+  no_apm = (grub_memcmp (arg, "--no-apm", 8) == 0);
+  grub_halt (no_apm);
+  
+  /* Never reach here.  */
+  return 1;
+}
+
+static struct builtin builtin_halt =
+{
+  "halt",
+  halt_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "halt [--no-apm]",
+  "Halt your system. If APM is avaiable on it, turn off the power using"
+  " the APM BIOS, unless you specify the option `--no-apm'."
+};
+
+
+/* help */
+#define MAX_SHORT_DOC_LEN	39
+#define MAX_LONG_DOC_LEN	66
+
+static int
+help_func (char *arg, int flags)
+{
+  int all = 0;
+  
+  if (grub_memcmp (arg, "--all", sizeof ("--all") - 1) == 0)
+    {
+      all = 1;
+      arg = skip_to (0, arg);
+    }
+  
+  if (! *arg)
+    {
+      /* Invoked with no argument. Print the list of the short docs.  */
+      struct builtin **builtin;
+      int left = 1;
+
+      for (builtin = builtin_table; *builtin != 0; builtin++)
+	{
+	  int len;
+	  int i;
+
+	  /* If this cannot be used in the command-line interface,
+	     skip this.  */
+	  if (! ((*builtin)->flags & BUILTIN_CMDLINE))
+	    continue;
+	  
+	  /* If this doesn't need to be listed automatically and "--all"
+	     is not specified, skip this.  */
+	  if (! all && ! ((*builtin)->flags & BUILTIN_HELP_LIST))
+	    continue;
+
+	  len = grub_strlen ((*builtin)->short_doc);
+	  /* If the length of SHORT_DOC is too long, truncate it.  */
+	  if (len > MAX_SHORT_DOC_LEN - 1)
+	    len = MAX_SHORT_DOC_LEN - 1;
+
+	  for (i = 0; i < len; i++)
+	    grub_putchar ((*builtin)->short_doc[i]);
+
+	  for (; i < MAX_SHORT_DOC_LEN; i++)
+	    grub_putchar (' ');
+
+	  if (! left)
+	    grub_putchar ('\n');
+
+	  left = ! left;
+	}
+
+      /* If the last entry was at the left column, no newline was printed
+	 at the end.  */
+      if (! left)
+	grub_putchar ('\n');
+    }
+  else
+    {
+      /* Invoked with one or more patterns.  */
+      do
+	{
+	  struct builtin **builtin;
+	  char *next_arg;
+
+	  /* Get the next argument.  */
+	  next_arg = skip_to (0, arg);
+
+	  /* Terminate ARG.  */
+	  nul_terminate (arg);
+
+	  for (builtin = builtin_table; *builtin; builtin++)
+	    {
+	      /* Skip this if this is only for the configuration file.  */
+	      if (! ((*builtin)->flags & BUILTIN_CMDLINE))
+		continue;
+
+	      if (substring (arg, (*builtin)->name) < 1)
+		{
+		  char *doc = (*builtin)->long_doc;
+
+		  /* At first, print the name and the short doc.  */
+		  grub_printf ("%s: %s\n",
+			       (*builtin)->name, (*builtin)->short_doc);
+
+		  /* Print the long doc.  */
+		  while (*doc)
+		    {
+		      int len = grub_strlen (doc);
+		      int i;
+
+		      /* If LEN is too long, fold DOC.  */
+		      if (len > MAX_LONG_DOC_LEN)
+			{
+			  /* Fold this line at the position of a space.  */
+			  for (len = MAX_LONG_DOC_LEN; len > 0; len--)
+			    if (doc[len - 1] == ' ')
+			      break;
+			}
+
+		      grub_printf ("    ");
+		      for (i = 0; i < len; i++)
+			grub_putchar (*doc++);
+		      grub_putchar ('\n');
+		    }
+		}
+	    }
+
+	  arg = next_arg;
+	}
+      while (*arg);
+    }
+
+  return 0;
+}
+
+static struct builtin builtin_help =
+{
+  "help",
+  help_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "help [--all] [PATTERN ...]",
+  "Display helpful information about builtin commands. Not all commands"
+  " aren't shown without the option `--all'."
+};
+
+
+/* hiddenmenu */
+static int
+hiddenmenu_func (char *arg, int flags)
+{
+  show_menu = 0;
+  return 0;
+}
+
+static struct builtin builtin_hiddenmenu =
+{
+  "hiddenmenu",
+  hiddenmenu_func,
+  BUILTIN_MENU,
+#if 0
+  "hiddenmenu",
+  "Hide the menu."
+#endif
+};
+
+
+/* hide */
+static int
+hide_func (char *arg, int flags)
+{
+  if (! set_device (arg))
+    return 1;
+
+  if (! set_partition_hidden_flag (1))
+    return 1;
+
+  return 0;
+}
+
+static struct builtin builtin_hide =
+{
+  "hide",
+  hide_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "hide PARTITION",
+  "Hide PARTITION by setting the \"hidden\" bit in"
+  " its partition type code."
+};
+
+
+#ifdef SUPPORT_NETBOOT
+/* ifconfig */
+static int
+ifconfig_func (char *arg, int flags)
+{
+  char *svr = 0, *ip = 0, *gw = 0, *sm = 0;
+  
+  if (! eth_probe ())
+    {
+      grub_printf ("No ethernet card found.\n");
+      errnum = ERR_DEV_VALUES;
+      return 1;
+    }
+  
+  while (*arg) 
+    {
+      if (! grub_memcmp ("--server=", arg, sizeof ("--server=") - 1))
+	svr = arg + sizeof("--server=") - 1;
+      else if (! grub_memcmp ("--address=", arg, sizeof ("--address=") - 1))
+	ip = arg + sizeof ("--address=") - 1;
+      else if (! grub_memcmp ("--gateway=", arg, sizeof ("--gateway=") - 1))
+	gw = arg + sizeof ("--gateway=") - 1;
+      else if (! grub_memcmp ("--mask=", arg, sizeof("--mask=") - 1))
+	sm = arg + sizeof ("--mask=") - 1;
+      else
+	{
+	  errnum = ERR_BAD_ARGUMENT;
+	  return 1;
+	}
+      
+      arg = skip_to (0, arg);
+    }
+  
+  if (! ifconfig (ip, sm, gw, svr))
+    {
+      errnum = ERR_BAD_ARGUMENT;
+      return 1;
+    }
+  
+  print_network_configuration ();
+  return 0;
+}
+
+static struct builtin builtin_ifconfig =
+{
+  "ifconfig",
+  ifconfig_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "ifconfig [--address=IP] [--gateway=IP] [--mask=MASK] [--server=IP]",
+  "Configure the IP address, the netmask, the gateway and the server"
+  " address or print current network configuration."
+};
+#endif /* SUPPORT_NETBOOT */
+
+
+/* impsprobe */
+static int
+impsprobe_func (char *arg, int flags)
+{
+#ifdef GRUB_UTIL
+  /* In the grub shell, we cannot probe IMPS.  */
+  errnum = ERR_UNRECOGNIZED;
+  return 1;
+#else /* ! GRUB_UTIL */
+  if (!imps_probe ())
+    printf (" No MPS information found or probe failed\n");
+
+  return 0;
+#endif /* ! GRUB_UTIL */
+}
+
+static struct builtin builtin_impsprobe =
+{
+  "impsprobe",
+  impsprobe_func,
+  BUILTIN_CMDLINE,
+  "impsprobe",
+  "Probe the Intel Multiprocessor Specification 1.1 or 1.4"
+  " configuration table and boot the various CPUs which are found into"
+  " a tight loop."
+};
+
+
+/* initrd */
+static int
+initrd_func (char *arg, int flags)
+{
+  switch (kernel_type)
+    {
+    case KERNEL_TYPE_LINUX:
+    case KERNEL_TYPE_BIG_LINUX:
+      if (! load_initrd (arg))
+	return 1;
+      break;
+
+    default:
+      errnum = ERR_NEED_LX_KERNEL;
+      return 1;
+    }
+
+  return 0;
+}
+
+static struct builtin builtin_initrd =
+{
+  "initrd",
+  initrd_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "initrd FILE [ARG ...]",
+  "Load an initial ramdisk FILE for a Linux format boot image and set the"
+  " appropriate parameters in the Linux setup area in memory."
+};
+
+
+/* install */
+static int
+install_func (char *arg, int flags)
+{
+  char *stage1_file, *dest_dev, *file, *addr;
+  char *stage1_buffer = (char *) RAW_ADDR (0x100000);
+  char *stage2_buffer = stage1_buffer + SECTOR_SIZE;
+  char *old_sect = stage2_buffer + SECTOR_SIZE;
+  char *stage2_first_buffer = old_sect + SECTOR_SIZE;
+  char *stage2_second_buffer = stage2_first_buffer + SECTOR_SIZE;
+  /* XXX: Probably SECTOR_SIZE is reasonable.  */
+  char *config_filename = stage2_second_buffer + SECTOR_SIZE;
+  char *dummy = config_filename + SECTOR_SIZE;
+  int new_drive = GRUB_INVALID_DRIVE;
+  int dest_drive, dest_partition, dest_sector;
+  int src_drive, src_partition, src_part_start;
+  int i;
+  struct geometry dest_geom, src_geom;
+  int saved_sector;
+  int stage2_first_sector, stage2_second_sector;
+  char *ptr;
+  int installaddr, installlist;
+  /* Point to the location of the name of a configuration file in Stage 2.  */
+  char *config_file_location;
+  /* If FILE is a Stage 1.5?  */
+  int is_stage1_5 = 0;
+  /* Must call grub_close?  */
+  int is_open = 0;
+  /* If LBA is forced?  */
+  int is_force_lba = 0;
+  /* Was the last sector full? */
+  int last_length = SECTOR_SIZE;
+  
+#ifdef GRUB_UTIL
+  /* If the Stage 2 is in a partition mounted by an OS, this will store
+     the filename under the OS.  */
+  char *stage2_os_file = 0;
+#endif /* GRUB_UTIL */
+  
+  auto void disk_read_savesect_func (int sector, int offset, int length);
+  auto void disk_read_blocklist_func (int sector, int offset, int length);
+  
+  /* Save the first sector of Stage2 in STAGE2_SECT.  */
+  auto void disk_read_savesect_func (int sector, int offset, int length)
+    {
+      if (debug)
+	printf ("[%d]", sector);
+
+      /* ReiserFS has files which sometimes contain data not aligned
+         on sector boundaries.  Returning an error is better than
+         silently failing. */
+      if (offset != 0 || length != SECTOR_SIZE)
+	errnum = ERR_UNALIGNED;
+
+      saved_sector = sector;
+    }
+
+  /* Write SECTOR to INSTALLLIST, and update INSTALLADDR and
+     INSTALLSECT.  */
+  auto void disk_read_blocklist_func (int sector, int offset, int length)
+    {
+      if (debug)
+	printf("[%d]", sector);
+
+      if (offset != 0 || last_length != SECTOR_SIZE)
+	{
+	  /* We found a non-sector-aligned data block. */
+	  errnum = ERR_UNALIGNED;
+	  return;
+	}
+
+      last_length = length;
+
+      if (*((unsigned long *) (installlist - 4))
+	  + *((unsigned short *) installlist) != sector
+	  || installlist == (int) stage2_first_buffer + SECTOR_SIZE + 4)
+	{
+	  installlist -= 8;
+
+	  if (*((unsigned long *) (installlist - 8)))
+	    errnum = ERR_WONT_FIT;
+	  else
+	    {
+	      *((unsigned short *) (installlist + 2)) = (installaddr >> 4);
+	      *((unsigned long *) (installlist - 4)) = sector;
+	    }
+	}
+
+      *((unsigned short *) installlist) += 1;
+      installaddr += 512;
+    }
+
+  /* First, check the GNU-style long option.  */
+  while (1)
+    {
+      if (grub_memcmp ("--force-lba", arg, sizeof ("--force-lba") - 1) == 0)
+	{
+	  is_force_lba = 1;
+	  arg = skip_to (0, arg);
+	}
+#ifdef GRUB_UTIL
+      else if (grub_memcmp ("--stage2=", arg, sizeof ("--stage2=") - 1) == 0)
+	{
+	  int fd;
+	  stage2_os_file = arg + sizeof ("--stage2=") - 1;
+	  arg = skip_to (0, arg);
+	  nul_terminate (stage2_os_file);
+
+#if defined(__linux__) && defined (FSYS_REISERFS)
+	  if ((fd=open(stage2_os_file, O_RDONLY)) >= 0)
+	    {
+	      struct statfs buf;
+	      /* see if the file sits on a reiserfs,
+		 and try do defragment it if so. */
+	      fstatfs(fd, &buf);
+	      if (buf.f_type == REISERFS_SUPER_MAGIC)
+		ioctl (fd, REISERFS_IOC_UNPACK, 1);
+	    }
+#endif	/* __linux__ && FSYS_REISERFS */
+
+	}
+#endif /* GRUB_UTIL */
+      else
+	break;
+    }
+  
+  stage1_file = arg;
+  dest_dev = skip_to (0, stage1_file);
+  if (*dest_dev == 'd')
+    {
+      new_drive = 0;
+      dest_dev = skip_to (0, dest_dev);
+    }
+  file = skip_to (0, dest_dev);
+  addr = skip_to (0, file);
+
+  /* Get the installation address.  */
+  if (! safe_parse_maxint (&addr, &installaddr))
+    {
+      /* ADDR is not specified.  */
+      installaddr = 0;
+      ptr = addr;
+      errnum = 0;
+    }
+  else
+    ptr = skip_to (0, addr);
+
+#ifndef NO_DECOMPRESSION
+  /* Do not decompress Stage 1 or Stage 2.  */
+  no_decompression = 1;
+#endif
+
+  /* Read Stage 1.  */
+  is_open = grub_open (stage1_file);
+  if (! is_open
+      || ! grub_read (stage1_buffer, SECTOR_SIZE) == SECTOR_SIZE)
+    goto fail;
+
+  /* Read the old sector from DEST_DEV.  */
+  if (! set_device (dest_dev)
+      || ! open_partition ()
+      || ! devread (0, 0, SECTOR_SIZE, old_sect))
+    goto fail;
+
+  /* Store the information for the destination device.  */
+  dest_drive = current_drive;
+  dest_partition = current_partition;
+  dest_geom = buf_geom;
+  dest_sector = part_start;
+
+  /* Copy the possible DOS BPB, 59 bytes at byte offset 3.  */
+  grub_memmove (stage1_buffer + BOOTSEC_BPB_OFFSET,
+		old_sect + BOOTSEC_BPB_OFFSET,
+		BOOTSEC_BPB_LENGTH);
+
+  /* If for a hard disk, copy the possible MBR/extended part table.  */
+  if (dest_drive & 0x80)
+    grub_memmove (stage1_buffer + STAGE1_WINDOWS_NT_MAGIC,
+		  old_sect + STAGE1_WINDOWS_NT_MAGIC,
+		  STAGE1_PARTEND - STAGE1_WINDOWS_NT_MAGIC);
+
+  /* Check for the version and the signature of Stage 1.  */
+  if (*((short *)(stage1_buffer + STAGE1_VER_MAJ_OFFS)) != COMPAT_VERSION
+      || (*((unsigned short *) (stage1_buffer + BOOTSEC_SIG_OFFSET))
+	  != BOOTSEC_SIGNATURE))
+    {
+      errnum = ERR_BAD_VERSION;
+      goto fail;
+    }
+
+  /* This below is not true any longer. But should we leave this alone?  */
+  
+  /* If DEST_DRIVE is a floppy, Stage 2 must have the iteration probe
+     routine.  */
+  if (! (dest_drive & 0x80)
+      && (*((unsigned char *) (stage1_buffer + BOOTSEC_PART_OFFSET)) == 0x80
+	  || stage1_buffer[BOOTSEC_PART_OFFSET] == 0))
+    {
+      errnum = ERR_BAD_VERSION;
+      goto fail;
+    }
+
+  grub_close ();
+  
+  /* Open Stage 2.  */
+  is_open = grub_open (file);
+  if (! is_open)
+    goto fail;
+
+  src_drive = current_drive;
+  src_partition = current_partition;
+  src_part_start = part_start;
+  src_geom = buf_geom;
+  
+  if (! new_drive)
+    new_drive = src_drive;
+  else if (src_drive != dest_drive)
+    grub_printf ("Warning: the option `d' was not used, but the Stage 1 will"
+		 " be installed on a\ndifferent drive than the drive where"
+		 " the Stage 2 resides.\n");
+
+  /* Set the boot drive.  */
+  *((unsigned char *) (stage1_buffer + STAGE1_BOOT_DRIVE)) = new_drive;
+
+  /* Set the "force LBA" flag.  */
+  *((unsigned char *) (stage1_buffer + STAGE1_FORCE_LBA)) = is_force_lba;
+
+  /* If DEST_DRIVE is a hard disk, enable the workaround, which is
+     for buggy BIOSes which don't pass boot drive correctly. Instead,
+     they pass 0x00 or 0x01 even when booted from 0x80.  */
+  if (dest_drive & BIOS_FLAG_FIXED_DISK)
+    /* Replace the jmp (2 bytes) with double nop's.  */
+    *((unsigned short *) (stage1_buffer + STAGE1_BOOT_DRIVE_CHECK))
+      = 0x9090;
+  
+  /* Read the first sector of Stage 2.  */
+  disk_read_hook = disk_read_savesect_func;
+  if (grub_read (stage2_first_buffer, SECTOR_SIZE) != SECTOR_SIZE)
+    goto fail;
+
+  stage2_first_sector = saved_sector;
+  
+  /* Read the second sector of Stage 2.  */
+  if (grub_read (stage2_second_buffer, SECTOR_SIZE) != SECTOR_SIZE)
+    goto fail;
+
+  stage2_second_sector = saved_sector;
+  
+  /* Check for the version of Stage 2.  */
+  if (*((short *) (stage2_second_buffer + STAGE2_VER_MAJ_OFFS))
+      != COMPAT_VERSION)
+    {
+      errnum = ERR_BAD_VERSION;
+      goto fail;
+    }
+
+  /* Check for the Stage 2 id.  */
+  if (stage2_second_buffer[STAGE2_STAGE2_ID] != STAGE2_ID_STAGE2)
+    is_stage1_5 = 1;
+
+  /* If INSTALLADDR is not specified explicitly in the command-line,
+     determine it by the Stage 2 id.  */
+  if (! installaddr)
+    {
+      if (! is_stage1_5)
+	/* Stage 2.  */
+	installaddr = 0x8000;
+      else
+	/* Stage 1.5.  */
+	installaddr = 0x2000;
+    }
+
+  *((unsigned long *) (stage1_buffer + STAGE1_STAGE2_SECTOR))
+    = stage2_first_sector;
+  *((unsigned short *) (stage1_buffer + STAGE1_STAGE2_ADDRESS))
+    = installaddr;
+  *((unsigned short *) (stage1_buffer + STAGE1_STAGE2_SEGMENT))
+    = installaddr >> 4;
+
+  i = (int) stage2_first_buffer + SECTOR_SIZE - 4;
+  while (*((unsigned long *) i))
+    {
+      if (i < (int) stage2_first_buffer
+	  || (*((int *) (i - 4)) & 0x80000000)
+	  || *((unsigned short *) i) >= 0xA00
+	  || *((short *) (i + 2)) == 0)
+	{
+	  errnum = ERR_BAD_VERSION;
+	  goto fail;
+	}
+
+      *((int *) i) = 0;
+      *((int *) (i - 4)) = 0;
+      i -= 8;
+    }
+
+  installlist = (int) stage2_first_buffer + SECTOR_SIZE + 4;
+  installaddr += SECTOR_SIZE;
+  
+  /* Read the whole of Stage2 except for the first sector.  */
+  grub_seek (SECTOR_SIZE);
+
+  disk_read_hook = disk_read_blocklist_func;
+  if (! grub_read (dummy, -1))
+    goto fail;
+  
+  disk_read_hook = 0;
+  
+  /* Find a string for the configuration filename.  */
+  config_file_location = stage2_second_buffer + STAGE2_VER_STR_OFFS;
+  while (*(config_file_location++))
+    ;
+
+  /* Set the "force LBA" flag for Stage2.  */
+  *((unsigned char *) (stage2_second_buffer + STAGE2_FORCE_LBA))
+    = is_force_lba;
+  
+  if (*ptr == 'p')
+    {
+      *((long *) (stage2_second_buffer + STAGE2_INSTALLPART))
+	= src_partition;
+      if (is_stage1_5)
+	{
+	  /* Reset the device information in FILE if it is a Stage 1.5.  */
+	  unsigned long device = 0xFFFFFFFF;
+
+	  grub_memmove (config_file_location, (char *) &device,
+			sizeof (device));
+	}
+
+      ptr = skip_to (0, ptr);
+    }
+
+  if (*ptr)
+    {
+      grub_strcpy (config_filename, ptr);
+      nul_terminate (config_filename);
+	
+      if (! is_stage1_5)
+	/* If it is a Stage 2, just copy PTR to CONFIG_FILE_LOCATION.  */
+	grub_strcpy (config_file_location, ptr);
+      else
+	{
+	  char *real_config;
+	  unsigned long device;
+
+	  /* Translate the external device syntax to the internal device
+	     syntax.  */
+	  if (! (real_config = set_device (ptr)))
+	    {
+	      /* The Stage 2 PTR does not contain the device name, so
+		 use the root device instead.  */
+	      errnum = ERR_NONE;
+	      current_drive = saved_drive;
+	      current_partition = saved_partition;
+	      real_config = ptr;
+	    }
+	  
+	  if (current_drive == src_drive)
+	    {
+	      /* If the drive where the Stage 2 resides is the same as
+		 the one where the Stage 1.5 resides, do not embed the
+		 drive number.  */
+	      current_drive = GRUB_INVALID_DRIVE;
+	    }
+
+	  device = (current_drive << 24) | current_partition;
+	  grub_memmove (config_file_location, (char *) &device,
+			sizeof (device));
+	  grub_strcpy (config_file_location + sizeof (device),
+		       real_config);
+	}
+
+      /* If a Stage 1.5 is used, then we need to modify the Stage2.  */
+      if (is_stage1_5)
+	{
+	  char *real_config_filename = skip_to (0, ptr);
+	  
+	  is_open = grub_open (config_filename);
+	  if (! is_open)
+	    goto fail;
+
+	  /* Skip the first sector.  */
+	  grub_seek (SECTOR_SIZE);
+	  
+	  disk_read_hook = disk_read_savesect_func;
+	  if (grub_read (stage2_buffer, SECTOR_SIZE) != SECTOR_SIZE)
+	    goto fail;
+	  
+	  disk_read_hook = 0;
+	  grub_close ();
+	  is_open = 0;
+	  
+	  /* Sanity check.  */
+	  if (*(stage2_buffer + STAGE2_STAGE2_ID) != STAGE2_ID_STAGE2)
+	    {
+	      errnum = ERR_BAD_VERSION;
+	      goto fail;
+	    }
+
+	  /* Set the "force LBA" flag for Stage2.  */
+	  *(stage2_buffer + STAGE2_FORCE_LBA) = is_force_lba;
+
+	  /* If REAL_CONFIG_FILENAME is specified, copy it to the Stage2.  */
+	  if (*real_config_filename)
+	    {
+	      /* Specified */
+	      char *location;
+	      
+	      /* Find a string for the configuration filename.  */
+	      location = stage2_buffer + STAGE2_VER_STR_OFFS;
+	      while (*(location++))
+		;
+	      
+	      /* Copy the name.  */
+	      grub_strcpy (location, real_config_filename);
+	    }
+	  
+	  /* Write it to the disk.  */
+	  buf_track = -1;
+
+#ifdef GRUB_UTIL
+	  /* In the grub shell, access the Stage 2 via the OS filesystem
+	     service, if possible.  */
+	  if (stage2_os_file)
+	    {
+	      FILE *fp;
+
+	      fp = fopen (stage2_os_file, "r+");
+	      if (! fp)
+		{
+		  errnum = ERR_FILE_NOT_FOUND;
+		  goto fail;
+		}
+
+	      if (fseek (fp, SECTOR_SIZE, SEEK_SET) != 0)
+		{
+		  fclose (fp);
+		  errnum = ERR_BAD_VERSION;
+		  goto fail;
+		}
+
+	      if (fwrite (stage2_buffer, 1, SECTOR_SIZE, fp)
+		  != SECTOR_SIZE)
+		{
+		  fclose (fp);
+		  errnum = ERR_WRITE;
+		  goto fail;
+		}
+
+	      fclose (fp);
+	    }
+	  else
+#endif /* GRUB_UTIL */
+	    {
+	      if (! devwrite (saved_sector - part_start, 1, stage2_buffer))
+		goto fail;
+	    }
+	}
+    }
+
+  /* Clear the cache.  */
+  buf_track = -1;
+
+  /* Write the modified sectors of Stage2 to the disk.  */
+#ifdef GRUB_UTIL
+  if (! is_stage1_5 && stage2_os_file)
+    {
+      FILE *fp;
+
+      fp = fopen (stage2_os_file, "r+");
+      if (! fp)
+	{
+	  errnum = ERR_FILE_NOT_FOUND;
+	  goto fail;
+	}
+
+      if (fwrite (stage2_first_buffer, 1, SECTOR_SIZE, fp) != SECTOR_SIZE)
+	{
+	  fclose (fp);
+	  errnum = ERR_WRITE;
+	  goto fail;
+	}
+
+      if (fwrite (stage2_second_buffer, 1, SECTOR_SIZE, fp) != SECTOR_SIZE)
+	{
+	  fclose (fp);
+	  errnum = ERR_WRITE;
+	  goto fail;
+	}
+
+      fclose (fp);
+    }
+  else
+#endif /* GRUB_UTIL */
+    {
+      /* The first.  */
+      current_drive = src_drive;
+      current_partition = src_partition;
+
+      if (! open_partition ())
+	goto fail;
+
+      if (! devwrite (stage2_first_sector - src_part_start, 1,
+		      stage2_first_buffer))
+	goto fail;
+
+      if (! devwrite (stage2_second_sector - src_part_start, 1,
+		      stage2_second_buffer))
+	goto fail;
+    }
+  
+  /* Write the modified sector of Stage 1 to the disk.  */
+  current_drive = dest_drive;
+  current_partition = dest_partition;
+  if (! open_partition ())
+    goto fail;
+
+  devwrite (0, 1, stage1_buffer);
+
+ fail:
+  if (is_open)
+    grub_close ();
+  
+  disk_read_hook = 0;
+  
+#ifndef NO_DECOMPRESSION
+  no_decompression = 0;
+#endif
+
+  return errnum;
+}
+
+static struct builtin builtin_install =
+{
+  "install",
+  install_func,
+  BUILTIN_CMDLINE,
+  "install [--stage2=STAGE2_FILE] [--force-lba] STAGE1 [d] DEVICE STAGE2 [ADDR] [p] [CONFIG_FILE] [REAL_CONFIG_FILE]",
+  "Install STAGE1 on DEVICE, and install a blocklist for loading STAGE2"
+  " as a Stage 2. If the option `d' is present, the Stage 1 will always"
+  " look for the disk where STAGE2 was installed, rather than using"
+  " the booting drive. The Stage 2 will be loaded at address ADDR, which"
+  " will be determined automatically if you don't specify it. If"
+  " the option `p' or CONFIG_FILE is present, then the first block"
+  " of Stage 2 is patched with new values of the partition and name"
+  " of the configuration file used by the true Stage 2 (for a Stage 1.5,"
+  " this is the name of the true Stage 2) at boot time. If STAGE2 is a Stage"
+  " 1.5 and REAL_CONFIG_FILE is present, then the Stage 2 CONFIG_FILE is"
+  " patched with the configuration filename REAL_CONFIG_FILE."
+  " If the option `--force-lba' is specified, disable some sanity checks"
+  " for LBA mode. If the option `--stage2' is specified, rewrite the Stage"
+  " 2 via your OS's filesystem instead of the raw device."
+};
+
+
+/* ioprobe */
+static int
+ioprobe_func (char *arg, int flags)
+{
+#ifdef GRUB_UTIL
+  
+  errnum = ERR_UNRECOGNIZED;
+  return 1;
+  
+#else /* ! GRUB_UTIL */
+  
+  unsigned short *port;
+  
+  /* Get the drive number.  */
+  set_device (arg);
+  if (errnum)
+    return 1;
+
+  /* Clean out IO_MAP.  */
+  grub_memset ((char *) io_map, 0, IO_MAP_SIZE * sizeof (unsigned short));
+
+  /* Track the int13 handler.  */
+  track_int13 (current_drive);
+  
+  /* Print out the result.  */
+  for (port = io_map; *port != 0; port++)
+    grub_printf (" 0x%x", (unsigned int) *port);
+
+  return 0;
+  
+#endif /* ! GRUB_UTIL */
+}
+
+static struct builtin builtin_ioprobe =
+{
+  "ioprobe",
+  ioprobe_func,
+  BUILTIN_CMDLINE,
+  "ioprobe DRIVE",
+  "Probe I/O ports used for the drive DRIVE."
+};
+
+
+/* kernel */
+static int
+kernel_func (char *arg, int flags)
+{
+  int len;
+  kernel_t suggested_type = KERNEL_TYPE_NONE;
+  unsigned long load_flags = 0;
+
+#ifndef AUTO_LINUX_MEM_OPT
+  load_flags |= KERNEL_LOAD_NO_MEM_OPTION;
+#endif
+
+  /* Deal with GNU-style long options.  */
+  while (1)
+    {
+      /* If the option `--type=TYPE' is specified, convert the string to
+	 a kernel type.  */
+      if (grub_memcmp (arg, "--type=", 7) == 0)
+	{
+	  arg += 7;
+	  
+	  if (grub_memcmp (arg, "netbsd", 6) == 0)
+	    suggested_type = KERNEL_TYPE_NETBSD;
+	  else if (grub_memcmp (arg, "freebsd", 7) == 0)
+	    suggested_type = KERNEL_TYPE_FREEBSD;
+	  else if (grub_memcmp (arg, "openbsd", 7) == 0)
+	    /* XXX: For now, OpenBSD is identical to NetBSD, from GRUB's
+	       point of view.  */
+	    suggested_type = KERNEL_TYPE_NETBSD;
+	  else if (grub_memcmp (arg, "linux", 5) == 0)
+	    suggested_type = KERNEL_TYPE_LINUX;
+	  else if (grub_memcmp (arg, "biglinux", 8) == 0)
+	    suggested_type = KERNEL_TYPE_BIG_LINUX;
+	  else if (grub_memcmp (arg, "multiboot", 9) == 0)
+	    suggested_type = KERNEL_TYPE_MULTIBOOT;
+	  else
+	    {
+	      errnum = ERR_BAD_ARGUMENT;
+	      return 1;
+	    }
+	}
+      /* If the `--no-mem-option' is specified, don't pass a Linux's mem
+	 option automatically. If the kernel is another type, this flag
+	 has no effect.  */
+      else if (grub_memcmp (arg, "--no-mem-option", 15) == 0)
+	load_flags |= KERNEL_LOAD_NO_MEM_OPTION;
+      else
+	break;
+
+      /* Try the next.  */
+      arg = skip_to (0, arg);
+    }
+      
+  len = grub_strlen (arg);
+
+  /* Reset MB_CMDLINE.  */
+  mb_cmdline = (char *) MB_CMDLINE_BUF;
+  if (len + 1 > MB_CMDLINE_BUFLEN)
+    {
+      errnum = ERR_WONT_FIT;
+      return 1;
+    }
+
+  /* Copy the command-line to MB_CMDLINE.  */
+  grub_memmove (mb_cmdline, arg, len + 1);
+  kernel_type = load_image (arg, mb_cmdline, suggested_type, load_flags);
+  if (kernel_type == KERNEL_TYPE_NONE)
+    return 1;
+
+  mb_cmdline += len + 1;
+  return 0;
+}
+
+static struct builtin builtin_kernel =
+{
+  "kernel",
+  kernel_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "kernel [--no-mem-option] [--type=TYPE] FILE [ARG ...]",
+  "Attempt to load the primary boot image from FILE. The rest of the"
+  " line is passed verbatim as the \"kernel command line\".  Any modules"
+  " must be reloaded after using this command. The option --type is used"
+  " to suggest what type of kernel to be loaded. TYPE must be either of"
+  " \"netbsd\", \"freebsd\", \"openbsd\", \"linux\", \"biglinux\" and"
+  " \"multiboot\". The option --no-mem-option tells GRUB not to pass a"
+  " Linux's mem option automatically."
+};
+
+
+/* lock */
+static int
+lock_func (char *arg, int flags)
+{
+  if (! auth && password)
+    {
+      errnum = ERR_PRIVILEGED;
+      return 1;
+    }
+
+  return 0;
+}
+
+static struct builtin builtin_lock =
+{
+  "lock",
+  lock_func,
+  BUILTIN_CMDLINE,
+  "lock",
+  "Break a command execution unless the user is authenticated."
+};
+  
+
+/* makeactive */
+static int
+makeactive_func (char *arg, int flags)
+{
+  if (! make_saved_active ())
+    return 1;
+
+  return 0;
+}
+
+static struct builtin builtin_makeactive =
+{
+  "makeactive",
+  makeactive_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "makeactive",
+  "Set the active partition on the root disk to GRUB's root device."
+  " This command is limited to _primary_ PC partitions on a hard disk."
+};
+
+
+/* map */
+/* Map FROM_DRIVE to TO_DRIVE.  */
+static int
+map_func (char *arg, int flags)
+{
+  char *to_drive;
+  char *from_drive;
+  unsigned long to, from;
+  int i;
+  
+  to_drive = arg;
+  from_drive = skip_to (0, arg);
+
+  /* Get the drive number for TO_DRIVE.  */
+  set_device (to_drive);
+  if (errnum)
+    return 1;
+  to = current_drive;
+
+  /* Get the drive number for FROM_DRIVE.  */
+  set_device (from_drive);
+  if (errnum)
+    return 1;
+  from = current_drive;
+
+  /* Search for an empty slot in BIOS_DRIVE_MAP.  */
+  for (i = 0; i < DRIVE_MAP_SIZE; i++)
+    {
+      /* Perhaps the user wants to override the map.  */
+      if ((bios_drive_map[i] & 0xff) == from)
+	break;
+      
+      if (! bios_drive_map[i])
+	break;
+    }
+
+  if (i == DRIVE_MAP_SIZE)
+    {
+      errnum = ERR_WONT_FIT;
+      return 1;
+    }
+
+  if (to == from)
+    /* If TO is equal to FROM, delete the entry.  */
+    grub_memmove ((char *) &bios_drive_map[i], (char *) &bios_drive_map[i + 1],
+		  sizeof (unsigned short) * (DRIVE_MAP_SIZE - i));
+  else
+    bios_drive_map[i] = from | (to << 8);
+  
+  return 0;
+}
+
+static struct builtin builtin_map =
+{
+  "map",
+  map_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "map TO_DRIVE FROM_DRIVE",
+  "Map the drive FROM_DRIVE to the drive TO_DRIVE. This is necessary"
+  " when you chain-load some operating systems, such as DOS, if such an"
+  " OS resides at a non-first drive."
+};
+
+
+#ifdef USE_MD5_PASSWORDS
+/* md5crypt */
+static int
+md5crypt_func (char *arg, int flags)
+{
+  char crypted[36];
+  char key[32];
+  unsigned int seed;
+  int i;
+  const char *const seedchars =
+    "./0123456789ABCDEFGHIJKLMNOPQRST"
+    "UVWXYZabcdefghijklmnopqrstuvwxyz";
+  
+  /* First create a salt.  */
+
+  /* The magical prefix.  */
+  grub_memset (crypted, 0, sizeof (crypted));
+  grub_memmove (crypted, "$1$", 3);
+
+  /* Create the length of a salt.  */
+  seed = currticks ();
+
+  /* Generate a salt.  */
+  for (i = 0; i < 8 && seed; i++)
+    {
+      /* FIXME: This should be more random.  */
+      crypted[3 + i] = seedchars[seed & 0x3f];
+      seed >>= 6;
+    }
+
+  /* A salt must be terminated with `$', if it is less than 8 chars.  */
+  crypted[3 + i] = '$';
+
+#ifdef DEBUG_MD5CRYPT
+  grub_printf ("salt = %s\n", crypted);
+#endif
+  
+  /* Get a password.  */
+  grub_memset (key, 0, sizeof (key));
+  get_cmdline ("Password: ", key, sizeof (key) - 1, '*', 0);
+
+  /* Crypt the key.  */
+  make_md5_password (key, crypted);
+
+  grub_printf ("Encrypted: %s\n", crypted);
+  return 0;
+}
+
+static struct builtin builtin_md5crypt =
+{
+  "md5crypt",
+  md5crypt_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "md5crypt",
+  "Generate a password in MD5 format."
+};
+#endif /* USE_MD5_PASSWORDS */
+
+
+/* module */
+static int
+module_func (char *arg, int flags)
+{
+  int len = grub_strlen (arg);
+
+  switch (kernel_type)
+    {
+    case KERNEL_TYPE_MULTIBOOT:
+      if (mb_cmdline + len + 1 > (char *) MB_CMDLINE_BUF + MB_CMDLINE_BUFLEN)
+	{
+	  errnum = ERR_WONT_FIT;
+	  return 1;
+	}
+      grub_memmove (mb_cmdline, arg, len + 1);
+      if (! load_module (arg, mb_cmdline))
+	return 1;
+      mb_cmdline += len + 1;
+      break;
+
+    case KERNEL_TYPE_LINUX:
+    case KERNEL_TYPE_BIG_LINUX:
+      if (! load_initrd (arg))
+	return 1;
+      break;
+
+    default:
+      errnum = ERR_NEED_MB_KERNEL;
+      return 1;
+    }
+
+  return 0;
+}
+
+static struct builtin builtin_module =
+{
+  "module",
+  module_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "module FILE [ARG ...]",
+  "Load a boot module FILE for a Multiboot format boot image (no"
+  " interpretation of the file contents is made, so users of this"
+  " command must know what the kernel in question expects). The"
+  " rest of the line is passed as the \"module command line\", like"
+  " the `kernel' command."
+};
+
+
+/* modulenounzip */
+static int
+modulenounzip_func (char *arg, int flags)
+{
+  int ret;
+
+#ifndef NO_DECOMPRESSION
+  no_decompression = 1;
+#endif
+
+  ret = module_func (arg, flags);
+
+#ifndef NO_DECOMPRESSION
+  no_decompression = 0;
+#endif
+
+  return ret;
+}
+
+static struct builtin builtin_modulenounzip =
+{
+  "modulenounzip",
+  modulenounzip_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "modulenounzip FILE [ARG ...]",
+  "The same as `module', except that automatic decompression is"
+  " disabled."
+};
+
+
+/* pager [on|off] */
+static int
+pager_func (char *arg, int flags)
+{
+  /* If ARG is empty, toggle the flag.  */
+  if (! *arg)
+    use_pager = ! use_pager;
+  else if (grub_memcmp (arg, "on", 2) == 0)
+    use_pager = 1;
+  else if (grub_memcmp (arg, "off", 3) == 0)
+    use_pager = 0;
+  else
+    {
+      errnum = ERR_BAD_ARGUMENT;
+      return 1;
+    }
+
+  grub_printf (" Internal pager is now %s\n", use_pager ? "on" : "off");
+  return 0;
+}
+
+static struct builtin builtin_pager =
+{
+  "pager",
+  pager_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "pager [FLAG]",
+  "Toggle pager mode with no argument. If FLAG is given and its value"
+  " is `on', turn on the mode. If FLAG is `off', turn off the mode."
+};
+
+
+/* partnew PART TYPE START LEN */
+static int
+partnew_func (char *arg, int flags)
+{
+  int new_type, new_start, new_len;
+  int start_cl, start_ch, start_dh;
+  int end_cl, end_ch, end_dh;
+  int entry;
+  char mbr[512];
+
+  /* Convert a LBA address to a CHS address in the INT 13 format.  */
+  auto void lba_to_chs (int lba, int *cl, int *ch, int *dh);
+  void lba_to_chs (int lba, int *cl, int *ch, int *dh)
+    {
+      int cylinder, head, sector;
+
+      sector = lba % buf_geom.sectors + 1;
+      head = (lba / buf_geom.sectors) % buf_geom.heads;
+      cylinder = lba / (buf_geom.sectors * buf_geom.heads);
+
+      if (cylinder >= buf_geom.cylinders)
+	cylinder = buf_geom.cylinders - 1;
+      
+      *cl = sector | ((cylinder & 0x300) >> 2);
+      *ch = cylinder & 0xFF;
+      *dh = head;
+    }
+      
+  /* Get the drive and the partition.  */
+  if (! set_device (arg))
+    return 1;
+
+  /* The drive must be a hard disk.  */
+  if (! (current_drive & 0x80))
+    {
+      errnum = ERR_BAD_ARGUMENT;
+      return 1;
+    }
+
+  /* The partition must a primary partition.  */
+  if ((current_partition >> 16) > 3
+      || (current_partition & 0xFFFF) != 0xFFFF)
+    {
+      errnum = ERR_BAD_ARGUMENT;
+      return 1;
+    }
+
+  entry = current_partition >> 16;
+  
+  /* Get the new partition type.  */
+  arg = skip_to (0, arg);
+  if (! safe_parse_maxint (&arg, &new_type))
+    return 1;
+
+  /* The partition type is unsigned char.  */
+  if (new_type > 0xFF)
+    {
+      errnum = ERR_BAD_ARGUMENT;
+      return 1;
+    }
+
+  /* Get the new partition start.  */
+  arg = skip_to (0, arg);
+  if (! safe_parse_maxint (&arg, &new_start))
+    return 1;
+  
+  /* Get the new partition length.  */
+  arg = skip_to (0, arg);
+  if (! safe_parse_maxint (&arg, &new_len))
+    return 1;
+
+  /* Read the MBR.  */
+  if (! rawread (current_drive, 0, 0, SECTOR_SIZE, mbr))
+    return 1;
+
+  /* Check if the new partition will fit in the disk.  */
+  if (new_start + new_len > buf_geom.total_sectors)
+    {
+      errnum = ERR_GEOM;
+      return 1;
+    }
+
+  /* Store the partition information in the MBR.  */
+  lba_to_chs (new_start, &start_cl, &start_ch, &start_dh);
+  lba_to_chs (new_start + new_len - 1, &end_cl, &end_ch, &end_dh);
+
+  PC_SLICE_FLAG (mbr, entry) = 0;
+  PC_SLICE_HEAD (mbr, entry) = start_dh;
+  PC_SLICE_SEC (mbr, entry) = start_cl;
+  PC_SLICE_CYL (mbr, entry) = start_ch;
+  PC_SLICE_TYPE (mbr, entry) = new_type;
+  PC_SLICE_EHEAD (mbr, entry) = end_dh;
+  PC_SLICE_ESEC (mbr, entry) = end_cl;
+  PC_SLICE_ECYL (mbr, entry) = end_ch;
+  PC_SLICE_START (mbr, entry) = new_start;
+  PC_SLICE_LENGTH (mbr, entry) = new_len;
+
+  /* Make sure that the MBR has a valid signature.  */
+  PC_MBR_SIG (mbr) = PC_MBR_SIGNATURE;
+  
+  /* Write back the MBR to the disk.  */
+  buf_track = -1;
+  if (! rawwrite (current_drive, 0, mbr))
+    return 1;
+
+  return 0;
+}
+
+static struct builtin builtin_partnew =
+{
+  "partnew",
+  partnew_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "partnew PART TYPE START LEN",
+  "Create a primary partition at the starting address START with the"
+  " length LEN, with the type TYPE. START and LEN are in sector units."
+};
+
+
+/* parttype PART TYPE */
+static int
+parttype_func (char *arg, int flags)
+{
+  int new_type;
+  unsigned long part = 0xFFFFFF;
+  unsigned long start, len, offset, ext_offset;
+  int entry, type;
+  char mbr[512];
+
+  /* Get the drive and the partition.  */
+  if (! set_device (arg))
+    return 1;
+
+  /* The drive must be a hard disk.  */
+  if (! (current_drive & 0x80))
+    {
+      errnum = ERR_BAD_ARGUMENT;
+      return 1;
+    }
+  
+  /* The partition must be a PC slice.  */
+  if ((current_partition >> 16) == 0xFF
+      || (current_partition & 0xFFFF) != 0xFFFF)
+    {
+      errnum = ERR_BAD_ARGUMENT;
+      return 1;
+    }
+
+  /* Get the new partition type.  */
+  arg = skip_to (0, arg);
+  if (! safe_parse_maxint (&arg, &new_type))
+    return 1;
+
+  /* The partition type is unsigned char.  */
+  if (new_type > 0xFF)
+    {
+      errnum = ERR_BAD_ARGUMENT;
+      return 1;
+    }
+
+  /* Look for the partition.  */
+  while (next_partition (current_drive, 0xFFFFFF, &part, &type,
+			 &start, &len, &offset, &entry,
+			 &ext_offset, mbr))
+    {
+      if (part == current_partition)
+	{
+	  /* Found.  */
+
+	  /* Set the type to NEW_TYPE.  */
+	  PC_SLICE_TYPE (mbr, entry) = new_type;
+	  
+	  /* Write back the MBR to the disk.  */
+	  buf_track = -1;
+	  if (! rawwrite (current_drive, offset, mbr))
+	    return 1;
+
+	  /* Succeed.  */
+	  return 0;
+	}
+    }
+
+  /* The partition was not found.  ERRNUM was set by next_partition.  */
+  return 1;
+}
+
+static struct builtin builtin_parttype =
+{
+  "parttype",
+  parttype_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "parttype PART TYPE",
+  "Change the type of the partition PART to TYPE."
+};
+
+
+/* password */
+static int
+password_func (char *arg, int flags)
+{
+  int len;
+  password_t type = PASSWORD_PLAIN;
+
+#ifdef USE_MD5_PASSWORDS
+  if (grub_memcmp (arg, "--md5", 5) == 0)
+    {
+      type = PASSWORD_MD5;
+      arg = skip_to (0, arg);
+    }
+#endif
+  if (grub_memcmp (arg, "--", 2) == 0)
+    {
+      type = PASSWORD_UNSUPPORTED;
+      arg = skip_to (0, arg);
+    }
+
+  if ((flags & (BUILTIN_CMDLINE | BUILTIN_SCRIPT)) != 0)
+    {
+      /* Do password check! */
+      char entered[32];
+      
+      /* Wipe out any previously entered password */
+      entered[0] = 0;
+      get_cmdline ("Password: ", entered, 31, '*', 0);
+
+      nul_terminate (arg);
+      if (check_password (entered, arg, type) != 0)
+	{
+	  errnum = ERR_PRIVILEGED;
+	  return 1;
+	}
+    }
+  else
+    {
+      len = grub_strlen (arg);
+      
+      /* PASSWORD NUL NUL ... */
+      if (len + 2 > PASSWORD_BUFLEN)
+	{
+	  errnum = ERR_WONT_FIT;
+	  return 1;
+	}
+      
+      /* Copy the password and clear the rest of the buffer.  */
+      password = (char *) PASSWORD_BUF;
+      grub_memmove (password, arg, len);
+      grub_memset (password + len, 0, PASSWORD_BUFLEN - len);
+      password_type = type;
+    }
+  return 0;
+}
+
+static struct builtin builtin_password =
+{
+  "password",
+  password_func,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_NO_ECHO,
+  "password [--md5] PASSWD [FILE]",
+  "If used in the first section of a menu file, disable all"
+  " interactive editing control (menu entry editor and"
+  " command line). If the password PASSWD is entered, it loads the"
+  " FILE as a new config file and restarts the GRUB Stage 2. If you"
+  " omit the argument FILE, then GRUB just unlocks privileged"
+  " instructions.  You can also use it in the script section, in"
+  " which case it will ask for the password, before continueing."
+  " The option --md5 tells GRUB that PASSWD is encrypted with"
+  " md5crypt."
+};
+
+
+/* pause */
+static int
+pause_func (char *arg, int flags)
+{
+  printf("%s\n", arg);
+
+  /* If ESC is returned, then abort this entry.  */
+  if (ASCII_CHAR (getkey ()) == 27)
+    return 1;
+
+  return 0;
+}
+
+static struct builtin builtin_pause =
+{
+  "pause",
+  pause_func,
+  BUILTIN_CMDLINE | BUILTIN_NO_ECHO,
+  "pause [MESSAGE ...]",
+  "Print MESSAGE, then wait until a key is pressed."
+};
+
+
+#ifdef GRUB_UTIL
+/* quit */
+static int
+quit_func (char *arg, int flags)
+{
+  stop ();
+  
+  /* Never reach here.  */
+  return 0;
+}
+
+static struct builtin builtin_quit =
+{
+  "quit",
+  quit_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "quit",
+  "Exit from the GRUB shell."
+};
+#endif /* GRUB_UTIL */
+
+
+#ifdef SUPPORT_NETBOOT
+/* rarp */
+static int
+rarp_func (char *arg, int flags)
+{
+  if (! rarp ())
+    {
+      if (errnum == ERR_NONE)
+	errnum = ERR_DEV_VALUES;
+
+      return 1;
+    }
+
+  /* Notify the configuration.  */
+  print_network_configuration ();
+  return 0;
+}
+
+static struct builtin builtin_rarp =
+{
+  "rarp",
+  rarp_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "rarp",
+  "Initialize a network device via RARP."
+};
+#endif /* SUPPORT_NETBOOT */
+
+
+static int
+read_func (char *arg, int flags)
+{
+  int addr;
+
+  if (! safe_parse_maxint (&arg, &addr))
+    return 1;
+
+  grub_printf ("Address 0x%x: Value 0x%x\n",
+	       addr, *((unsigned *) RAW_ADDR (addr)));
+  return 0;
+}
+
+static struct builtin builtin_read =
+{
+  "read",
+  read_func,
+  BUILTIN_CMDLINE,
+  "read ADDR",
+  "Read a 32-bit value from memory at address ADDR and"
+  " display it in hex format."
+};
+
+
+/* reboot */
+static int
+reboot_func (char *arg, int flags)
+{
+  grub_reboot ();
+
+  /* Never reach here.  */
+  return 1;
+}
+
+static struct builtin builtin_reboot =
+{
+  "reboot",
+  reboot_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "reboot",
+  "Reboot your system."
+};
+
+
+/* Print the root device information.  */
+static void
+print_root_device (void)
+{
+  if (saved_drive == NETWORK_DRIVE)
+    {
+      /* Network drive.  */
+      grub_printf (" (nd):");
+    }
+  else if (saved_drive & 0x80)
+    {
+      /* Hard disk drive.  */
+      grub_printf (" (hd%d", saved_drive - 0x80);
+      
+      if ((saved_partition & 0xFF0000) != 0xFF0000)
+	grub_printf (",%d", saved_partition >> 16);
+
+      if ((saved_partition & 0x00FF00) != 0x00FF00)
+	grub_printf (",%c", ((saved_partition >> 8) & 0xFF) + 'a');
+
+      grub_printf ("):");
+    }
+  else
+    {
+      /* Floppy disk drive.  */
+      grub_printf (" (fd%d):", saved_drive);
+    }
+
+  /* Print the filesystem information.  */
+  current_partition = saved_partition;
+  current_drive = saved_drive;
+  print_fsys_type ();
+}
+
+static int
+real_root_func (char *arg, int attempt_mount)
+{
+  int hdbias = 0;
+  char *biasptr;
+  char *next;
+
+  /* If ARG is empty, just print the current root device.  */
+  if (! *arg)
+    {
+      print_root_device ();
+      return 0;
+    }
+  
+  /* Call set_device to get the drive and the partition in ARG.  */
+  next = set_device (arg);
+  if (! next)
+    return 1;
+
+  /* Ignore ERR_FSYS_MOUNT.  */
+  if (attempt_mount)
+    {
+      if (! open_device () && errnum != ERR_FSYS_MOUNT)
+	return 1;
+    }
+  else
+    {
+      /* This is necessary, because the location of a partition table
+	 must be set appropriately.  */
+      if (open_partition ())
+	{
+	  set_bootdev (0);
+	  if (errnum)
+	    return 1;
+	}
+    }
+  
+  /* Clear ERRNUM.  */
+  errnum = 0;
+  saved_partition = current_partition;
+  saved_drive = current_drive;
+
+  if (attempt_mount)
+    {
+      /* BSD and chainloading evil hacks !!  */
+      biasptr = skip_to (0, next);
+      safe_parse_maxint (&biasptr, &hdbias);
+      errnum = 0;
+      bootdev = set_bootdev (hdbias);
+      if (errnum)
+	return 1;
+      
+      /* Print the type of the filesystem.  */
+      print_fsys_type ();
+    }
+  
+  return 0;
+}
+
+static int
+root_func (char *arg, int flags)
+{
+  return real_root_func (arg, 1);
+}
+
+static struct builtin builtin_root =
+{
+  "root",
+  root_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "root [DEVICE [HDBIAS]]",
+  "Set the current \"root device\" to the device DEVICE, then"
+  " attempt to mount it to get the partition size (for passing the"
+  " partition descriptor in `ES:ESI', used by some chain-loaded"
+  " bootloaders), the BSD drive-type (for booting BSD kernels using"
+  " their native boot format), and correctly determine "
+  " the PC partition where a BSD sub-partition is located. The"
+  " optional HDBIAS parameter is a number to tell a BSD kernel"
+  " how many BIOS drive numbers are on controllers before the current"
+  " one. For example, if there is an IDE disk and a SCSI disk, and your"
+  " FreeBSD root partition is on the SCSI disk, then use a `1' for HDBIAS."
+};
+
+
+/* rootnoverify */
+static int
+rootnoverify_func (char *arg, int flags)
+{
+  return real_root_func (arg, 0);
+}
+
+static struct builtin builtin_rootnoverify =
+{
+  "rootnoverify",
+  rootnoverify_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "rootnoverify [DEVICE [HDBIAS]]",
+  "Similar to `root', but don't attempt to mount the partition. This"
+  " is useful for when an OS is outside of the area of the disk that"
+  " GRUB can read, but setting the correct root device is still"
+  " desired. Note that the items mentioned in `root' which"
+  " derived from attempting the mount will NOT work correctly."
+};
+
+
+/* savedefault */
+static int
+savedefault_func (char *arg, int flags)
+{
+#if !defined(SUPPORT_DISKLESS) && !defined(GRUB_UTIL)
+  unsigned long tmp_drive = saved_drive;
+  unsigned long tmp_partition = saved_partition;
+  char *default_file = (char *) DEFAULT_FILE_BUF;
+  char buf[10];
+  char sect[SECTOR_SIZE];
+  int entryno;
+  int sector_count = 0;
+  int saved_sectors[2];
+  int saved_offsets[2];
+  int saved_lengths[2];
+
+  /* Save sector information about at most two sectors.  */
+  auto void disk_read_savesect_func (int sector, int offset, int length);
+  void disk_read_savesect_func (int sector, int offset, int length)
+    {
+      if (sector_count < 2)
+	{
+	  saved_sectors[sector_count] = sector;
+	  saved_offsets[sector_count] = offset;
+	  saved_lengths[sector_count] = length;
+	}
+      sector_count++;
+    }
+  
+  /* This command is only useful when you boot an entry from the menu
+     interface.  */
+  if (! (flags & BUILTIN_SCRIPT))
+    {
+      errnum = ERR_UNRECOGNIZED;
+      return 1;
+    }
+
+  /* Determine a saved entry number.  */
+  if (*arg)
+    {
+      if (grub_memcmp (arg, "fallback", sizeof ("fallback") - 1) == 0)
+	{
+	  int i;
+	  int index = 0;
+	  
+	  for (i = 0; i < MAX_FALLBACK_ENTRIES; i++)
+	    {
+	      if (fallback_entries[i] < 0)
+		break;
+	      if (fallback_entries[i] == current_entryno)
+		{
+		  index = i + 1;
+		  break;
+		}
+	    }
+	  
+	  if (index >= MAX_FALLBACK_ENTRIES || fallback_entries[index] < 0)
+	    {
+	      /* This is the last.  */
+	      errnum = ERR_BAD_ARGUMENT;
+	      return 1;
+	    }
+
+	  entryno = fallback_entries[index];
+	}
+      else if (! safe_parse_maxint (&arg, &entryno))
+	return 1;
+    }
+  else
+    entryno = current_entryno;
+
+  /* Open the default file.  */
+  saved_drive = boot_drive;
+  saved_partition = install_partition;
+  if (grub_open (default_file))
+    {
+      int len;
+      
+      disk_read_hook = disk_read_savesect_func;
+      len = grub_read (buf, sizeof (buf));
+      disk_read_hook = 0;
+      grub_close ();
+      
+      if (len != sizeof (buf))
+	{
+	  /* This is too small. Do not modify the file manually, please!  */
+	  errnum = ERR_READ;
+	  goto fail;
+	}
+
+      if (sector_count > 2)
+	{
+	  /* Is this possible?! Too fragmented!  */
+	  errnum = ERR_FSYS_CORRUPT;
+	  goto fail;
+	}
+      
+      /* Set up a string to be written.  */
+      grub_memset (buf, '\n', sizeof (buf));
+      grub_sprintf (buf, "%d", entryno);
+      
+      if (saved_lengths[0] < sizeof (buf))
+	{
+	  /* The file is anchored to another file and the first few bytes
+	     are spanned in two sectors. Uggh...  */
+	  if (! rawread (current_drive, saved_sectors[0], 0, SECTOR_SIZE,
+			 sect))
+	    goto fail;
+	  grub_memmove (sect + saved_offsets[0], buf, saved_lengths[0]);
+	  if (! rawwrite (current_drive, saved_sectors[0], sect))
+	    goto fail;
+
+	  if (! rawread (current_drive, saved_sectors[1], 0, SECTOR_SIZE,
+			 sect))
+	    goto fail;
+	  grub_memmove (sect + saved_offsets[1],
+			buf + saved_lengths[0],
+			sizeof (buf) - saved_lengths[0]);
+	  if (! rawwrite (current_drive, saved_sectors[1], sect))
+	    goto fail;
+	}
+      else
+	{
+	  /* This is a simple case. It fits into a single sector.  */
+	  if (! rawread (current_drive, saved_sectors[0], 0, SECTOR_SIZE,
+			 sect))
+	    goto fail;
+	  grub_memmove (sect + saved_offsets[0], buf, sizeof (buf));
+	  if (! rawwrite (current_drive, saved_sectors[0], sect))
+	    goto fail;
+	}
+
+      /* Clear the cache.  */
+      buf_track = -1;
+    }
+
+ fail:
+  saved_drive = tmp_drive;
+  saved_partition = tmp_partition;
+  return errnum;
+#else /* ! SUPPORT_DISKLESS && ! GRUB_UTIL */
+  errnum = ERR_UNRECOGNIZED;
+  return 1;
+#endif /* ! SUPPORT_DISKLESS && ! GRUB_UTIL */
+}
+
+static struct builtin builtin_savedefault =
+{
+  "savedefault",
+  savedefault_func,
+  BUILTIN_CMDLINE,
+  "savedefault [NUM | `fallback']",
+  "Save the current entry as the default boot entry if no argument is"
+  " specified. If a number is specified, this number is saved. If"
+  " `fallback' is used, next fallback entry is saved."
+};
+
+
+#ifdef SUPPORT_SERIAL
+/* serial */
+static int
+serial_func (char *arg, int flags)
+{
+  unsigned short port = serial_hw_get_port (0);
+  unsigned int speed = 9600;
+  int word_len = UART_8BITS_WORD;
+  int parity = UART_NO_PARITY;
+  int stop_bit_len = UART_1_STOP_BIT;
+
+  /* Process GNU-style long options.
+     FIXME: We should implement a getopt-like function, to avoid
+     duplications.  */
+  while (1)
+    {
+      if (grub_memcmp (arg, "--unit=", sizeof ("--unit=") - 1) == 0)
+	{
+	  char *p = arg + sizeof ("--unit=") - 1;
+	  int unit;
+	  
+	  if (! safe_parse_maxint (&p, &unit))
+	    return 1;
+	  
+	  if (unit < 0 || unit > 3)
+	    {
+	      errnum = ERR_DEV_VALUES;
+	      return 1;
+	    }
+
+	  port = serial_hw_get_port (unit);
+	}
+      else if (grub_memcmp (arg, "--speed=", sizeof ("--speed=") - 1) == 0)
+	{
+	  char *p = arg + sizeof ("--speed=") - 1;
+	  int num;
+	  
+	  if (! safe_parse_maxint (&p, &num))
+	    return 1;
+
+	  speed = (unsigned int) num;
+	}
+      else if (grub_memcmp (arg, "--port=", sizeof ("--port=") - 1) == 0)
+	{
+	  char *p = arg + sizeof ("--port=") - 1;
+	  int num;
+	  
+	  if (! safe_parse_maxint (&p, &num))
+	    return 1;
+
+	  port = (unsigned short) num;
+	}
+      else if (grub_memcmp (arg, "--word=", sizeof ("--word=") - 1) == 0)
+	{
+	  char *p = arg + sizeof ("--word=") - 1;
+	  int len;
+	  
+	  if (! safe_parse_maxint (&p, &len))
+	    return 1;
+
+	  switch (len)
+	    {
+	    case 5: word_len = UART_5BITS_WORD; break;
+	    case 6: word_len = UART_6BITS_WORD; break;
+	    case 7: word_len = UART_7BITS_WORD; break;
+	    case 8: word_len = UART_8BITS_WORD; break;
+	    default:
+	      errnum = ERR_BAD_ARGUMENT;
+	      return 1;
+	    }
+	}
+      else if (grub_memcmp (arg, "--stop=", sizeof ("--stop=") - 1) == 0)
+	{
+	  char *p = arg + sizeof ("--stop=") - 1;
+	  int len;
+	  
+	  if (! safe_parse_maxint (&p, &len))
+	    return 1;
+
+	  switch (len)
+	    {
+	    case 1: stop_bit_len = UART_1_STOP_BIT; break;
+	    case 2: stop_bit_len = UART_2_STOP_BITS; break;
+	    default:
+	      errnum = ERR_BAD_ARGUMENT;
+	      return 1;
+	    }
+	}
+      else if (grub_memcmp (arg, "--parity=", sizeof ("--parity=") - 1) == 0)
+	{
+	  char *p = arg + sizeof ("--parity=") - 1;
+
+	  if (grub_memcmp (p, "no", sizeof ("no") - 1) == 0)
+	    parity = UART_NO_PARITY;
+	  else if (grub_memcmp (p, "odd", sizeof ("odd") - 1) == 0)
+	    parity = UART_ODD_PARITY;
+	  else if (grub_memcmp (p, "even", sizeof ("even") - 1) == 0)
+	    parity = UART_EVEN_PARITY;
+	  else
+	    {
+	      errnum = ERR_BAD_ARGUMENT;
+	      return 1;
+	    }
+	}
+# ifdef GRUB_UTIL
+      /* In the grub shell, don't use any port number but open a tty
+	 device instead.  */
+      else if (grub_memcmp (arg, "--device=", sizeof ("--device=") - 1) == 0)
+	{
+	  char *p = arg + sizeof ("--device=") - 1;
+	  char dev[256];	/* XXX */
+	  char *q = dev;
+	  
+	  while (*p && ! grub_isspace (*p))
+	    *q++ = *p++;
+	  
+	  *q = 0;
+	  serial_set_device (dev);
+	}
+# endif /* GRUB_UTIL */
+      else
+	break;
+
+      arg = skip_to (0, arg);
+    }
+
+  /* Initialize the serial unit.  */
+  if (! serial_hw_init (port, speed, word_len, parity, stop_bit_len))
+    {
+      errnum = ERR_BAD_ARGUMENT;
+      return 1;
+    }
+  
+  return 0;
+}
+
+static struct builtin builtin_serial =
+{
+  "serial",
+  serial_func,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "serial [--unit=UNIT] [--port=PORT] [--speed=SPEED] [--word=WORD] [--parity=PARITY] [--stop=STOP] [--device=DEV]",
+  "Initialize a serial device. UNIT is a digit that specifies which serial"
+  " device is used (e.g. 0 == COM1). If you need to specify the port number,"
+  " set it by --port. SPEED is the DTE-DTE speed. WORD is the word length,"
+  " PARITY is the type of parity, which is one of `no', `odd' and `even'."
+  " STOP is the length of stop bit(s). The option --device can be used only"
+  " in the grub shell, which specifies the file name of a tty device. The"
+  " default values are COM1, 9600, 8N1."
+};
+#endif /* SUPPORT_SERIAL */
+
+
+/* setkey */
+struct keysym
+{
+  char *unshifted_name;			/* the name in unshifted state */
+  char *shifted_name;			/* the name in shifted state */
+  unsigned char unshifted_ascii;	/* the ascii code in unshifted state */
+  unsigned char shifted_ascii;		/* the ascii code in shifted state */
+  unsigned char keycode;		/* keyboard scancode */
+};
+
+/* The table for key symbols. If the "shifted" member of an entry is
+   NULL, the entry does not have shifted state.  */
+static struct keysym keysym_table[] =
+{
+  {"escape",		0,		0x1b,	0,	0x01},
+  {"1",			"exclam",	'1',	'!',	0x02},
+  {"2",			"at",		'2',	'@',	0x03},
+  {"3",			"numbersign",	'3',	'#',	0x04},
+  {"4",			"dollar",	'4',	'$',	0x05},
+  {"5",			"percent",	'5',	'%',	0x06},
+  {"6",			"caret",	'6',	'^',	0x07},
+  {"7",			"ampersand",	'7',	'&',	0x08},
+  {"8",			"asterisk",	'8',	'*',	0x09},
+  {"9",			"parenleft",	'9',	'(',	0x0a},
+  {"0",			"parenright",	'0',	')',	0x0b},
+  {"minus",		"underscore",	'-',	'_',	0x0c},
+  {"equal",		"plus",		'=',	'+',	0x0d},
+  {"backspace",		0,		'\b',	0,	0x0e},
+  {"tab",		0,		'\t',	0,	0x0f},
+  {"q",			"Q",		'q',	'Q',	0x10},
+  {"w",			"W",		'w',	'W',	0x11},
+  {"e",			"E",		'e',	'E',	0x12},
+  {"r",			"R",		'r',	'R',	0x13},
+  {"t",			"T",		't',	'T',	0x14},
+  {"y",			"Y",		'y',	'Y',	0x15},
+  {"u",			"U",		'u',	'U',	0x16},
+  {"i",			"I",		'i',	'I',	0x17},
+  {"o",			"O",		'o',	'O',	0x18},
+  {"p",			"P",		'p',	'P',	0x19},
+  {"bracketleft",	"braceleft",	'[',	'{',	0x1a},
+  {"bracketright",	"braceright",	']',	'}',	0x1b},
+  {"enter",		0,		'\n',	0,	0x1c},
+  {"control",		0,		0,	0,	0x1d},
+  {"a",			"A",		'a',	'A',	0x1e},
+  {"s",			"S",		's',	'S',	0x1f},
+  {"d",			"D",		'd',	'D',	0x20},
+  {"f",			"F",		'f',	'F',	0x21},
+  {"g",			"G",		'g',	'G',	0x22},
+  {"h",			"H",		'h',	'H',	0x23},
+  {"j",			"J",		'j',	'J',	0x24},
+  {"k",			"K",		'k',	'K',	0x25},
+  {"l",			"L",		'l',	'L',	0x26},
+  {"semicolon",		"colon",	';',	':',	0x27},
+  {"quote",		"doublequote",	'\'',	'"',	0x28},
+  {"backquote",		"tilde",	'`',	'~',	0x29},
+  {"shift",		0,		0,	0,	0x2a},
+  {"backslash",		"bar",		'\\',	'|',	0x2b},
+  {"z",			"Z",		'z',	'Z',	0x2c},
+  {"x",			"X",		'x',	'X',	0x2d},
+  {"c",			"C",		'c',	'C',	0x2e},
+  {"v",			"V",		'v',	'V',	0x2f},
+  {"b",			"B",		'b',	'B',	0x30},
+  {"n",			"N",		'n',	'N',	0x31},
+  {"m",			"M",		'm',	'M',	0x32},
+  {"comma",		"less",		',',	'<',	0x33},
+  {"period",		"greater",	'.',	'>',	0x34},
+  {"slash",		"question",	'/',	'?',	0x35},
+  {"alt",		0,		0,	0,	0x38},
+  {"space",		0,		' ',	0,	0x39},
+  {"capslock",		0,		0,	0,	0x3a},
+  {"F1",		0,		0,	0,	0x3b},
+  {"F2",		0,		0,	0,	0x3c},
+  {"F3",		0,		0,	0,	0x3d},
+  {"F4",		0,		0,	0,	0x3e},
+  {"F5",		0,		0,	0,	0x3f},
+  {"F6",		0,		0,	0,	0x40},
+  {"F7",		0,		0,	0,	0x41},
+  {"F8",		0,		0,	0,	0x42},
+  {"F9",		0,		0,	0,	0x43},
+  {"F10",		0,		0,	0,	0x44},
+  /* Caution: do not add NumLock here! we cannot deal with it properly.  */
+  {"delete",		0,		0x7f,	0,	0x53}
+};
+
+static int
+setkey_func (char *arg, int flags)
+{
+  char *to_key, *from_key;
+  int to_code, from_code;
+  int map_in_interrupt = 0;
+  
+  auto int find_key_code (char *key);
+  auto int find_ascii_code (char *key);
+  
+  auto int find_key_code (char *key)
+    {
+      int i;
+
+      for (i = 0; i < sizeof (keysym_table) / sizeof (keysym_table[0]); i++)
+	{
+	  if (keysym_table[i].unshifted_name &&
+	      grub_strcmp (key, keysym_table[i].unshifted_name) == 0)
+	    return keysym_table[i].keycode;
+	  else if (keysym_table[i].shifted_name &&
+		   grub_strcmp (key, keysym_table[i].shifted_name) == 0)
+	    return keysym_table[i].keycode;
+	}
+      
+      return 0;
+    }
+  
+  auto int find_ascii_code (char *key)
+    {
+      int i;
+      
+      for (i = 0; i < sizeof (keysym_table) / sizeof (keysym_table[0]); i++)
+	{
+	  if (keysym_table[i].unshifted_name &&
+	      grub_strcmp (key, keysym_table[i].unshifted_name) == 0)
+	    return keysym_table[i].unshifted_ascii;
+	  else if (keysym_table[i].shifted_name &&
+		   grub_strcmp (key, keysym_table[i].shifted_name) == 0)
+	    return keysym_table[i].shifted_ascii;
+	}
+      
+      return 0;
+    }
+  
+  to_key = arg;
+  from_key = skip_to (0, to_key);
+
+  if (! *to_key)
+    {
+      /* If the user specifies no argument, reset the key mappings.  */
+      grub_memset (bios_key_map, 0, KEY_MAP_SIZE * sizeof (unsigned short));
+      grub_memset (ascii_key_map, 0, KEY_MAP_SIZE * sizeof (unsigned short));
+
+      return 0;
+    }
+  else if (! *from_key)
+    {
+      /* The user must specify two arguments or zero argument.  */
+      errnum = ERR_BAD_ARGUMENT;
+      return 1;
+    }
+  
+  nul_terminate (to_key);
+  nul_terminate (from_key);
+  
+  to_code = find_ascii_code (to_key);
+  from_code = find_ascii_code (from_key);
+  if (! to_code || ! from_code)
+    {
+      map_in_interrupt = 1;
+      to_code = find_key_code (to_key);
+      from_code = find_key_code (from_key);
+      if (! to_code || ! from_code)
+	{
+	  errnum = ERR_BAD_ARGUMENT;
+	  return 1;
+	}
+    }
+  
+  if (map_in_interrupt)
+    {
+      int i;
+      
+      /* Find an empty slot.  */
+      for (i = 0; i < KEY_MAP_SIZE; i++)
+	{
+	  if ((bios_key_map[i] & 0xff) == from_code)
+	    /* Perhaps the user wants to overwrite the map.  */
+	    break;
+	  
+	  if (! bios_key_map[i])
+	    break;
+	}
+      
+      if (i == KEY_MAP_SIZE)
+	{
+	  errnum = ERR_WONT_FIT;
+	  return 1;
+	}
+      
+      if (to_code == from_code)
+	/* If TO is equal to FROM, delete the entry.  */
+	grub_memmove ((char *) &bios_key_map[i],
+		      (char *) &bios_key_map[i + 1],
+		      sizeof (unsigned short) * (KEY_MAP_SIZE - i));
+      else
+	bios_key_map[i] = (to_code << 8) | from_code;
+      
+      /* Ugly but should work.  */
+      unset_int15_handler ();
+      set_int15_handler ();
+    }
+  else
+    {
+      int i;
+      
+      /* Find an empty slot.  */
+      for (i = 0; i < KEY_MAP_SIZE; i++)
+	{
+	  if ((ascii_key_map[i] & 0xff) == from_code)
+	    /* Perhaps the user wants to overwrite the map.  */
+	    break;
+	  
+	  if (! ascii_key_map[i])
+	    break;
+	}
+      
+      if (i == KEY_MAP_SIZE)
+	{
+	  errnum = ERR_WONT_FIT;
+	  return 1;
+	}
+      
+      if (to_code == from_code)
+	/* If TO is equal to FROM, delete the entry.  */
+	grub_memmove ((char *) &ascii_key_map[i],
+		      (char *) &ascii_key_map[i + 1],
+		      sizeof (unsigned short) * (KEY_MAP_SIZE - i));
+      else
+	ascii_key_map[i] = (to_code << 8) | from_code;
+    }
+      
+  return 0;
+}
+
+static struct builtin builtin_setkey =
+{
+  "setkey",
+  setkey_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "setkey [TO_KEY FROM_KEY]",
+  "Change the keyboard map. The key FROM_KEY is mapped to the key TO_KEY."
+  " A key must be an alphabet, a digit, or one of these: escape, exclam,"
+  " at, numbersign, dollar, percent, caret, ampersand, asterisk, parenleft,"
+  " parenright, minus, underscore, equal, plus, backspace, tab, bracketleft,"
+  " braceleft, bracketright, braceright, enter, control, semicolon, colon,"
+  " quote, doublequote, backquote, tilde, shift, backslash, bar, comma,"
+  " less, period, greater, slash, question, alt, space, capslock, FX (X"
+  " is a digit), and delete. If no argument is specified, reset key"
+  " mappings."
+};
+
+
+/* setup */
+static int
+setup_func (char *arg, int flags)
+{
+  /* Point to the string of the installed drive/partition.  */
+  char *install_ptr;
+  /* Point to the string of the drive/parition where the GRUB images
+     reside.  */
+  char *image_ptr;
+  unsigned long installed_drive, installed_partition;
+  unsigned long image_drive, image_partition;
+  unsigned long tmp_drive, tmp_partition;
+  char stage1[64];
+  char stage2[64];
+  char config_filename[64];
+  char real_config_filename[64];
+  char cmd_arg[256];
+  char device[16];
+  char *buffer = (char *) RAW_ADDR (0x100000);
+  int is_force_lba = 0;
+  char *stage2_arg = 0;
+  char *prefix = 0;
+
+  auto int check_file (char *file);
+  auto void sprint_device (int drive, int partition);
+  auto int embed_stage1_5 (char * stage1_5, int drive, int partition);
+  
+  /* Check if the file FILE exists like Autoconf.  */
+  int check_file (char *file)
+    {
+      int ret;
+      
+      grub_printf (" Checking if \"%s\" exists... ", file);
+      ret = grub_open (file);
+      if (ret)
+	{
+	  grub_close ();
+	  grub_printf ("yes\n");
+	}
+      else
+	grub_printf ("no\n");
+
+      return ret;
+    }
+  
+  /* Construct a device name in DEVICE.  */
+  void sprint_device (int drive, int partition)
+    {
+      grub_sprintf (device, "(%cd%d",
+		    (drive & 0x80) ? 'h' : 'f',
+		    drive & ~0x80);
+      if ((partition & 0xFF0000) != 0xFF0000)
+	{
+	  char tmp[16];
+	  grub_sprintf (tmp, ",%d", (partition >> 16) & 0xFF);
+	  grub_strncat (device, tmp, 256);
+	}
+      if ((partition & 0x00FF00) != 0x00FF00)
+	{
+	  char tmp[16];
+	  grub_sprintf (tmp, ",%c", 'a' + ((partition >> 8) & 0xFF));
+	  grub_strncat (device, tmp, 256);
+	}
+      grub_strncat (device, ")", 256);
+    }
+  
+  int embed_stage1_5 (char *stage1_5, int drive, int partition)
+    {
+      /* We install GRUB into the MBR, so try to embed the
+	 Stage 1.5 in the sectors right after the MBR.  */
+      sprint_device (drive, partition);
+      grub_sprintf (cmd_arg, "%s %s", stage1_5, device);
+	      
+      /* Notify what will be run.  */
+      grub_printf (" Running \"embed %s\"... ", cmd_arg);
+      
+      embed_func (cmd_arg, flags);
+      if (! errnum)
+	{
+	  /* Construct the blocklist representation.  */
+	  grub_sprintf (buffer, "%s%s", device, embed_info);
+	  grub_printf ("succeeded\n");
+	  return 1;
+	}
+      else
+	{
+	  grub_printf ("failed (this is not fatal)\n");
+	  return 0;
+	}
+    }
+	  
+  struct stage1_5_map {
+    char *fsys;
+    char *name;
+  };
+  struct stage1_5_map stage1_5_map[] =
+  {
+    {"ext2fs",   "/e2fs_stage1_5"},
+    {"fat",      "/fat_stage1_5"},
+    {"ufs2",     "/ufs2_stage1_5"},
+    {"ffs",      "/ffs_stage1_5"},
+    {"iso9660",  "/iso9660_stage1_5"},
+    {"jfs",      "/jfs_stage1_5"},
+    {"minix",    "/minix_stage1_5"},
+    {"reiserfs", "/reiserfs_stage1_5"},
+    {"vstafs",   "/vstafs_stage1_5"},
+    {"xfs",      "/xfs_stage1_5"}
+  };
+
+  tmp_drive = saved_drive;
+  tmp_partition = saved_partition;
+
+  /* Check if the user specifies --force-lba.  */
+  while (1)
+    {
+      if (grub_memcmp ("--force-lba", arg, sizeof ("--force-lba") - 1) == 0)
+	{
+	  is_force_lba = 1;
+	  arg = skip_to (0, arg);
+	}
+      else if (grub_memcmp ("--prefix=", arg, sizeof ("--prefix=") - 1) == 0)
+	{
+	  prefix = arg + sizeof ("--prefix=") - 1;
+	  arg = skip_to (0, arg);
+	  nul_terminate (prefix);
+	}
+#ifdef GRUB_UTIL
+      else if (grub_memcmp ("--stage2=", arg, sizeof ("--stage2=") - 1) == 0)
+	{
+	  stage2_arg = arg;
+	  arg = skip_to (0, arg);
+	  nul_terminate (stage2_arg);
+	}
+#endif /* GRUB_UTIL */
+      else
+	break;
+    }
+  
+  install_ptr = arg;
+  image_ptr = skip_to (0, install_ptr);
+
+  /* Make sure that INSTALL_PTR is valid.  */
+  set_device (install_ptr);
+  if (errnum)
+    return 1;
+
+  installed_drive = current_drive;
+  installed_partition = current_partition;
+  
+  /* Mount the drive pointed by IMAGE_PTR.  */
+  if (*image_ptr)
+    {
+      /* If the drive/partition where the images reside is specified,
+	 get the drive and the partition.  */
+      set_device (image_ptr);
+      if (errnum)
+	return 1;
+    }
+  else
+    {
+      /* If omitted, use SAVED_PARTITION and SAVED_DRIVE.  */
+      current_drive = saved_drive;
+      current_partition = saved_partition;
+    }
+
+  image_drive = saved_drive = current_drive;
+  image_partition = saved_partition = current_partition;
+
+  /* Open it.  */
+  if (! open_device ())
+    goto fail;
+
+  /* Check if stage1 exists. If the user doesn't specify the option
+     `--prefix', attempt /boot/grub and /grub.  */
+  /* NOTE: It is dangerous to run this command without `--prefix' in the
+     grub shell, since that affects `--stage2'.  */
+  if (! prefix)
+    {
+      prefix = "/boot/grub";
+      grub_sprintf (stage1, "%s%s", prefix, "/stage1");
+      if (! check_file (stage1))
+	{
+	  errnum = ERR_NONE;
+	  prefix = "/grub";
+	  grub_sprintf (stage1, "%s%s", prefix, "/stage1");
+	  if (! check_file (stage1))
+	    goto fail;
+	}
+    }
+  else
+    {
+      grub_sprintf (stage1, "%s%s", prefix, "/stage1");
+      if (! check_file (stage1))
+	goto fail;
+    }
+
+  /* The prefix was determined.  */
+  grub_sprintf (stage2, "%s%s", prefix, "/stage2");
+  grub_sprintf (config_filename, "%s%s", prefix, "/menu.lst");
+  *real_config_filename = 0;
+
+  /* Check if stage2 exists.  */
+  if (! check_file (stage2))
+    goto fail;
+
+  {
+    char *fsys = fsys_table[fsys_type].name;
+    int i;
+    int size = sizeof (stage1_5_map) / sizeof (stage1_5_map[0]);
+    
+    /* Iterate finding the same filesystem name as FSYS.  */
+    for (i = 0; i < size; i++)
+      if (grub_strcmp (fsys, stage1_5_map[i].fsys) == 0)
+	{
+	  /* OK, check if the Stage 1.5 exists.  */
+	  char stage1_5[64];
+	  
+	  grub_sprintf (stage1_5, "%s%s", prefix, stage1_5_map[i].name);
+	  if (check_file (stage1_5))
+	    {
+	      if (embed_stage1_5 (stage1_5, 
+				    installed_drive, installed_partition)
+		  || embed_stage1_5 (stage1_5, 
+				     image_drive, image_partition))
+		{
+		  grub_strcpy (real_config_filename, config_filename);
+		  sprint_device (image_drive, image_partition);
+		  grub_sprintf (config_filename, "%s%s", device, stage2);
+		  grub_strcpy (stage2, buffer);
+		}
+	    }
+	  errnum = 0;
+	  break;
+	}
+  }
+
+  /* force buffer cache invalidation after embedding */
+  buf_drive = -1;
+
+  /* Construct a string that is used by the command "install" as its
+     arguments.  */
+  sprint_device (installed_drive, installed_partition);
+  
+#if 1
+  /* Don't embed a drive number unnecessarily.  */
+  grub_sprintf (cmd_arg, "%s%s%s%s %s%s %s p %s %s",
+		is_force_lba? "--force-lba " : "",
+		stage2_arg? stage2_arg : "",
+		stage2_arg? " " : "",
+		stage1,
+		(installed_drive != image_drive) ? "d " : "",
+		device,
+		stage2,
+		config_filename,
+		real_config_filename);
+#else /* NOT USED */
+  /* This code was used, because we belived some BIOSes had a problem
+     that they didn't pass a booting drive correctly. It turned out,
+     however, stage1 could trash a booting drive when checking LBA support,
+     because some BIOSes modified the register %dx in INT 13H, AH=48H.
+     So it becamed unclear whether GRUB should use a pre-defined booting
+     drive or not. If the problem still exists, it would be necessary to
+     switch back to this code.  */
+  grub_sprintf (cmd_arg, "%s%s%s%s d %s %s p %s %s",
+		is_force_lba? "--force-lba " : "",
+		stage2_arg? stage2_arg : "",
+		stage2_arg? " " : "",
+		stage1,
+		device,
+		stage2,
+		config_filename,
+		real_config_filename);
+#endif /* NOT USED */
+  
+  /* Notify what will be run.  */
+  grub_printf (" Running \"install %s\"... ", cmd_arg);
+
+  /* Make sure that SAVED_DRIVE and SAVED_PARTITION are identical
+     with IMAGE_DRIVE and IMAGE_PARTITION, respectively.  */
+  saved_drive = image_drive;
+  saved_partition = image_partition;
+  
+  /* Run the command.  */
+  if (! install_func (cmd_arg, flags))
+    grub_printf ("succeeded\nDone.\n");
+  else
+    grub_printf ("failed\n");
+
+ fail:
+  saved_drive = tmp_drive;
+  saved_partition = tmp_partition;
+  return errnum;
+}
+
+static struct builtin builtin_setup =
+{
+  "setup",
+  setup_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "setup [--prefix=DIR] [--stage2=STAGE2_FILE] [--force-lba] INSTALL_DEVICE [IMAGE_DEVICE]",
+  "Set up the installation of GRUB automatically. This command uses"
+  " the more flexible command \"install\" in the backend and installs"
+  " GRUB into the device INSTALL_DEVICE. If IMAGE_DEVICE is specified,"
+  " then find the GRUB images in the device IMAGE_DEVICE, otherwise"
+  " use the current \"root device\", which can be set by the command"
+  " \"root\". If you know that your BIOS should support LBA but GRUB"
+  " doesn't work in LBA mode, specify the option `--force-lba'."
+  " If you install GRUB under the grub shell and you cannot unmount the"
+  " partition where GRUB images reside, specify the option `--stage2'"
+  " to tell GRUB the file name under your OS."
+};
+
+
+#if defined(SUPPORT_SERIAL) || defined(SUPPORT_HERCULES)
+/* terminal */
+static int
+terminal_func (char *arg, int flags)
+{
+  /* The index of the default terminal in TERM_TABLE.  */
+  int default_term = -1;
+  struct term_entry *prev_term = current_term;
+  int to = -1;
+  int lines = 0;
+  int no_message = 0;
+  unsigned long term_flags = 0;
+  /* XXX: Assume less than 32 terminals.  */
+  unsigned long term_bitmap = 0;
+
+  /* Get GNU-style long options.  */
+  while (1)
+    {
+      if (grub_memcmp (arg, "--dumb", sizeof ("--dumb") - 1) == 0)
+	term_flags |= TERM_DUMB;
+      else if (grub_memcmp (arg, "--no-echo", sizeof ("--no-echo") - 1) == 0)
+	/* ``--no-echo'' implies ``--no-edit''.  */
+	term_flags |= (TERM_NO_ECHO | TERM_NO_EDIT);
+      else if (grub_memcmp (arg, "--no-edit", sizeof ("--no-edit") - 1) == 0)
+	term_flags |= TERM_NO_EDIT;
+      else if (grub_memcmp (arg, "--timeout=", sizeof ("--timeout=") - 1) == 0)
+	{
+	  char *val = arg + sizeof ("--timeout=") - 1;
+	  
+	  if (! safe_parse_maxint (&val, &to))
+	    return 1;
+	}
+      else if (grub_memcmp (arg, "--lines=", sizeof ("--lines=") - 1) == 0)
+	{
+	  char *val = arg + sizeof ("--lines=") - 1;
+
+	  if (! safe_parse_maxint (&val, &lines))
+	    return 1;
+
+	  /* Probably less than four is meaningless....  */
+	  if (lines < 4)
+	    {
+	      errnum = ERR_BAD_ARGUMENT;
+	      return 1;
+	    }
+	}
+      else if (grub_memcmp (arg, "--silent", sizeof ("--silent") - 1) == 0)
+	no_message = 1;
+      else
+	break;
+
+      arg = skip_to (0, arg);
+    }
+  
+  /* If no argument is specified, show current setting.  */
+  if (! *arg)
+    {
+      grub_printf ("%s%s%s%s\n",
+		   current_term->name,
+		   current_term->flags & TERM_DUMB ? " (dumb)" : "",
+		   current_term->flags & TERM_NO_EDIT ? " (no edit)" : "",
+		   current_term->flags & TERM_NO_ECHO ? " (no echo)" : "");
+      return 0;
+    }
+
+  while (*arg)
+    {
+      int i;
+      char *next = skip_to (0, arg);
+      
+      nul_terminate (arg);
+
+      for (i = 0; term_table[i].name; i++)
+	{
+	  if (grub_strcmp (arg, term_table[i].name) == 0)
+	    {
+	      if (term_table[i].flags & TERM_NEED_INIT)
+		{
+		  errnum = ERR_DEV_NEED_INIT;
+		  return 1;
+		}
+	      
+	      if (default_term < 0)
+		default_term = i;
+
+	      term_bitmap |= (1 << i);
+	      break;
+	    }
+	}
+
+      if (! term_table[i].name)
+	{
+	  errnum = ERR_BAD_ARGUMENT;
+	  return 1;
+	}
+
+      arg = next;
+    }
+
+  /* If multiple terminals are specified, wait until the user pushes any
+     key on one of the terminals.  */
+  if (term_bitmap & ~(1 << default_term))
+    {
+      int time1, time2 = -1;
+
+      /* XXX: Disable the pager.  */
+      count_lines = -1;
+      
+      /* Get current time.  */
+      while ((time1 = getrtsecs ()) == 0xFF)
+	;
+
+      /* Wait for a key input.  */
+      while (to)
+	{
+	  int i;
+
+	  for (i = 0; term_table[i].name; i++)
+	    {
+	      if (term_bitmap & (1 << i))
+		{
+		  if (term_table[i].checkkey () >= 0)
+		    {
+		      (void) term_table[i].getkey ();
+		      default_term = i;
+		      
+		      goto end;
+		    }
+		}
+	    }
+	  
+	  /* Prompt the user, once per sec.  */
+	  if ((time1 = getrtsecs ()) != time2 && time1 != 0xFF)
+	    {
+	      if (! no_message)
+		{
+		  /* Need to set CURRENT_TERM to each of selected
+		     terminals.  */
+		  for (i = 0; term_table[i].name; i++)
+		    if (term_bitmap & (1 << i))
+		      {
+			current_term = term_table + i;
+			grub_printf ("\rPress any key to continue.\n");
+		      }
+		  
+		  /* Restore CURRENT_TERM.  */
+		  current_term = prev_term;
+		}
+	      
+	      time2 = time1;
+	      if (to > 0)
+		to--;
+	    }
+	}
+    }
+
+ end:
+  current_term = term_table + default_term;
+  current_term->flags = term_flags;
+  
+  if (lines)
+    max_lines = lines;
+  else
+    /* 24 would be a good default value.  */
+    max_lines = 24;
+  
+  /* If the interface is currently the command-line,
+     restart it to repaint the screen.  */
+  if (current_term != prev_term && (flags & BUILTIN_CMDLINE))
+    grub_longjmp (restart_cmdline_env, 0);
+  
+  return 0;
+}
+
+static struct builtin builtin_terminal =
+{
+  "terminal",
+  terminal_func,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "terminal [--dumb] [--no-echo] [--no-edit] [--timeout=SECS] [--lines=LINES] [--silent] [console] [serial] [hercules]",
+  "Select a terminal. When multiple terminals are specified, wait until"
+  " you push any key to continue. If both console and serial are specified,"
+  " the terminal to which you input a key first will be selected. If no"
+  " argument is specified, print current setting. The option --dumb"
+  " specifies that your terminal is dumb, otherwise, vt100-compatibility"
+  " is assumed. If you specify --no-echo, input characters won't be echoed."
+  " If you specify --no-edit, the BASH-like editing feature will be disabled."
+  " If --timeout is present, this command will wait at most for SECS"
+  " seconds. The option --lines specifies the maximum number of lines."
+  " The option --silent is used to suppress messages."
+};
+#endif /* SUPPORT_SERIAL || SUPPORT_HERCULES */
+
+
+#ifdef SUPPORT_SERIAL
+static int
+terminfo_func (char *arg, int flags)
+{
+  struct terminfo term;
+
+  if (*arg)
+    {
+      struct
+      {
+	const char *name;
+	char *var;
+      }
+      options[] =
+	{
+	  {"--name=", term.name},
+	  {"--cursor-address=", term.cursor_address},
+	  {"--clear-screen=", term.clear_screen},
+	  {"--enter-standout-mode=", term.enter_standout_mode},
+	  {"--exit-standout-mode=", term.exit_standout_mode}
+	};
+
+      grub_memset (&term, 0, sizeof (term));
+      
+      while (*arg)
+	{
+	  int i;
+	  char *next = skip_to (0, arg);
+	      
+	  nul_terminate (arg);
+	  
+	  for (i = 0; i < sizeof (options) / sizeof (options[0]); i++)
+	    {
+	      const char *name = options[i].name;
+	      int len = grub_strlen (name);
+	      
+	      if (! grub_memcmp (arg, name, len))
+		{
+		  grub_strcpy (options[i].var, ti_unescape_string (arg + len));
+		  break;
+		}
+	    }
+
+	  if (i == sizeof (options) / sizeof (options[0]))
+	    {
+	      errnum = ERR_BAD_ARGUMENT;
+	      return errnum;
+	    }
+
+	  arg = next;
+	}
+
+      if (term.name[0] == 0 || term.cursor_address[0] == 0)
+	{
+	  errnum = ERR_BAD_ARGUMENT;
+	  return errnum;
+	}
+
+      ti_set_term (&term);
+    }
+  else
+    {
+      /* No option specifies printing out current settings.  */
+      ti_get_term (&term);
+
+      grub_printf ("name=%s\n",
+		   ti_escape_string (term.name));
+      grub_printf ("cursor_address=%s\n",
+		   ti_escape_string (term.cursor_address));
+      grub_printf ("clear_screen=%s\n",
+		   ti_escape_string (term.clear_screen));
+      grub_printf ("enter_standout_mode=%s\n",
+		   ti_escape_string (term.enter_standout_mode));
+      grub_printf ("exit_standout_mode=%s\n",
+		   ti_escape_string (term.exit_standout_mode));
+    }
+
+  return 0;
+}
+
+static struct builtin builtin_terminfo =
+{
+  "terminfo",
+  terminfo_func,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "terminfo [--name=NAME --cursor-address=SEQ [--clear-screen=SEQ]"
+  " [--enter-standout-mode=SEQ] [--exit-standout-mode=SEQ]]",
+  
+  "Define the capabilities of your terminal. Use this command to"
+  " define escape sequences, if it is not vt100-compatible."
+  " You may use \\e for ESC and ^X for a control character."
+  " If no option is specified, the current settings are printed."
+};
+#endif /* SUPPORT_SERIAL */
+	  
+
+/* testload */
+static int
+testload_func (char *arg, int flags)
+{
+  int i;
+
+  kernel_type = KERNEL_TYPE_NONE;
+
+  if (! grub_open (arg))
+    return 1;
+
+  disk_read_hook = disk_read_print_func;
+
+  /* Perform filesystem test on the specified file.  */
+  /* Read whole file first. */
+  grub_printf ("Whole file: ");
+
+  grub_read ((char *) RAW_ADDR (0x100000), -1);
+
+  /* Now compare two sections of the file read differently.  */
+
+  for (i = 0; i < 0x10ac0; i++)
+    {
+      *((unsigned char *) RAW_ADDR (0x200000 + i)) = 0;
+      *((unsigned char *) RAW_ADDR (0x300000 + i)) = 1;
+    }
+
+  /* First partial read.  */
+  grub_printf ("\nPartial read 1: ");
+
+  grub_seek (0);
+  grub_read ((char *) RAW_ADDR (0x200000), 0x7);
+  grub_read ((char *) RAW_ADDR (0x200007), 0x100);
+  grub_read ((char *) RAW_ADDR (0x200107), 0x10);
+  grub_read ((char *) RAW_ADDR (0x200117), 0x999);
+  grub_read ((char *) RAW_ADDR (0x200ab0), 0x10);
+  grub_read ((char *) RAW_ADDR (0x200ac0), 0x10000);
+
+  /* Second partial read.  */
+  grub_printf ("\nPartial read 2: ");
+
+  grub_seek (0);
+  grub_read ((char *) RAW_ADDR (0x300000), 0x10000);
+  grub_read ((char *) RAW_ADDR (0x310000), 0x10);
+  grub_read ((char *) RAW_ADDR (0x310010), 0x7);
+  grub_read ((char *) RAW_ADDR (0x310017), 0x10);
+  grub_read ((char *) RAW_ADDR (0x310027), 0x999);
+  grub_read ((char *) RAW_ADDR (0x3109c0), 0x100);
+
+  grub_printf ("\nHeader1 = 0x%x, next = 0x%x, next = 0x%x, next = 0x%x\n",
+	       *((int *) RAW_ADDR (0x200000)),
+	       *((int *) RAW_ADDR (0x200004)),
+	       *((int *) RAW_ADDR (0x200008)),
+	       *((int *) RAW_ADDR (0x20000c)));
+
+  grub_printf ("Header2 = 0x%x, next = 0x%x, next = 0x%x, next = 0x%x\n",
+	       *((int *) RAW_ADDR (0x300000)),
+	       *((int *) RAW_ADDR (0x300004)),
+	       *((int *) RAW_ADDR (0x300008)),
+	       *((int *) RAW_ADDR (0x30000c)));
+
+  for (i = 0; i < 0x10ac0; i++)
+    if (*((unsigned char *) RAW_ADDR (0x200000 + i))
+	!= *((unsigned char *) RAW_ADDR (0x300000 + i)))
+      break;
+
+  grub_printf ("Max is 0x10ac0: i=0x%x, filepos=0x%x\n", i, filepos);
+  disk_read_hook = 0;
+  grub_close ();
+  return 0;
+}
+
+static struct builtin builtin_testload =
+{
+  "testload",
+  testload_func,
+  BUILTIN_CMDLINE,
+  "testload FILE",
+  "Read the entire contents of FILE in several different ways and"
+  " compares them, to test the filesystem code. The output is somewhat"
+  " cryptic, but if no errors are reported and the final `i=X,"
+  " filepos=Y' reading has X and Y equal, then it is definitely"
+  " consistent, and very likely works correctly subject to a"
+  " consistent offset error. If this test succeeds, then a good next"
+  " step is to try loading a kernel."
+};
+
+
+/* testvbe MODE */
+static int
+testvbe_func (char *arg, int flags)
+{
+  int mode_number;
+  struct vbe_controller controller;
+  struct vbe_mode mode;
+  
+  if (! *arg)
+    {
+      errnum = ERR_BAD_ARGUMENT;
+      return 1;
+    }
+
+  if (! safe_parse_maxint (&arg, &mode_number))
+    return 1;
+
+  /* Preset `VBE2'.  */
+  grub_memmove (controller.signature, "VBE2", 4);
+
+  /* Detect VBE BIOS.  */
+  if (get_vbe_controller_info (&controller) != 0x004F)
+    {
+      grub_printf (" VBE BIOS is not present.\n");
+      return 0;
+    }
+  
+  if (controller.version < 0x0200)
+    {
+      grub_printf (" VBE version %d.%d is not supported.\n",
+		   (int) (controller.version >> 8),
+		   (int) (controller.version & 0xFF));
+      return 0;
+    }
+
+  if (get_vbe_mode_info (mode_number, &mode) != 0x004F
+      || (mode.mode_attributes & 0x0091) != 0x0091)
+    {
+      grub_printf (" Mode 0x%x is not supported.\n", mode_number);
+      return 0;
+    }
+
+  /* Now trip to the graphics mode.  */
+  if (set_vbe_mode (mode_number | (1 << 14)) != 0x004F)
+    {
+      grub_printf (" Switching to Mode 0x%x failed.\n", mode_number);
+      return 0;
+    }
+
+  /* Draw something on the screen...  */
+  {
+    unsigned char *base_buf = (unsigned char *) mode.phys_base;
+    int scanline = controller.version >= 0x0300
+      ? mode.linear_bytes_per_scanline : mode.bytes_per_scanline;
+    /* FIXME: this assumes that any depth is a modulo of 8.  */
+    int bpp = mode.bits_per_pixel / 8;
+    int width = mode.x_resolution;
+    int height = mode.y_resolution;
+    int x, y;
+    unsigned color = 0;
+
+    /* Iterate drawing on the screen, until the user hits any key.  */
+    while (checkkey () == -1)
+      {
+	for (y = 0; y < height; y++)
+	  {
+	    unsigned char *line_buf = base_buf + scanline * y;
+	    
+	    for (x = 0; x < width; x++)
+	      {
+		unsigned char *buf = line_buf + bpp * x;
+		int i;
+
+		for (i = 0; i < bpp; i++, buf++)
+		  *buf = (color >> (i * 8)) & 0xff;
+	      }
+
+	    color++;
+	  }
+      }
+
+    /* Discard the input.  */
+    getkey ();
+  }
+  
+  /* Back to the default text mode.  */
+  if (set_vbe_mode (0x03) != 0x004F)
+    {
+      /* Why?!  */
+      grub_reboot ();
+    }
+
+  return 0;
+}
+
+static struct builtin builtin_testvbe =
+{
+  "testvbe",
+  testvbe_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "testvbe MODE",
+  "Test the VBE mode MODE. Hit any key to return."
+};
+
+
+#ifdef SUPPORT_NETBOOT
+/* tftpserver */
+static int
+tftpserver_func (char *arg, int flags)
+{
+  if (! *arg || ! ifconfig (0, 0, 0, arg))
+    {
+      errnum = ERR_BAD_ARGUMENT;
+      return 1;
+    }
+
+  print_network_configuration ();
+  return 0;
+}
+
+static struct builtin builtin_tftpserver =
+{
+  "tftpserver",
+  tftpserver_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "tftpserver IPADDR",
+  "Override the TFTP server address."
+};
+#endif /* SUPPORT_NETBOOT */
+
+
+/* timeout */
+static int
+timeout_func (char *arg, int flags)
+{
+  if (! safe_parse_maxint (&arg, &grub_timeout))
+    return 1;
+
+  return 0;
+}
+
+static struct builtin builtin_timeout =
+{
+  "timeout",
+  timeout_func,
+  BUILTIN_MENU,
+#if 0
+  "timeout SEC",
+  "Set a timeout, in SEC seconds, before automatically booting the"
+  " default entry (normally the first entry defined)."
+#endif
+};
+
+
+/* title */
+static int
+title_func (char *arg, int flags)
+{
+  /* This function is not actually used at least currently.  */
+  return 0;
+}
+
+static struct builtin builtin_title =
+{
+  "title",
+  title_func,
+  BUILTIN_TITLE,
+#if 0
+  "title [NAME ...]",
+  "Start a new boot entry, and set its name to the contents of the"
+  " rest of the line, starting with the first non-space character."
+#endif
+};
+
+
+/* unhide */
+static int
+unhide_func (char *arg, int flags)
+{
+  if (! set_device (arg))
+    return 1;
+
+  if (! set_partition_hidden_flag (0))
+    return 1;
+
+  return 0;
+}
+
+static struct builtin builtin_unhide =
+{
+  "unhide",
+  unhide_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "unhide PARTITION",
+  "Unhide PARTITION by clearing the \"hidden\" bit in its"
+  " partition type code."
+};
+
+
+/* uppermem */
+static int
+uppermem_func (char *arg, int flags)
+{
+  if (! safe_parse_maxint (&arg, (int *) &mbi.mem_upper))
+    return 1;
+
+  mbi.flags &= ~MB_INFO_MEM_MAP;
+  return 0;
+}
+
+static struct builtin builtin_uppermem =
+{
+  "uppermem",
+  uppermem_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "uppermem KBYTES",
+  "Force GRUB to assume that only KBYTES kilobytes of upper memory are"
+  " installed.  Any system address range maps are discarded."
+};
+
+
+/* vbeprobe */
+static int
+vbeprobe_func (char *arg, int flags)
+{
+  struct vbe_controller controller;
+  unsigned short *mode_list;
+  int mode_number = -1;
+  
+  auto unsigned long vbe_far_ptr_to_linear (unsigned long);
+  
+  unsigned long vbe_far_ptr_to_linear (unsigned long ptr)
+    {
+      unsigned short seg = (ptr >> 16);
+      unsigned short off = (ptr & 0xFFFF);
+
+      return (seg << 4) + off;
+    }
+  
+  if (*arg)
+    {
+      if (! safe_parse_maxint (&arg, &mode_number))
+	return 1;
+    }
+  
+  /* Set the signature to `VBE2', to obtain VBE 3.0 information.  */
+  grub_memmove (controller.signature, "VBE2", 4);
+  
+  if (get_vbe_controller_info (&controller) != 0x004F)
+    {
+      grub_printf (" VBE BIOS is not present.\n");
+      return 0;
+    }
+
+  /* Check the version.  */
+  if (controller.version < 0x0200)
+    {
+      grub_printf (" VBE version %d.%d is not supported.\n",
+		   (int) (controller.version >> 8),
+		   (int) (controller.version & 0xFF));
+      return 0;
+    }
+
+  /* Print some information.  */
+  grub_printf (" VBE version %d.%d\n",
+	       (int) (controller.version >> 8),
+	       (int) (controller.version & 0xFF));
+
+  /* Iterate probing modes.  */
+  for (mode_list
+	 = (unsigned short *) vbe_far_ptr_to_linear (controller.video_mode);
+       *mode_list != 0xFFFF;
+       mode_list++)
+    {
+      struct vbe_mode mode;
+      
+      if (get_vbe_mode_info (*mode_list, &mode) != 0x004F)
+	continue;
+
+      /* Skip this, if this is not supported or linear frame buffer
+	 mode is not support.  */
+      if ((mode.mode_attributes & 0x0081) != 0x0081)
+	continue;
+
+      if (mode_number == -1 || mode_number == *mode_list)
+	{
+	  char *model;
+	  switch (mode.memory_model)
+	    {
+	    case 0x00: model = "Text"; break;
+	    case 0x01: model = "CGA graphics"; break;
+	    case 0x02: model = "Hercules graphics"; break;
+	    case 0x03: model = "Planar"; break;
+	    case 0x04: model = "Packed pixel"; break;
+	    case 0x05: model = "Non-chain 4, 256 color"; break;
+	    case 0x06: model = "Direct Color"; break;
+	    case 0x07: model = "YUV"; break;
+	    default: model = "Unknown"; break;
+	    }
+	  
+	  grub_printf ("  0x%x: %s, %ux%ux%u\n",
+		       (unsigned) *mode_list,
+		       model,
+		       (unsigned) mode.x_resolution,
+		       (unsigned) mode.y_resolution,
+		       (unsigned) mode.bits_per_pixel);
+	  
+	  if (mode_number != -1)
+	    break;
+	}
+    }
+
+  if (mode_number != -1 && mode_number != *mode_list)
+    grub_printf ("  Mode 0x%x is not found or supported.\n", mode_number);
+  
+  return 0;
+}
+
+static struct builtin builtin_vbeprobe =
+{
+  "vbeprobe",
+  vbeprobe_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "vbeprobe [MODE]",
+  "Probe VBE information. If the mode number MODE is specified, show only"
+  " the information about only the mode."
+};
+  
+
+/* The table of builtin commands. Sorted in dictionary order.  */
+struct builtin *builtin_table[] =
+{
+  &builtin_blocklist,
+  &builtin_boot,
+#ifdef SUPPORT_NETBOOT
+  &builtin_bootp,
+#endif /* SUPPORT_NETBOOT */
+  &builtin_cat,
+  &builtin_chainloader,
+  &builtin_cmp,
+  &builtin_color,
+  &builtin_configfile,
+  &builtin_debug,
+  &builtin_default,
+#ifdef GRUB_UTIL
+  &builtin_device,
+#endif /* GRUB_UTIL */
+#ifdef SUPPORT_NETBOOT
+  &builtin_dhcp,
+#endif /* SUPPORT_NETBOOT */
+  &builtin_displayapm,
+  &builtin_displaymem,
+#ifdef GRUB_UTIL
+  &builtin_dump,
+#endif /* GRUB_UTIL */
+  &builtin_embed,
+  &builtin_fallback,
+  &builtin_find,
+  &builtin_fstest,
+  &builtin_geometry,
+  &builtin_gfxmenu,
+  &builtin_halt,
+  &builtin_help,
+  &builtin_hiddenmenu,
+  &builtin_hide,
+#ifdef SUPPORT_NETBOOT
+  &builtin_ifconfig,
+#endif /* SUPPORT_NETBOOT */
+  &builtin_impsprobe,
+  &builtin_initrd,
+  &builtin_install,
+  &builtin_ioprobe,
+  &builtin_kernel,
+  &builtin_lock,
+  &builtin_makeactive,
+  &builtin_map,
+#ifdef USE_MD5_PASSWORDS
+  &builtin_md5crypt,
+#endif /* USE_MD5_PASSWORDS */
+  &builtin_module,
+  &builtin_modulenounzip,
+  &builtin_pager,
+  &builtin_partnew,
+  &builtin_parttype,
+  &builtin_password,
+  &builtin_pause,
+#ifdef GRUB_UTIL
+  &builtin_quit,
+#endif /* GRUB_UTIL */
+#ifdef SUPPORT_NETBOOT
+  &builtin_rarp,
+#endif /* SUPPORT_NETBOOT */
+  &builtin_read,
+  &builtin_reboot,
+  &builtin_root,
+  &builtin_rootnoverify,
+  &builtin_savedefault,
+#ifdef SUPPORT_SERIAL
+  &builtin_serial,
+#endif /* SUPPORT_SERIAL */
+  &builtin_setkey,
+  &builtin_setup,
+#if defined(SUPPORT_SERIAL) || defined(SUPPORT_HERCULES)
+  &builtin_terminal,
+#endif /* SUPPORT_SERIAL || SUPPORT_HERCULES */
+#ifdef SUPPORT_SERIAL
+  &builtin_terminfo,
+#endif /* SUPPORT_SERIAL */
+  &builtin_testload,
+  &builtin_testvbe,
+#ifdef SUPPORT_NETBOOT
+  &builtin_tftpserver,
+#endif /* SUPPORT_NETBOOT */
+  &builtin_timeout,
+  &builtin_title,
+  &builtin_unhide,
+  &builtin_uppermem,
+  &builtin_vbeprobe,
+  0
+};
diff -Naur grub-0.97/stage2/disk_io.c grub-0.97-suse/stage2/disk_io.c
--- grub-0.97/stage2/disk_io.c	2004-05-23 13:35:24.000000000 -0300
+++ grub-0.97-suse/stage2/disk_io.c	2006-09-09 17:00:12.000000000 -0300
@@ -128,7 +128,7 @@
 int filemax;
 
 static inline unsigned long
-log2 (unsigned long word)
+grub_log2 (unsigned long word)
 {
   asm volatile ("bsfl %1,%0"
 		: "=r" (word)
@@ -140,7 +140,7 @@
 rawread (int drive, int sector, int byte_offset, int byte_len, char *buf)
 {
   int slen, sectors_per_vtrack;
-  int sector_size_bits = log2 (buf_geom.sector_size);
+  int sector_size_bits = grub_log2 (buf_geom.sector_size);
 
   if (byte_len <= 0)
     return 1;
@@ -163,7 +163,7 @@
 	    }
 	  buf_drive = drive;
 	  buf_track = -1;
-	  sector_size_bits = log2 (buf_geom.sector_size);
+	  sector_size_bits = grub_log2 (buf_geom.sector_size);
 	}
 
       /* Make sure that SECTOR is valid.  */
diff -Naur grub-0.97/stage2/filesys.h grub-0.97-suse/stage2/filesys.h
--- grub-0.97/stage2/filesys.h	2004-05-14 16:36:43.000000000 -0300
+++ grub-0.97-suse/stage2/filesys.h	2006-09-09 17:00:12.000000000 -0300
@@ -73,6 +73,16 @@
 int reiserfs_read (char *buf, int len);
 int reiserfs_dir (char *dirname);
 int reiserfs_embed (int *start_sector, int needed_sectors);
+#if defined(__linux__) && defined (GRUB_UTIL)
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/statfs.h>
+#include <fcntl.h>
+/* from <linux/reiserfs_fs.h> */
+#define REISERFS_SUPER_MAGIC 0x52654973
+#define REISERFS_IOC_UNPACK  _IOW(0xCD,1,long)
+#endif
 #else
 #define FSYS_REISERFS_NUM 0
 #endif
diff -Naur grub-0.97/stage2/fsys_ext2fs.c grub-0.97-suse/stage2/fsys_ext2fs.c
--- grub-0.97/stage2/fsys_ext2fs.c	2004-08-08 15:19:18.000000000 -0300
+++ grub-0.97-suse/stage2/fsys_ext2fs.c	2006-09-09 17:00:12.000000000 -0300
@@ -193,7 +193,7 @@
 
 
 /* ext2/super.c */
-#define log2(n) ffz(~(n))
+#define grub_log2(n) ffz(~(n))
 
 #define EXT2_SUPER_MAGIC      0xEF53	/* include/linux/ext2_fs.h */
 #define EXT2_ROOT_INO              2	/* include/linux/ext2_fs.h */
@@ -216,7 +216,7 @@
 
 /* linux/ext2_fs.h */
 #define EXT2_ADDR_PER_BLOCK(s)          (EXT2_BLOCK_SIZE(s) / sizeof (__u32))
-#define EXT2_ADDR_PER_BLOCK_BITS(s)		(log2(EXT2_ADDR_PER_BLOCK(s)))
+#define EXT2_ADDR_PER_BLOCK_BITS(s)		(grub_log2(EXT2_ADDR_PER_BLOCK(s)))
 
 /* linux/ext2_fs.h */
 #define EXT2_BLOCK_SIZE_BITS(s)        ((s)->s_log_block_size + 10)
@@ -537,7 +537,7 @@
 
       /* look up an inode */
       group_id = (current_ino - 1) / (SUPERBLOCK->s_inodes_per_group);
-      group_desc = group_id >> log2 (EXT2_DESC_PER_BLOCK (SUPERBLOCK));
+      group_desc = group_id >> grub_log2 (EXT2_DESC_PER_BLOCK (SUPERBLOCK));
       desc = group_id & (EXT2_DESC_PER_BLOCK (SUPERBLOCK) - 1);
 #ifdef E2DEBUG
       printf ("ipg=%d, dpb=%d\n", SUPERBLOCK->s_inodes_per_group,
@@ -553,7 +553,7 @@
       gdp = GROUP_DESC;
       ino_blk = gdp[desc].bg_inode_table +
 	(((current_ino - 1) % (SUPERBLOCK->s_inodes_per_group))
-	 >> log2 (EXT2_BLOCK_SIZE (SUPERBLOCK) / sizeof (struct ext2_inode)));
+	 >> grub_log2 (EXT2_BLOCK_SIZE (SUPERBLOCK) / sizeof (struct ext2_inode)));
 #ifdef E2DEBUG
       printf ("inode table fsblock=%d\n", ino_blk);
 #endif /* E2DEBUG */
diff -Naur grub-0.97/stage2/fsys_fat.c grub-0.97-suse/stage2/fsys_fat.c
--- grub-0.97/stage2/fsys_fat.c	2005-03-15 13:52:00.000000000 -0300
+++ grub-0.97-suse/stage2/fsys_fat.c	2006-09-09 17:00:12.000000000 -0300
@@ -55,7 +55,7 @@
 #define FAT_CACHE_SIZE 2048
 
 static __inline__ unsigned long
-log2 (unsigned long word)
+grub_log2 (unsigned long word)
 {
   __asm__ ("bsfl %1,%0"
 	   : "=r" (word)
@@ -84,9 +84,9 @@
   if (bpb.sects_per_clust == 0)
     return 0;
   
-  FAT_SUPER->sectsize_bits = log2 (FAT_CVT_U16 (bpb.bytes_per_sect));
+  FAT_SUPER->sectsize_bits = grub_log2 (FAT_CVT_U16 (bpb.bytes_per_sect));
   FAT_SUPER->clustsize_bits
-    = FAT_SUPER->sectsize_bits + log2 (bpb.sects_per_clust);
+    = FAT_SUPER->sectsize_bits + grub_log2 (bpb.sects_per_clust);
   
   /* Fill in info about super block */
   FAT_SUPER->num_sectors = FAT_CVT_U16 (bpb.short_sectors) 
diff -Naur grub-0.97/stage2/fsys_iso9660.c grub-0.97-suse/stage2/fsys_iso9660.c
--- grub-0.97/stage2/fsys_iso9660.c	2004-05-11 09:11:19.000000000 -0300
+++ grub-0.97-suse/stage2/fsys_iso9660.c	2006-09-09 17:00:12.000000000 -0300
@@ -57,7 +57,7 @@
 
 
 static inline unsigned long
-log2 (unsigned long word)
+grub_log2 (unsigned long word)
 {
   asm volatile ("bsfl %1,%0"
 		:          "=r" (word)
@@ -68,7 +68,7 @@
 static int
 iso9660_devread (int sector, int byte_offset, int byte_len, char *buf)
 {
-  unsigned short sector_size_lg2 = log2(buf_geom.sector_size);
+  unsigned short sector_size_lg2 = grub_log2(buf_geom.sector_size);
 
   /*
    * We have to use own devread() function since BIOS return wrong geometry
diff -Naur grub-0.97/stage2/fsys_reiserfs.c grub-0.97-suse/stage2/fsys_reiserfs.c
--- grub-0.97/stage2/fsys_reiserfs.c	2004-02-18 19:09:10.000000000 -0300
+++ grub-0.97-suse/stage2/fsys_reiserfs.c	2006-09-09 17:00:12.000000000 -0300
@@ -367,7 +367,7 @@
 
 
 static __inline__ unsigned long
-log2 (unsigned long word)
+grub_log2 (unsigned long word)
 {
   __asm__ ("bsfl %1,%0"
 	   : "=r" (word)
@@ -609,7 +609,7 @@
   
   INFO->version = super.s_version;
   INFO->blocksize = super.s_blocksize;
-  INFO->fullblocksize_shift = log2 (super.s_blocksize);
+  INFO->fullblocksize_shift = grub_log2 (super.s_blocksize);
   INFO->blocksize_shift = INFO->fullblocksize_shift - SECTOR_BITS;
   INFO->cached_slots = 
     (FSYSREISER_CACHE_SIZE >> INFO->fullblocksize_shift) - 1;
diff -Naur grub-0.97/stage2/iso9660.h grub-0.97-suse/stage2/iso9660.h
--- grub-0.97/stage2/iso9660.h	2004-03-27 13:02:38.000000000 -0300
+++ grub-0.97-suse/stage2/iso9660.h	2006-09-09 17:00:12.000000000 -0300
@@ -73,11 +73,11 @@
 
 typedef	struct __iso_16bit {
   u_int16_t l, b;
-} iso_16bit_t __attribute__ ((packed));
+} iso_16bit_t;
 
 typedef	struct __iso_32bit {
   u_int32_t l, b;
-} iso_32bit_t __attribute__ ((packed));
+} iso_32bit_t;
 
 typedef u_int8_t		iso_date_t[7];
 
diff -Naur grub-0.97/stage2/shared.h grub-0.97-suse/stage2/shared.h
--- grub-0.97/stage2/shared.h	2004-06-19 13:40:09.000000000 -0300
+++ grub-0.97-suse/stage2/shared.h	2006-09-09 17:00:12.000000000 -0300
@@ -374,6 +374,27 @@
 #endif /* WITHOUT_LIBC_STUBS */
 
 
+/* see typedef gfx_data_t below */
+#define gfx_ofs_ok			0x00
+#define gfx_ofs_mem_start		0x04
+#define gfx_ofs_mem_cur			0x08
+#define gfx_ofs_mem_max			0x0c
+#define gfx_ofs_code_seg		0x10
+#define gfx_ofs_jmp_table		0x14
+#define gfx_ofs_sys_cfg			0x44
+#define gfx_ofs_cmdline			0x64
+#define gfx_ofs_cmdline_len		0x68
+#define gfx_ofs_menu_list		0x6c
+#define gfx_ofs_menu_default_entry	0x70
+#define gfx_ofs_menu_entries		0x74
+#define gfx_ofs_menu_entry_len		0x78
+#define gfx_ofs_args_list		0x7c
+#define gfx_ofs_args_entry_len		0x80
+#define gfx_ofs_timeout			0x84
+#define gfx_ofs_mem_file		0x88
+#define gfx_ofs_mem_align		0x8c
+
+
 #ifndef ASM_FILE
 /*
  *  Below this should be ONLY defines and other constructs for C code.
@@ -595,6 +616,41 @@
 extern int default_entry;
 extern int current_entryno;
 
+
+/*
+ * graphics menu stuff
+ *
+ * Note: gfx_data and all data referred to in it must lie within a 64k area.
+ */
+typedef struct {
+  unsigned ok;			/* set while we're in graphics mode */
+  unsigned mem_start, mem_cur, mem_max;
+  unsigned code_seg;		/* code segment of binary graphics code */
+  unsigned jmp_table[12];	/* link to graphics functions */
+  unsigned char sys_cfg[32];	/* sys_cfg[0]: identifies boot loader (grub == 2) */
+  char *cmdline;		/* command line returned by gfx_input() */
+  unsigned cmdline_len;		/* length of the above */
+  char *menu_list;		/* list of menu entries, each of fixed length (menu_entry_len) */
+  char *menu_default_entry;	/* the default entry */
+  unsigned menu_entries;	/* number of entries in menu_list */
+  unsigned menu_entry_len;	/* one entry */
+  char *args_list;		/* same structure as menu_list, menu_entries entries */
+  unsigned args_entry_len;	/* one entry */
+  unsigned timeout;		/* in seconds (0: no timeout) */
+  unsigned mem_file;		/* aligned gfx file start */
+  unsigned mem_align;		/* aligned cpio file start */
+} __attribute__ ((packed)) gfx_data_t;
+
+extern gfx_data_t *graphics_data;
+
+/* pointer to graphics image data */
+extern char graphics_file[64];
+
+int gfx_init(gfx_data_t *gfx_data);
+int gfx_done(gfx_data_t *gfx_data);
+int gfx_input(gfx_data_t *gfx_data, int *menu_entry);
+int gfx_setup_menu(gfx_data_t *gfx_data);
+
 /* The constants for password types.  */
 typedef enum
 {
diff -Naur grub-0.97/stage2/shared.h~ grub-0.97-suse/stage2/shared.h~
--- grub-0.97/stage2/shared.h~	1969-12-31 21:00:00.000000000 -0300
+++ grub-0.97-suse/stage2/shared.h~	2004-06-19 13:40:09.000000000 -0300
@@ -0,0 +1,996 @@
+/* shared.h - definitions used in all GRUB-specific code */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 1999,2000,2001,2002,2003,2004  Free Software Foundation, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ *  Generic defines to use anywhere
+ */
+
+#ifndef GRUB_SHARED_HEADER
+#define GRUB_SHARED_HEADER	1
+
+#include <config.h>
+
+/* Add an underscore to a C symbol in assembler code if needed. */
+#ifdef HAVE_ASM_USCORE
+# define EXT_C(sym) _ ## sym
+#else
+# define EXT_C(sym) sym
+#endif
+
+/* Maybe redirect memory requests through grub_scratch_mem. */
+#ifdef GRUB_UTIL
+extern char *grub_scratch_mem;
+# define RAW_ADDR(x) ((x) + (int) grub_scratch_mem)
+# define RAW_SEG(x) (RAW_ADDR ((x) << 4) >> 4)
+#else
+# define RAW_ADDR(x) (x)
+# define RAW_SEG(x) (x)
+#endif
+
+/*
+ *  Integer sizes
+ */
+
+#define MAXINT     0x7FFFFFFF
+
+/* Maximum command line size. Before you blindly increase this value,
+   see the comment in char_io.c (get_cmdline).  */
+#define MAX_CMDLINE 1600
+#define NEW_HEAPSIZE 1500
+
+/* 512-byte scratch area */
+#define SCRATCHADDR  RAW_ADDR (0x77e00)
+#define SCRATCHSEG   RAW_SEG (0x77e0)
+
+/*
+ *  This is the location of the raw device buffer.  It is 31.5K
+ *  in size.
+ */
+
+#define BUFFERLEN   0x7e00
+#define BUFFERADDR  RAW_ADDR (0x70000)
+#define BUFFERSEG   RAW_SEG (0x7000)
+
+#define BOOT_PART_TABLE	RAW_ADDR (0x07be)
+
+/*
+ *  BIOS disk defines
+ */
+#define BIOSDISK_READ			0x0
+#define BIOSDISK_WRITE			0x1
+#define BIOSDISK_ERROR_GEOMETRY		0x100
+#define BIOSDISK_FLAG_LBA_EXTENSION	0x1
+#define BIOSDISK_FLAG_CDROM		0x2
+
+/*
+ *  This is the filesystem (not raw device) buffer.
+ *  It is 32K in size, do not overrun!
+ */
+
+#define FSYS_BUFLEN  0x8000
+#define FSYS_BUF RAW_ADDR (0x68000)
+
+/* Command-line buffer for Multiboot kernels and modules. This area
+   includes the area into which Stage 1.5 and Stage 1 are loaded, but
+   that's no problem.  */
+#define MB_CMDLINE_BUF		RAW_ADDR (0x2000)
+#define MB_CMDLINE_BUFLEN	0x6000
+
+/* The buffer for the password.  */
+#define PASSWORD_BUF		RAW_ADDR (0x78000)
+#define PASSWORD_BUFLEN		0x200
+
+/* THe buffer for the filename of "/boot/grub/default".  */
+#define DEFAULT_FILE_BUF	(PASSWORD_BUF + PASSWORD_BUFLEN)
+#define DEFAULT_FILE_BUFLEN	0x60
+
+/* The buffer for the command-line.  */
+#define CMDLINE_BUF		(DEFAULT_FILE_BUF + DEFAULT_FILE_BUFLEN)
+#define CMDLINE_BUFLEN		MAX_CMDLINE
+
+/* The kill buffer for the command-line.  */
+#define KILL_BUF		(CMDLINE_BUF + CMDLINE_BUFLEN)
+#define KILL_BUFLEN		MAX_CMDLINE
+
+/* The history buffer for the command-line.  */
+#define HISTORY_BUF		(KILL_BUF + KILL_BUFLEN)
+#define HISTORY_SIZE		5
+#define HISTORY_BUFLEN		(MAX_CMDLINE * HISTORY_SIZE)
+
+/* The buffer for the completion.  */
+#define COMPLETION_BUF		(HISTORY_BUF + HISTORY_BUFLEN)
+#define COMPLETION_BUFLEN	MAX_CMDLINE
+
+/* The buffer for the unique string.  */
+#define UNIQUE_BUF		(COMPLETION_BUF + COMPLETION_BUFLEN)
+#define UNIQUE_BUFLEN		MAX_CMDLINE
+
+/* The buffer for the menu entries.  */
+#define MENU_BUF		(UNIQUE_BUF + UNIQUE_BUFLEN)
+#define MENU_BUFLEN		(0x8000 + PASSWORD_BUF - MENU_BUF)
+
+/* The size of the drive map.  */
+#define DRIVE_MAP_SIZE		8
+
+/* The size of the key map.  */
+#define KEY_MAP_SIZE		128
+
+/* The size of the io map.  */
+#define IO_MAP_SIZE		128
+
+/*
+ *  Linux setup parameters
+ */
+
+#define LINUX_MAGIC_SIGNATURE		0x53726448	/* "HdrS" */
+#define LINUX_DEFAULT_SETUP_SECTS	4
+#define LINUX_FLAG_CAN_USE_HEAP		0x80
+#define LINUX_INITRD_MAX_ADDRESS	0x38000000
+#define LINUX_MAX_SETUP_SECTS		64
+#define LINUX_BOOT_LOADER_TYPE		0x71
+#define LINUX_HEAP_END_OFFSET		(0x9000 - 0x200)
+
+#define LINUX_BZIMAGE_ADDR		RAW_ADDR (0x100000)
+#define LINUX_ZIMAGE_ADDR		RAW_ADDR (0x10000)
+#define LINUX_OLD_REAL_MODE_ADDR	RAW_ADDR (0x90000)
+#define LINUX_SETUP_STACK		0x9000
+
+#define LINUX_FLAG_BIG_KERNEL		0x1
+
+/* Linux's video mode selection support. Actually I hate it!  */
+#define LINUX_VID_MODE_NORMAL		0xFFFF
+#define LINUX_VID_MODE_EXTENDED		0xFFFE
+#define LINUX_VID_MODE_ASK		0xFFFD
+
+#define LINUX_CL_OFFSET			0x9000
+#define LINUX_CL_END_OFFSET		0x90FF
+#define LINUX_SETUP_MOVE_SIZE		0x9100
+#define LINUX_CL_MAGIC			0xA33F
+
+/*
+ *  General disk stuff
+ */
+
+#define SECTOR_SIZE		0x200
+#define SECTOR_BITS		9
+#define BIOS_FLAG_FIXED_DISK	0x80
+
+#define BOOTSEC_LOCATION		RAW_ADDR (0x7C00)
+#define BOOTSEC_SIGNATURE		0xAA55
+#define BOOTSEC_BPB_OFFSET		0x3
+#define BOOTSEC_BPB_LENGTH		0x3B
+#define BOOTSEC_BPB_SYSTEM_ID		0x3
+#define BOOTSEC_BPB_HIDDEN_SECTORS	0x1C
+#define BOOTSEC_PART_OFFSET		0x1BE
+#define BOOTSEC_PART_LENGTH		0x40
+#define BOOTSEC_SIG_OFFSET		0x1FE
+#define BOOTSEC_LISTSIZE		8
+
+/* Not bad, perhaps.  */
+#define NETWORK_DRIVE	0x20
+
+/*
+ *  GRUB specific information
+ *    (in LSB order)
+ */
+
+#include <stage1.h>
+
+#define STAGE2_VER_MAJ_OFFS	0x6
+#define STAGE2_INSTALLPART	0x8
+#define STAGE2_SAVED_ENTRYNO	0xc
+#define STAGE2_STAGE2_ID	0x10
+#define STAGE2_FORCE_LBA	0x11
+#define STAGE2_VER_STR_OFFS	0x12
+
+/* Stage 2 identifiers */
+#define STAGE2_ID_STAGE2		0
+#define STAGE2_ID_FFS_STAGE1_5		1
+#define STAGE2_ID_E2FS_STAGE1_5		2
+#define STAGE2_ID_FAT_STAGE1_5		3
+#define STAGE2_ID_MINIX_STAGE1_5	4
+#define STAGE2_ID_REISERFS_STAGE1_5	5
+#define STAGE2_ID_VSTAFS_STAGE1_5	6
+#define STAGE2_ID_JFS_STAGE1_5		7
+#define STAGE2_ID_XFS_STAGE1_5		8
+#define STAGE2_ID_ISO9660_STAGE1_5	9
+#define STAGE2_ID_UFS2_STAGE1_5		10
+
+#ifndef STAGE1_5
+# define STAGE2_ID	STAGE2_ID_STAGE2
+#else
+# if defined(FSYS_FFS)
+#  define STAGE2_ID	STAGE2_ID_FFS_STAGE1_5
+# elif defined(FSYS_EXT2FS)
+#  define STAGE2_ID	STAGE2_ID_E2FS_STAGE1_5
+# elif defined(FSYS_FAT)
+#  define STAGE2_ID	STAGE2_ID_FAT_STAGE1_5
+# elif defined(FSYS_MINIX)
+#  define STAGE2_ID	STAGE2_ID_MINIX_STAGE1_5
+# elif defined(FSYS_REISERFS)
+#  define STAGE2_ID	STAGE2_ID_REISERFS_STAGE1_5
+# elif defined(FSYS_VSTAFS)
+#  define STAGE2_ID	STAGE2_ID_VSTAFS_STAGE1_5
+# elif defined(FSYS_JFS)
+#  define STAGE2_ID	STAGE2_ID_JFS_STAGE1_5
+# elif defined(FSYS_XFS)
+#  define STAGE2_ID	STAGE2_ID_XFS_STAGE1_5
+# elif defined(FSYS_ISO9660)
+#  define STAGE2_ID	STAGE2_ID_ISO9660_STAGE1_5
+# elif defined(FSYS_UFS2)
+#  define STAGE2_ID	STAGE2_ID_UFS2_STAGE1_5
+# else
+#  error "unknown Stage 2"
+# endif
+#endif
+
+/*
+ *  defines for use when switching between real and protected mode
+ */
+
+#define CR0_PE_ON	0x1
+#define CR0_PE_OFF	0xfffffffe
+#define PROT_MODE_CSEG	0x8
+#define PROT_MODE_DSEG  0x10
+#define PSEUDO_RM_CSEG	0x18
+#define PSEUDO_RM_DSEG	0x20
+#define STACKOFF	(0x2000 - 0x10)
+#define PROTSTACKINIT   (FSYS_BUF - 0x10)
+
+
+/*
+ * Assembly code defines
+ *
+ * "EXT_C" is assumed to be defined in the Makefile by the configure
+ *   command.
+ */
+
+#define ENTRY(x) .globl EXT_C(x) ; EXT_C(x):
+#define VARIABLE(x) ENTRY(x)
+
+
+#define K_RDWR  	0x60	/* keyboard data & cmds (read/write) */
+#define K_STATUS	0x64	/* keyboard status */
+#define K_CMD		0x64	/* keybd ctlr command (write-only) */
+
+#define K_OBUF_FUL 	0x01	/* output buffer full */
+#define K_IBUF_FUL 	0x02	/* input buffer full */
+
+#define KC_CMD_WIN	0xd0	/* read  output port */
+#define KC_CMD_WOUT	0xd1	/* write output port */
+#define KB_OUTPUT_MASK  0xdd	/* enable output buffer full interrupt
+				   enable data line
+				   enable clock line */
+#define KB_A20_ENABLE   0x02
+
+/* Codes for getchar. */
+#define ASCII_CHAR(x)   ((x) & 0xFF)
+#if !defined(GRUB_UTIL) || !defined(HAVE_LIBCURSES)
+# define KEY_LEFT        0x4B00
+# define KEY_RIGHT       0x4D00
+# define KEY_UP          0x4800
+# define KEY_DOWN        0x5000
+# define KEY_IC          0x5200	/* insert char */
+# define KEY_DC          0x5300	/* delete char */
+# define KEY_BACKSPACE   0x0008
+# define KEY_HOME        0x4700
+# define KEY_END         0x4F00
+# define KEY_NPAGE       0x5100
+# define KEY_PPAGE       0x4900
+# define A_NORMAL        0x7
+# define A_REVERSE       0x70
+#elif defined(HAVE_NCURSES_CURSES_H)
+# include <ncurses/curses.h>
+#elif defined(HAVE_NCURSES_H)
+# include <ncurses.h>
+#elif defined(HAVE_CURSES_H)
+# include <curses.h>
+#endif
+
+/* In old BSD curses, A_NORMAL and A_REVERSE are not defined, so we
+   define them here if they are undefined.  */
+#ifndef A_NORMAL
+# define A_NORMAL	0
+#endif /* ! A_NORMAL */
+#ifndef A_REVERSE
+# ifdef A_STANDOUT
+#  define A_REVERSE	A_STANDOUT
+# else /* ! A_STANDOUT */
+#  define A_REVERSE	0
+# endif /* ! A_STANDOUT */
+#endif /* ! A_REVERSE */
+
+/* Define ACS_* ourselves, since the definitions are not consistent among
+   various curses implementations.  */
+#undef ACS_ULCORNER
+#undef ACS_URCORNER
+#undef ACS_LLCORNER
+#undef ACS_LRCORNER
+#undef ACS_HLINE
+#undef ACS_VLINE
+#undef ACS_LARROW
+#undef ACS_RARROW
+#undef ACS_UARROW
+#undef ACS_DARROW
+
+#define ACS_ULCORNER	'+'
+#define ACS_URCORNER	'+'
+#define ACS_LLCORNER	'+'
+#define ACS_LRCORNER	'+'
+#define ACS_HLINE	'-'
+#define ACS_VLINE	'|'
+#define ACS_LARROW	'<'
+#define ACS_RARROW	'>'
+#define ACS_UARROW	'^'
+#define ACS_DARROW	'v'
+
+/* Special graphics characters for IBM displays. */
+#define DISP_UL		218
+#define DISP_UR		191
+#define DISP_LL		192
+#define DISP_LR		217
+#define DISP_HORIZ	196
+#define DISP_VERT	179
+#define DISP_LEFT	0x1b
+#define DISP_RIGHT	0x1a
+#define DISP_UP		0x18
+#define DISP_DOWN	0x19
+
+/* Remap some libc-API-compatible function names so that we prevent
+   circularararity. */
+#ifndef WITHOUT_LIBC_STUBS
+#define memmove grub_memmove
+#define memcpy grub_memmove	/* we don't need a separate memcpy */
+#define memset grub_memset
+#define isspace grub_isspace
+#define printf grub_printf
+#define sprintf grub_sprintf
+#undef putchar
+#define putchar grub_putchar
+#define strncat grub_strncat
+#define strstr grub_strstr
+#define memcmp grub_memcmp
+#define strcmp grub_strcmp
+#define tolower grub_tolower
+#define strlen grub_strlen
+#define strcpy grub_strcpy
+#endif /* WITHOUT_LIBC_STUBS */
+
+
+#ifndef ASM_FILE
+/*
+ *  Below this should be ONLY defines and other constructs for C code.
+ */
+
+/* multiboot stuff */
+
+#include "mb_header.h"
+#include "mb_info.h"
+
+/* For the Linux/i386 boot protocol version 2.03.  */
+struct linux_kernel_header
+{
+  char code1[0x0020];
+  unsigned short cl_magic;		/* Magic number 0xA33F */
+  unsigned short cl_offset;		/* The offset of command line */
+  char code2[0x01F1 - 0x0020 - 2 - 2];
+  unsigned char setup_sects;		/* The size of the setup in sectors */
+  unsigned short root_flags;		/* If the root is mounted readonly */
+  unsigned short syssize;		/* obsolete */
+  unsigned short swap_dev;		/* obsolete */
+  unsigned short ram_size;		/* obsolete */
+  unsigned short vid_mode;		/* Video mode control */
+  unsigned short root_dev;		/* Default root device number */
+  unsigned short boot_flag;		/* 0xAA55 magic number */
+  unsigned short jump;			/* Jump instruction */
+  unsigned long header;			/* Magic signature "HdrS" */
+  unsigned short version;		/* Boot protocol version supported */
+  unsigned long realmode_swtch;		/* Boot loader hook */
+  unsigned long start_sys;		/* Points to kernel version string */
+  unsigned char type_of_loader;		/* Boot loader identifier */
+  unsigned char loadflags;		/* Boot protocol option flags */
+  unsigned short setup_move_size;	/* Move to high memory size */
+  unsigned long code32_start;		/* Boot loader hook */
+  unsigned long ramdisk_image;		/* initrd load address */
+  unsigned long ramdisk_size;		/* initrd size */
+  unsigned long bootsect_kludge;	/* obsolete */
+  unsigned short heap_end_ptr;		/* Free memory after setup end */
+  unsigned short pad1;			/* Unused */
+  char *cmd_line_ptr;			/* Points to the kernel command line */
+  unsigned long initrd_addr_max;	/* The highest address of initrd */
+} __attribute__ ((packed));
+
+/* Memory map address range descriptor used by GET_MMAP_ENTRY. */
+struct mmar_desc
+{
+  unsigned long desc_len;	/* Size of this descriptor. */
+  unsigned long long addr;	/* Base address. */
+  unsigned long long length;	/* Length in bytes. */
+  unsigned long type;		/* Type of address range. */
+} __attribute__ ((packed));
+
+/* VBE controller information.  */
+struct vbe_controller
+{
+  unsigned char signature[4];
+  unsigned short version;
+  unsigned long oem_string;
+  unsigned long capabilities;
+  unsigned long video_mode;
+  unsigned short total_memory;
+  unsigned short oem_software_rev;
+  unsigned long oem_vendor_name;
+  unsigned long oem_product_name;
+  unsigned long oem_product_rev;
+  unsigned char reserved[222];
+  unsigned char oem_data[256];
+} __attribute__ ((packed));
+
+/* VBE mode information.  */
+struct vbe_mode
+{
+  unsigned short mode_attributes;
+  unsigned char win_a_attributes;
+  unsigned char win_b_attributes;
+  unsigned short win_granularity;
+  unsigned short win_size;
+  unsigned short win_a_segment;
+  unsigned short win_b_segment;
+  unsigned long win_func;
+  unsigned short bytes_per_scanline;
+
+  /* >=1.2 */
+  unsigned short x_resolution;
+  unsigned short y_resolution;
+  unsigned char x_char_size;
+  unsigned char y_char_size;
+  unsigned char number_of_planes;
+  unsigned char bits_per_pixel;
+  unsigned char number_of_banks;
+  unsigned char memory_model;
+  unsigned char bank_size;
+  unsigned char number_of_image_pages;
+  unsigned char reserved0;
+
+  /* direct color */
+  unsigned char red_mask_size;
+  unsigned char red_field_position;
+  unsigned char green_mask_size;
+  unsigned char green_field_position;
+  unsigned char blue_mask_size;
+  unsigned char blue_field_position;
+  unsigned char reserved_mask_size;
+  unsigned char reserved_field_position;
+  unsigned char direct_color_mode_info;
+
+  /* >=2.0 */
+  unsigned long phys_base;
+  unsigned long reserved1;
+  unsigned short reversed2;
+
+  /* >=3.0 */
+  unsigned short linear_bytes_per_scanline;
+  unsigned char banked_number_of_image_pages;
+  unsigned char linear_number_of_image_pages;
+  unsigned char linear_red_mask_size;
+  unsigned char linear_red_field_position;
+  unsigned char linear_green_mask_size;
+  unsigned char linear_green_field_position;
+  unsigned char linear_blue_mask_size;
+  unsigned char linear_blue_field_position;
+  unsigned char linear_reserved_mask_size;
+  unsigned char linear_reserved_field_position;
+  unsigned long max_pixel_clock;
+
+  unsigned char reserved3[189];
+} __attribute__ ((packed));
+
+
+#undef NULL
+#define NULL         ((void *) 0)
+
+/* Error codes (descriptions are in common.c) */
+typedef enum
+{
+  ERR_NONE = 0,
+  ERR_BAD_FILENAME,
+  ERR_BAD_FILETYPE,
+  ERR_BAD_GZIP_DATA,
+  ERR_BAD_GZIP_HEADER,
+  ERR_BAD_PART_TABLE,
+  ERR_BAD_VERSION,
+  ERR_BELOW_1MB,
+  ERR_BOOT_COMMAND,
+  ERR_BOOT_FAILURE,
+  ERR_BOOT_FEATURES,
+  ERR_DEV_FORMAT,
+  ERR_DEV_VALUES,
+  ERR_EXEC_FORMAT,
+  ERR_FILELENGTH,
+  ERR_FILE_NOT_FOUND,
+  ERR_FSYS_CORRUPT,
+  ERR_FSYS_MOUNT,
+  ERR_GEOM,
+  ERR_NEED_LX_KERNEL,
+  ERR_NEED_MB_KERNEL,
+  ERR_NO_DISK,
+  ERR_NO_PART,
+  ERR_NUMBER_PARSING,
+  ERR_OUTSIDE_PART,
+  ERR_READ,
+  ERR_SYMLINK_LOOP,
+  ERR_UNRECOGNIZED,
+  ERR_WONT_FIT,
+  ERR_WRITE,
+  ERR_BAD_ARGUMENT,
+  ERR_UNALIGNED,
+  ERR_PRIVILEGED,
+  ERR_DEV_NEED_INIT,
+  ERR_NO_DISK_SPACE,
+  ERR_NUMBER_OVERFLOW,
+
+  MAX_ERR_NUM
+} grub_error_t;
+
+extern unsigned long install_partition;
+extern unsigned long boot_drive;
+extern unsigned long install_second_sector;
+extern struct apm_info apm_bios_info;
+extern unsigned long boot_part_addr;
+extern int saved_entryno;
+extern unsigned char force_lba;
+extern char version_string[];
+extern char config_file[];
+extern unsigned long linux_text_len;
+extern char *linux_data_tmp_addr;
+extern char *linux_data_real_addr;
+
+#ifdef GRUB_UTIL
+/* If not using config file, this variable is set to zero,
+   otherwise non-zero.  */
+extern int use_config_file;
+/* If using the preset menu, this variable is set to non-zero,
+   otherwise zero.  */
+extern int use_preset_menu;
+/* If not using curses, this variable is set to zero, otherwise non-zero.  */
+extern int use_curses;
+/* The flag for verbose messages.  */
+extern int verbose;
+/* The flag for read-only.  */
+extern int read_only;
+/* The number of floppies to be probed.  */
+extern int floppy_disks;
+/* The map between BIOS drives and UNIX device file names.  */
+extern char **device_map;
+/* The filename which stores the information about a device map.  */
+extern char *device_map_file;
+/* The array of geometries.  */
+extern struct geometry *disks;
+/* Assign DRIVE to a device name DEVICE.  */
+extern void assign_device_name (int drive, const char *device);
+#endif
+
+#ifndef STAGE1_5
+/* GUI interface variables. */
+# define MAX_FALLBACK_ENTRIES	8
+extern int fallback_entries[MAX_FALLBACK_ENTRIES];
+extern int fallback_entryno;
+extern int default_entry;
+extern int current_entryno;
+
+/* The constants for password types.  */
+typedef enum
+{
+  PASSWORD_PLAIN,
+  PASSWORD_MD5,
+  PASSWORD_UNSUPPORTED
+}
+password_t;
+
+extern char *password;
+extern password_t password_type;
+extern int auth;
+extern char commands[];
+
+/* For `more'-like feature.  */
+extern int max_lines;
+extern int count_lines;
+extern int use_pager;
+#endif
+
+#ifndef NO_DECOMPRESSION
+extern int no_decompression;
+extern int compressed_file;
+#endif
+
+/* instrumentation variables */
+extern void (*disk_read_hook) (int, int, int);
+extern void (*disk_read_func) (int, int, int);
+
+#ifndef STAGE1_5
+/* The flag for debug mode.  */
+extern int debug;
+#endif /* STAGE1_5 */
+
+extern unsigned long current_drive;
+extern unsigned long current_partition;
+
+extern int fsys_type;
+
+/* The information for a disk geometry. The CHS information is only for
+   DOS/Partition table compatibility, and the real number of sectors is
+   stored in TOTAL_SECTORS.  */
+struct geometry
+{
+  /* The number of cylinders */
+  unsigned long cylinders;
+  /* The number of heads */
+  unsigned long heads;
+  /* The number of sectors */
+  unsigned long sectors;
+  /* The total number of sectors */
+  unsigned long total_sectors;
+  /* Device sector size */
+  unsigned long sector_size;
+  /* Flags */
+  unsigned long flags;
+};
+
+extern unsigned long part_start;
+extern unsigned long part_length;
+
+extern int current_slice;
+
+extern int buf_drive;
+extern int buf_track;
+extern struct geometry buf_geom;
+
+/* these are the current file position and maximum file position */
+extern int filepos;
+extern int filemax;
+
+/*
+ *  Common BIOS/boot data.
+ */
+
+extern struct multiboot_info mbi;
+extern unsigned long saved_drive;
+extern unsigned long saved_partition;
+extern unsigned long cdrom_drive;
+#ifndef STAGE1_5
+extern unsigned long saved_mem_upper;
+extern unsigned long extended_memory;
+#endif
+
+/*
+ *  Error variables.
+ */
+
+extern grub_error_t errnum;
+extern char *err_list[];
+
+/* Simplify declaration of entry_addr. */
+typedef void (*entry_func) (int, int, int, int, int, int)
+     __attribute__ ((noreturn));
+
+extern entry_func entry_addr;
+
+/* Enter the stage1.5/stage2 C code after the stack is set up. */
+void cmain (void);
+
+/* Halt the processor (called after an unrecoverable error). */
+void stop (void) __attribute__ ((noreturn));
+
+/* Reboot the system.  */
+void grub_reboot (void) __attribute__ ((noreturn));
+
+/* Halt the system, using APM if possible. If NO_APM is true, don't use
+   APM even if it is available.  */
+void grub_halt (int no_apm) __attribute__ ((noreturn));
+
+/* Copy MAP to the drive map and set up int13_handler.  */
+void set_int13_handler (unsigned short *map);
+
+/* Set up int15_handler.  */
+void set_int15_handler (void);
+
+/* Restore the original int15 handler.  */
+void unset_int15_handler (void);
+
+/* Track the int13 handler to probe I/O address space.  */
+void track_int13 (int drive);
+
+/* The key map.  */
+extern unsigned short bios_key_map[];
+extern unsigned short ascii_key_map[];
+extern unsigned short io_map[];
+
+/* calls for direct boot-loader chaining */
+void chain_stage1 (unsigned long segment, unsigned long offset,
+		   unsigned long part_table_addr)
+     __attribute__ ((noreturn));
+void chain_stage2 (unsigned long segment, unsigned long offset,
+		   int second_sector)
+     __attribute__ ((noreturn));
+
+/* do some funky stuff, then boot linux */
+void linux_boot (void) __attribute__ ((noreturn));
+
+/* do some funky stuff, then boot bzImage linux */
+void big_linux_boot (void) __attribute__ ((noreturn));
+
+/* booting a multiboot executable */
+void multi_boot (int start, int mb_info) __attribute__ ((noreturn));
+
+/* If LINEAR is nonzero, then set the Intel processor to linear mode.
+   Otherwise, bit 20 of all memory accesses is always forced to zero,
+   causing a wraparound effect for bugwards compatibility with the
+   8086 CPU. */
+void gateA20 (int linear);
+
+/* memory probe routines */
+int get_memsize (int type);
+int get_eisamemsize (void);
+
+/* Fetch the next entry in the memory map and return the continuation
+   value.  DESC is a pointer to the descriptor buffer, and CONT is the
+   previous continuation value (0 to get the first entry in the
+   map). */
+int get_mmap_entry (struct mmar_desc *desc, int cont);
+
+/* Get the linear address of a ROM configuration table. Return zero,
+   if fails.  */
+unsigned long get_rom_config_table (void);
+
+/* Get APM BIOS information.  */
+void get_apm_info (void);
+
+/* Get VBE controller information.  */
+int get_vbe_controller_info (struct vbe_controller *controller);
+
+/* Get VBE mode information.  */
+int get_vbe_mode_info (int mode_number, struct vbe_mode *mode);
+
+/* Set VBE mode.  */
+int set_vbe_mode (int mode_number);
+
+/* Return the data area immediately following our code. */
+int get_code_end (void);
+
+/* low-level timing info */
+int getrtsecs (void);
+int currticks (void);
+
+/* Clear the screen. */
+void cls (void);
+
+/* Turn on/off cursor. */
+int setcursor (int on);
+
+/* Get the current cursor position (where 0,0 is the top left hand
+   corner of the screen).  Returns packed values, (RET >> 8) is x,
+   (RET & 0xff) is y. */
+int getxy (void);
+
+/* Set the cursor position. */
+void gotoxy (int x, int y);
+
+/* Displays an ASCII character.  IBM displays will translate some
+   characters to special graphical ones (see the DISP_* constants). */
+void grub_putchar (int c);
+
+/* Wait for a keypress, and return its packed BIOS/ASCII key code.
+   Use ASCII_CHAR(ret) to extract the ASCII code. */
+int getkey (void);
+
+/* Like GETKEY, but doesn't block, and returns -1 if no keystroke is
+   available. */
+int checkkey (void);
+
+/* Low-level disk I/O */
+int get_diskinfo (int drive, struct geometry *geometry);
+int biosdisk (int subfunc, int drive, struct geometry *geometry,
+	      int sector, int nsec, int segment);
+void stop_floppy (void);
+
+/* Command-line interface functions. */
+#ifndef STAGE1_5
+
+/* The flags for the builtins.  */
+#define BUILTIN_CMDLINE		0x1	/* Run in the command-line.  */
+#define BUILTIN_MENU		0x2	/* Run in the menu.  */
+#define BUILTIN_TITLE		0x4	/* Only for the command title.  */
+#define BUILTIN_SCRIPT		0x8	/* Run in the script.  */
+#define BUILTIN_NO_ECHO		0x10	/* Don't print command on booting. */
+#define BUILTIN_HELP_LIST	0x20	/* Show help in listing.  */
+
+/* The table for a builtin.  */
+struct builtin
+{
+  /* The command name.  */
+  char *name;
+  /* The callback function.  */
+  int (*func) (char *, int);
+  /* The combination of the flags defined above.  */
+  int flags;
+  /* The short version of the documentation.  */
+  char *short_doc;
+  /* The long version of the documentation.  */
+  char *long_doc;
+};
+
+/* All the builtins are registered in this.  */
+extern struct builtin *builtin_table[];
+
+/* The constants for kernel types.  */
+typedef enum
+{
+  KERNEL_TYPE_NONE,		/* None is loaded.  */
+  KERNEL_TYPE_MULTIBOOT,	/* Multiboot.  */
+  KERNEL_TYPE_LINUX,		/* Linux.  */
+  KERNEL_TYPE_BIG_LINUX,	/* Big Linux.  */
+  KERNEL_TYPE_FREEBSD,		/* FreeBSD.  */
+  KERNEL_TYPE_NETBSD,		/* NetBSD.  */
+  KERNEL_TYPE_CHAINLOADER	/* Chainloader.  */
+}
+kernel_t;
+
+extern kernel_t kernel_type;
+extern int show_menu;
+extern int grub_timeout;
+
+void init_builtins (void);
+void init_config (void);
+char *skip_to (int after_equal, char *cmdline);
+struct builtin *find_command (char *command);
+void print_cmdline_message (int forever);
+void enter_cmdline (char *heap, int forever);
+int run_script (char *script, char *heap);
+#endif
+
+/* C library replacement functions with identical semantics. */
+void grub_printf (const char *format,...);
+int grub_sprintf (char *buffer, const char *format, ...);
+int grub_tolower (int c);
+int grub_isspace (int c);
+int grub_strncat (char *s1, const char *s2, int n);
+void *grub_memmove (void *to, const void *from, int len);
+void *grub_memset (void *start, int c, int len);
+int grub_strncat (char *s1, const char *s2, int n);
+char *grub_strstr (const char *s1, const char *s2);
+int grub_memcmp (const char *s1, const char *s2, int n);
+int grub_strcmp (const char *s1, const char *s2);
+int grub_strlen (const char *str);
+char *grub_strcpy (char *dest, const char *src);
+
+#ifndef GRUB_UTIL
+typedef unsigned long grub_jmp_buf[6];
+#else
+/* In the grub shell, use the libc jmp_buf instead.  */
+# include <setjmp.h>
+# define grub_jmp_buf jmp_buf
+#endif
+
+#ifdef GRUB_UTIL
+# define grub_setjmp	setjmp
+# define grub_longjmp	longjmp
+#else /* ! GRUB_UTIL */
+int grub_setjmp (grub_jmp_buf env);
+void grub_longjmp (grub_jmp_buf env, int val);
+#endif /* ! GRUB_UTIL */
+
+/* The environment for restarting Stage 2.  */
+extern grub_jmp_buf restart_env;
+/* The environment for restarting the command-line interface.  */
+extern grub_jmp_buf restart_cmdline_env;
+
+/* misc */
+void init_page (void);
+void print_error (void);
+char *convert_to_ascii (char *buf, int c, ...);
+int get_cmdline (char *prompt, char *cmdline, int maxlen,
+		 int echo_char, int history);
+int substring (const char *s1, const char *s2);
+int nul_terminate (char *str);
+int get_based_digit (int c, int base);
+int safe_parse_maxint (char **str_ptr, int *myint_ptr);
+int memcheck (int start, int len);
+void grub_putstr (const char *str);
+
+#ifndef NO_DECOMPRESSION
+/* Compression support. */
+int gunzip_test_header (void);
+int gunzip_read (char *buf, int len);
+#endif /* NO_DECOMPRESSION */
+
+int rawread (int drive, int sector, int byte_offset, int byte_len, char *buf);
+int devread (int sector, int byte_offset, int byte_len, char *buf);
+int rawwrite (int drive, int sector, char *buf);
+int devwrite (int sector, int sector_len, char *buf);
+
+/* Parse a device string and initialize the global parameters. */
+char *set_device (char *device);
+int open_device (void);
+int real_open_partition (int flags);
+int open_partition (void);
+int next_partition (unsigned long drive, unsigned long dest,
+		    unsigned long *partition, int *type,
+		    unsigned long *start, unsigned long *len,
+		    unsigned long *offset, int *entry,
+		    unsigned long *ext_offset, char *buf);
+
+/* Sets device to the one represented by the SAVED_* parameters. */
+int make_saved_active (void);
+
+/* Set or clear the current root partition's hidden flag.  */
+int set_partition_hidden_flag (int hidden);
+
+/* Open a file or directory on the active device, using GRUB's
+   internal filesystem support. */
+int grub_open (char *filename);
+
+/* Read LEN bytes into BUF from the file that was opened with
+   GRUB_OPEN.  If LEN is -1, read all the remaining data in the file.  */
+int grub_read (char *buf, int len);
+
+/* Reposition a file offset.  */
+int grub_seek (int offset);
+
+/* Close a file.  */
+void grub_close (void);
+
+/* List the contents of the directory that was opened with GRUB_OPEN,
+   printing all completions. */
+int dir (char *dirname);
+
+int set_bootdev (int hdbias);
+
+/* Display statistics on the current active device. */
+void print_fsys_type (void);
+
+/* Display device and filename completions. */
+void print_a_completion (char *filename);
+int print_completions (int is_filename, int is_completion);
+
+/* Copies the current partition data to the desired address. */
+void copy_current_part_entry (char *buf);
+
+#ifndef STAGE1_5
+void bsd_boot (kernel_t type, int bootdev, char *arg)
+     __attribute__ ((noreturn));
+
+/* Define flags for load_image here.  */
+/* Don't pass a Linux's mem option automatically.  */
+#define KERNEL_LOAD_NO_MEM_OPTION	(1 << 0)
+
+kernel_t load_image (char *kernel, char *arg, kernel_t suggested_type,
+		     unsigned long load_flags);
+
+int load_module (char *module, char *arg);
+int load_initrd (char *initrd);
+
+int check_password(char *entered, char* expected, password_t type);
+#endif
+
+void init_bios_info (void);
+
+#endif /* ASM_FILE */
+
+#endif /* ! GRUB_SHARED_HEADER */
diff -Naur grub-0.97/stage2/stage2.c grub-0.97-suse/stage2/stage2.c
--- grub-0.97/stage2/stage2.c	2005-03-19 14:51:57.000000000 -0300
+++ grub-0.97-suse/stage2/stage2.c	2006-09-09 17:00:13.000000000 -0300
@@ -22,6 +22,8 @@
 
 grub_jmp_buf restart_env;
 
+gfx_data_t *graphics_data;
+
 #if defined(PRESET_MENU_STRING) || defined(SUPPORT_DISKLESS)
 
 # if defined(PRESET_MENU_STRING)
@@ -310,6 +312,12 @@
       
       if (! auth && password)
 	{
+	  if (*graphics_file)
+	    {
+	      printf ("\
+	WARNING: graphical menu doesn\'t work\
+	in conjunction with the password feature\n" );
+	    }
 	  printf ("\
       Press enter to boot the selected OS or \'p\' to enter a\n\
       password to unlock the next set of features.");
@@ -753,6 +761,422 @@
 }
 
 
+
+#if 0
+/* for debugging */
+static void hexdump(unsigned char *buf, unsigned len)
+{
+  int i, j = 0;
+  char s[17];
+  unsigned addr = (unsigned) buf;
+
+  s[16] = 0;
+  while(len--) {
+    i = buf[j];
+    i = i & 0xff;
+    s[j & 15] = (i >= 0x20 && i <= 0x7e) ? i : '.';
+    if(!(j & 15)) {
+      printf("%x  ", j + addr);
+    }
+    if(!(j & 7) && (j & 15)) printf(" ");
+    /* stupid grub_printf */
+    printf("%x", (i >> 4) & 0x0f);
+    printf("%x ", i & 0x0f);
+    if(!(++j & 15)) {
+      printf(" %s\n", s);
+    }
+  }
+
+  if(j & 15) {
+    s[j & 15] = 0;
+    if(!(j & 8)) printf(" ");
+    i = 1 + 3 * (16 - (j & 15));
+    while(i--) printf(" ");
+    printf("%s\n", s);
+  }
+}
+#endif
+
+/*
+ * Go through config entry and find kernel args, if any.
+ */
+static char *get_kernel_args(char *cfg)
+{
+  int j;
+  char *s, *t = "";
+
+  for(j = 0; ; j++) {
+    s = get_entry(cfg, j, 0);
+    if(!*s) break;
+    if(!memcmp(s, "kernel", 6) && (s[6] == ' ' || s[6] == '\t')) {
+      t = skip_to(0, s);
+      if(*t) t = skip_to(0, t);
+      break;
+    }
+  }
+
+  return t;
+}
+
+
+/*
+ * Check header and return code start offset.
+ */
+static unsigned magic_ok(unsigned char *buf)
+{
+  if(
+    *(unsigned *) buf == 0x0b2d97f00 &&		/* magic id */
+    (buf[4] >= 5 && buf[4] <= 7)		/* version 5 - 7 */
+  ) {
+    return *(unsigned *) (buf + 8);
+  }
+
+  return 0;
+}
+
+
+/*
+ * Search cpio archive for gfx file.
+ */
+static unsigned find_file(unsigned char *buf, unsigned len, unsigned *gfx_file_start)
+{
+  unsigned i, fname_len, flen, code_start = 0;
+
+  *gfx_file_start = 0;
+
+  for(i = 0; i < len;) {
+    if((len - i) >= 0x1a && (buf[i] + (buf[i + 1] << 8)) == 0x71c7) {
+      fname_len = *(unsigned short *) (buf + i + 20);
+      flen = *(unsigned short *) (buf + i + 24) + (*(unsigned short *) (buf + i + 22) << 16);
+      i += 26 + fname_len;
+      i = ((i + 1) & ~1);
+      if((code_start = magic_ok(buf + i))) {
+        *gfx_file_start = i;
+        return code_start;
+      }
+      i += flen;
+      i = ((i + 1) & ~1);
+    }
+    else {
+      break;
+    }
+  }
+
+  return code_start;
+}
+
+static inline unsigned char * stack_ptr(void)
+{
+  unsigned char * u;
+
+  asm("movl %%esp, %0" : "=r" (u));
+
+  return u;
+}
+
+/*
+ * Leave that much space on the heap. Everything else goes to the graphics
+ * functions.
+ *
+ * 0x2000 is _not_ enough
+ */
+#define MIN_HEAP_SIZE	0x4000
+
+/* gfx code needs at least this much free memory */
+#define MIN_GFX_FREE	0xc000
+
+/*
+ * Does normally not return.
+ */
+static void
+run_graphics_menu (char *menu_entries, char *config_entries, int num_entries,
+	  char *heap, int entryno)
+{
+  unsigned char *buf;
+  unsigned u, buf_size, code_start, file_start;
+  char *s, *t, *cfg, *new_config;
+  char *saved_heap;
+  int i, j, max_len;
+  int selected_entry;
+  gfx_data_t *gfx_data;
+
+  /*
+   * check gfx_data_t struct offsets for consistency; gcc will optimize away
+   * the whole block
+   */
+
+  /* dummy function to make ld fail */
+  {
+    extern void wrong_struct_size(void);
+    #define gfx_ofs_check(a) if(gfx_ofs_##a != (char *) &gfx_data->a - (char *) gfx_data) wrong_struct_size();
+    gfx_ofs_check(ok);
+    gfx_ofs_check(mem_start);
+    gfx_ofs_check(mem_cur);
+    gfx_ofs_check(mem_max);
+    gfx_ofs_check(code_seg);
+    gfx_ofs_check(jmp_table);
+    gfx_ofs_check(sys_cfg);
+    gfx_ofs_check(cmdline);
+    gfx_ofs_check(cmdline_len);
+    gfx_ofs_check(menu_list);
+    gfx_ofs_check(menu_default_entry);
+    gfx_ofs_check(menu_entries);
+    gfx_ofs_check(menu_entry_len);
+    gfx_ofs_check(args_list);
+    gfx_ofs_check(args_entry_len);
+    gfx_ofs_check(timeout);
+    gfx_ofs_check(mem_file);
+    gfx_ofs_check(mem_align);
+    #undef gfx_ofs_check
+  }
+
+  if(!num_entries) return;
+
+  graphics_data = gfx_data = (gfx_data_t *) heap;
+  heap += sizeof *gfx_data;
+  memset(gfx_data, 0, sizeof *gfx_data);
+
+  gfx_data->sys_cfg[0] = 2;	/* bootloader: grub */
+  gfx_data->timeout = grub_timeout >= 0 ? grub_timeout : 0;
+
+
+  /* setup command line edit buffer */
+
+  gfx_data->cmdline_len = 256;
+
+  gfx_data->cmdline = heap;
+  heap += gfx_data->cmdline_len;
+  memset(gfx_data->cmdline, 0, gfx_data->cmdline_len);
+
+
+  /* setup menu entries */
+
+  for(i = max_len = 0; i < num_entries; i++) {
+    j = strlen(get_entry(menu_entries, i, 0));
+    if(j > max_len) max_len = j;
+  }
+
+  if(!max_len) return;
+
+  gfx_data->menu_entry_len = max_len + 1;
+  gfx_data->menu_entries = num_entries;
+
+  gfx_data->menu_list = heap;
+  heap += gfx_data->menu_entry_len * gfx_data->menu_entries;
+
+  memset(gfx_data->menu_list, 0, gfx_data->menu_entry_len * gfx_data->menu_entries);
+
+  for(i = 0; i < (int) gfx_data->menu_entries; i++) {
+    strcpy(gfx_data->menu_list + i * gfx_data->menu_entry_len, get_entry(menu_entries, i, 0));
+  }
+
+  gfx_data->menu_default_entry = gfx_data->menu_list + entryno * gfx_data->menu_entry_len;
+
+
+  /* setup list of kernel args */
+
+  for(i = max_len = 0; i < num_entries; i++) {
+    s = get_kernel_args(get_entry(config_entries, i, 1));
+    j = strlen(s);
+    if(j > max_len) max_len = j;
+  }
+
+  gfx_data->args_entry_len = max_len + 1;
+
+  gfx_data->args_list = heap;
+  heap += gfx_data->args_entry_len * gfx_data->menu_entries;
+
+  memset(gfx_data->args_list, 0, gfx_data->args_entry_len * gfx_data->menu_entries);
+
+  for(i = 0; i < (int) gfx_data->menu_entries; i++) {
+    strcpy(gfx_data->args_list + i* gfx_data->args_entry_len, get_kernel_args(get_entry(config_entries, i, 1)));
+  }
+
+
+  /* go back here when we no longer need the graphics data */
+  saved_heap = heap;
+
+
+  /* get memory area to be used by graphics functions */
+
+  buf = (unsigned char *) (((unsigned) heap + 0xf) & ~0xf);
+
+  buf_size = stack_ptr() - buf - MIN_HEAP_SIZE;
+  buf_size &= ~0xf;
+
+  /* too small */
+  if(buf_size < 0x10000) return;
+
+  gfx_data->mem_start = (unsigned) buf;
+  gfx_data->mem_max = gfx_data->mem_start + buf_size;
+
+#if 0
+  printf("graphics menu\n");
+  printf(
+    "heap = 0x%x, buf = 0x%x (0x%x bytes), graphics_file = %s\n",
+    heap, gfx_data->mem_start, buf_size, graphics_file
+  );
+  getkey();
+#endif
+
+  heap += buf_size;
+
+
+  /* read the file */
+
+  if(!grub_open(graphics_file)) {
+    printf("graphics file \"%s\" missing, press a key to continue...\n", graphics_file);
+    getkey();
+    return;
+  }
+
+  i = grub_read(buf, buf_size);
+
+  grub_close();
+
+  if(i <= 0) {
+    printf("error reading \"%s\", press a key to continue...\n", graphics_file);
+    getkey();
+    return;
+  }
+
+  /* besides the file, we need some working memory, too */
+  if(i + MIN_GFX_FREE + 0x0f >= (int) buf_size) {
+    printf("file \"%s\" too large, press a key to continue...\n", graphics_file);
+    printf("i is %d, MIN_GFX_FREE is %d, buf_size is %d\n",i,MIN_GFX_FREE,buf_size);
+    getkey();
+    return;
+  }
+
+  gfx_data->mem_cur = gfx_data->mem_start + ((i + 0x0f + 3) & ~3);	/* align it */
+
+#if 0
+  printf("image: %d bytes (%d bytes left)\n", i, gfx_data->mem_max - gfx_data->mem_cur);
+  getkey();
+#endif
+
+
+  /* locate file inside cpio archive */
+  if(!(code_start = find_file(buf, i, &file_start))) {
+    printf("\"%s\" has wrong format, press a key to continue...\n", graphics_file);
+    getkey();
+    return;
+  }
+
+
+  /* align it */
+  u = (-(code_start + gfx_data->mem_start + file_start)) & 0x0f;
+  gfx_data->mem_align = gfx_data->mem_start + u;
+  gfx_data->mem_file = gfx_data->mem_align + file_start;
+  if(u) {
+    memcpy((void *) gfx_data->mem_align, (void *) gfx_data->mem_start, i);
+  }
+
+  /* init interface to graphics functions */
+
+  code_start += gfx_data->mem_file;
+
+#if 0
+  printf("code_start: 0x%x, file_start: 0x%x, mem_align = 0x%x, mem_file = 0x%x\n",
+    code_start, file_start, gfx_data->mem_align, gfx_data->mem_file
+  );
+  getkey();
+#endif
+
+  gfx_data->code_seg = code_start >> 4;
+
+#if 0
+  printf("code start = 0x%x, code_seg = 0x%x\n", code_start, gfx_data->code_seg);
+#endif
+
+  for(i = 0; (unsigned) i < sizeof gfx_data->jmp_table / sizeof *gfx_data->jmp_table; i++) {
+    gfx_data->jmp_table[i] = (gfx_data->code_seg << 16) + ((unsigned short *) code_start)[i];
+  }
+
+#if 0
+  for(i = 0; i < 12; i++) {
+    printf("%d: 0x%x\n", i, gfx_data->jmp_table[i]);
+  }
+
+  for(i = 0; i < gfx_data->menu_entries; i++) {
+    printf(">%s< - >%s<\n",
+      gfx_data->menu_list + i * gfx_data->menu_entry_len,
+      gfx_data->args_list + i * gfx_data->args_entry_len
+    );
+  }
+
+  printf("def: >%s<\n", gfx_data->menu_default_entry);
+#endif
+
+
+  /* switch to graphics mode */
+
+  if(gfx_init(gfx_data)) {
+#if 0
+    printf("gfx_init failed\n");
+    getkey();
+#endif
+    return;
+  }
+
+  gfx_setup_menu(gfx_data);
+
+  i = gfx_input(gfx_data, &selected_entry);
+
+  /* ESC -> show text menu */
+  if(i == 1) {
+    gfx_done(gfx_data);
+    grub_timeout = -1;
+
+    return;
+  }
+
+  gfx_done(gfx_data);
+
+  heap = saved_heap;	/* free most of the graphics data */
+
+  // printf("cmdline: >%s<, entry = %d\n", gfx_data->cmdline, selected_entry);
+
+  if(selected_entry < 0 || selected_entry > num_entries) return;
+
+
+  /* create new config with modified kernel option */
+
+  cfg = get_entry(config_entries, selected_entry, 1);
+
+  new_config = heap;
+
+  for(i = 0; ; i++) {
+    s = get_entry(cfg, i, 0);
+    if(!*s) {
+      if(!i) *heap++ = 0;
+      *heap++ = 0;
+      break;
+    }
+    if(!memcmp(s, "kernel", 6) && (s[6] == ' ' || s[6] == '\t')) {
+      t = skip_to(0, s);
+      if(*t) t = skip_to(0, t);
+      memmove(heap, s, t - s);
+      heap += t - s;
+      *heap++ = ' ';
+      strcpy(heap, gfx_data->cmdline);
+      heap += strlen(gfx_data->cmdline) + 1;
+    }
+    else {
+      strcpy(heap, s);
+      heap += strlen(s) + 1;
+    }
+  }
+
+  *heap++ = 0;
+
+  // hexdump(new_config, heap - new_config);
+  // getkey();
+
+  run_script(new_config, heap);
+}
+
+
 static int
 get_line_from_config (char *cmdline, int maxlen, int read_from_file)
 {
@@ -827,6 +1251,7 @@
   return pos;
 }
 
+extern void __savedefault_once_reset();
 
 /* This is the starting function in C.  */
 void
@@ -1049,7 +1474,9 @@
 	    }
 	  while (is_preset);
 	}
-
+#ifndef SUPPORT_DISKLESS
+      __savedefault_once_reset();
+#endif
       if (! num_entries)
 	{
 	  /* If no acceptable config file, goto command-line, starting
@@ -1059,9 +1486,12 @@
 	}
       else
 	{
-	  /* Run menu interface.  */
-	  run_menu (menu_entries, config_entries, num_entries,
-		    menu_entries + menu_len, default_entry);
+	  if (*graphics_file && !password && show_menu && grub_timeout)
+	    {
+	      run_graphics_menu(menu_entries, config_entries, num_entries,menu_entries + menu_len, default_entry);
+	    }
+	    /* Run menu interface.  */
+            run_menu (menu_entries, config_entries, num_entries, menu_entries + menu_len, default_entry);
 	}
     }
 }
diff -Naur grub-0.97/stage2/stage2.c~ grub-0.97-suse/stage2/stage2.c~
--- grub-0.97/stage2/stage2.c~	1969-12-31 21:00:00.000000000 -0300
+++ grub-0.97-suse/stage2/stage2.c~	2006-09-09 17:00:12.000000000 -0300
@@ -0,0 +1,1070 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2000,2001,2002,2004,2005  Free Software Foundation, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <shared.h>
+#include <term.h>
+
+grub_jmp_buf restart_env;
+
+#if defined(PRESET_MENU_STRING) || defined(SUPPORT_DISKLESS)
+
+# if defined(PRESET_MENU_STRING)
+static const char *preset_menu = PRESET_MENU_STRING;
+# elif defined(SUPPORT_DISKLESS)
+/* Execute the command "bootp" automatically.  */
+static const char *preset_menu = "bootp\n";
+# endif /* SUPPORT_DISKLESS */
+
+static int preset_menu_offset;
+
+static int
+open_preset_menu (void)
+{
+#ifdef GRUB_UTIL
+  /* Unless the user explicitly requests to use the preset menu,
+     always opening the preset menu fails in the grub shell.  */
+  if (! use_preset_menu)
+    return 0;
+#endif /* GRUB_UTIL */
+  
+  preset_menu_offset = 0;
+  return preset_menu != 0;
+}
+
+static int
+read_from_preset_menu (char *buf, int maxlen)
+{
+  int len = grub_strlen (preset_menu + preset_menu_offset);
+
+  if (len > maxlen)
+    len = maxlen;
+
+  grub_memmove (buf, preset_menu + preset_menu_offset, len);
+  preset_menu_offset += len;
+
+  return len;
+}
+
+static void
+close_preset_menu (void)
+{
+  /* Disable the preset menu.  */
+  preset_menu = 0;
+}
+
+#else /* ! PRESET_MENU_STRING && ! SUPPORT_DISKLESS */
+
+#define open_preset_menu()	0
+#define read_from_preset_menu(buf, maxlen)	0
+#define close_preset_menu()
+
+#endif /* ! PRESET_MENU_STRING && ! SUPPORT_DISKLESS */
+
+static char *
+get_entry (char *list, int num, int nested)
+{
+  int i;
+
+  for (i = 0; i < num; i++)
+    {
+      do
+	{
+	  while (*(list++));
+	}
+      while (nested && *(list++));
+    }
+
+  return list;
+}
+
+/* Print an entry in a line of the menu box.  */
+static void
+print_entry (int y, int highlight, char *entry)
+{
+  int x;
+
+  if (current_term->setcolorstate)
+    current_term->setcolorstate (COLOR_STATE_NORMAL);
+  
+  if (highlight && current_term->setcolorstate)
+    current_term->setcolorstate (COLOR_STATE_HIGHLIGHT);
+
+  gotoxy (2, y);
+  grub_putchar (' ');
+  for (x = 3; x < 75; x++)
+    {
+      if (*entry && x <= 72)
+	{
+	  if (x == 72)
+	    grub_putchar (DISP_RIGHT);
+	  else
+	    grub_putchar (*entry++);
+	}
+      else
+	grub_putchar (' ');
+    }
+  gotoxy (74, y);
+
+  if (current_term->setcolorstate)
+    current_term->setcolorstate (COLOR_STATE_STANDARD);
+}
+
+/* Print entries in the menu box.  */
+static void
+print_entries (int y, int size, int first, int entryno, char *menu_entries)
+{
+  int i;
+  
+  gotoxy (77, y + 1);
+
+  if (first)
+    grub_putchar (DISP_UP);
+  else
+    grub_putchar (' ');
+
+  menu_entries = get_entry (menu_entries, first, 0);
+
+  for (i = 0; i < size; i++)
+    {
+      print_entry (y + i + 1, entryno == i, menu_entries);
+
+      while (*menu_entries)
+	menu_entries++;
+
+      if (*(menu_entries - 1))
+	menu_entries++;
+    }
+
+  gotoxy (77, y + size);
+
+  if (*menu_entries)
+    grub_putchar (DISP_DOWN);
+  else
+    grub_putchar (' ');
+
+  gotoxy (74, y + entryno + 1);
+}
+
+static void
+print_entries_raw (int size, int first, char *menu_entries)
+{
+  int i;
+
+#define LINE_LENGTH 67
+
+  for (i = 0; i < LINE_LENGTH; i++)
+    grub_putchar ('-');
+  grub_putchar ('\n');
+
+  for (i = first; i < size; i++)
+    {
+      /* grub's printf can't %02d so ... */
+      if (i < 10)
+	grub_putchar (' ');
+      grub_printf ("%d: %s\n", i, get_entry (menu_entries, i, 0));
+    }
+
+  for (i = 0; i < LINE_LENGTH; i++)
+    grub_putchar ('-');
+  grub_putchar ('\n');
+
+#undef LINE_LENGTH
+}
+
+
+static void
+print_border (int y, int size)
+{
+  int i;
+
+  if (current_term->setcolorstate)
+    current_term->setcolorstate (COLOR_STATE_NORMAL);
+  
+  gotoxy (1, y);
+
+  grub_putchar (DISP_UL);
+  for (i = 0; i < 73; i++)
+    grub_putchar (DISP_HORIZ);
+  grub_putchar (DISP_UR);
+
+  i = 1;
+  while (1)
+    {
+      gotoxy (1, y + i);
+
+      if (i > size)
+	break;
+      
+      grub_putchar (DISP_VERT);
+      gotoxy (75, y + i);
+      grub_putchar (DISP_VERT);
+
+      i++;
+    }
+
+  grub_putchar (DISP_LL);
+  for (i = 0; i < 73; i++)
+    grub_putchar (DISP_HORIZ);
+  grub_putchar (DISP_LR);
+
+  if (current_term->setcolorstate)
+    current_term->setcolorstate (COLOR_STATE_STANDARD);
+}
+
+static void
+run_menu (char *menu_entries, char *config_entries, int num_entries,
+	  char *heap, int entryno)
+{
+  int c, time1, time2 = -1, first_entry = 0;
+  char *cur_entry = 0;
+
+  /*
+   *  Main loop for menu UI.
+   */
+
+restart:
+  /* Dumb terminal always use all entries for display 
+     invariant for TERM_DUMB: first_entry == 0  */
+  if (! (current_term->flags & TERM_DUMB))
+    {
+      while (entryno > 11)
+	{
+	  first_entry++;
+	  entryno--;
+	}
+    }
+
+  /* If the timeout was expired or wasn't set, force to show the menu
+     interface. */
+  if (grub_timeout < 0)
+    show_menu = 1;
+  
+  /* If SHOW_MENU is false, don't display the menu until ESC is pressed.  */
+  if (! show_menu)
+    {
+      /* Get current time.  */
+      while ((time1 = getrtsecs ()) == 0xFF)
+	;
+
+      while (1)
+	{
+	  /* Check if ESC is pressed.  */
+	  if (checkkey () != -1 && ASCII_CHAR (getkey ()) == '\e')
+	    {
+	      grub_timeout = -1;
+	      show_menu = 1;
+	      break;
+	    }
+
+	  /* If GRUB_TIMEOUT is expired, boot the default entry.  */
+	  if (grub_timeout >=0
+	      && (time1 = getrtsecs ()) != time2
+	      && time1 != 0xFF)
+	    {
+	      if (grub_timeout <= 0)
+		{
+		  grub_timeout = -1;
+		  goto boot_entry;
+		}
+	      
+	      time2 = time1;
+	      grub_timeout--;
+	      
+	      /* Print a message.  */
+	      grub_printf ("\rPress `ESC' to enter the menu... %d   ",
+			   grub_timeout);
+	    }
+	}
+    }
+
+  /* Only display the menu if the user wants to see it. */
+  if (show_menu)
+    {
+      init_page ();
+      setcursor (0);
+
+      if (current_term->flags & TERM_DUMB)
+	print_entries_raw (num_entries, first_entry, menu_entries);
+      else
+	print_border (3, 12);
+
+      grub_printf ("\n\
+      Use the %c and %c keys to select which entry is highlighted.\n",
+		   DISP_UP, DISP_DOWN);
+      
+      if (! auth && password)
+	{
+	  printf ("\
+      Press enter to boot the selected OS or \'p\' to enter a\n\
+      password to unlock the next set of features.");
+	}
+      else
+	{
+	  if (config_entries)
+	    printf ("\
+      Press enter to boot the selected OS, \'e\' to edit the\n\
+      commands before booting, or \'c\' for a command-line.");
+	  else
+	    printf ("\
+      Press \'b\' to boot, \'e\' to edit the selected command in the\n\
+      boot sequence, \'c\' for a command-line, \'o\' to open a new line\n\
+      after (\'O\' for before) the selected line, \'d\' to remove the\n\
+      selected line, or escape to go back to the main menu.");
+	}
+
+      if (current_term->flags & TERM_DUMB)
+	grub_printf ("\n\nThe selected entry is %d ", entryno);
+      else
+	print_entries (3, 12, first_entry, entryno, menu_entries);
+    }
+
+  /* XX using RT clock now, need to initialize value */
+  while ((time1 = getrtsecs()) == 0xFF);
+
+  while (1)
+    {
+      /* Initialize to NULL just in case...  */
+      cur_entry = NULL;
+
+      if (grub_timeout >= 0 && (time1 = getrtsecs()) != time2 && time1 != 0xFF)
+	{
+	  if (grub_timeout <= 0)
+	    {
+	      grub_timeout = -1;
+	      break;
+	    }
+
+	  /* else not booting yet! */
+	  time2 = time1;
+
+	  if (current_term->flags & TERM_DUMB)
+	      grub_printf ("\r    Entry %d will be booted automatically in %d seconds.   ", 
+			   entryno, grub_timeout);
+	  else
+	    {
+	      gotoxy (3, 22);
+	      grub_printf ("The highlighted entry will be booted automatically in %d seconds.    ",
+			   grub_timeout);
+	      gotoxy (74, 4 + entryno);
+	  }
+	  
+	  grub_timeout--;
+	}
+
+      /* Check for a keypress, however if TIMEOUT has been expired
+	 (GRUB_TIMEOUT == -1) relax in GETKEY even if no key has been
+	 pressed.  
+	 This avoids polling (relevant in the grub-shell and later on
+	 in grub if interrupt driven I/O is done).  */
+      if (checkkey () >= 0 || grub_timeout < 0)
+	{
+	  /* Key was pressed, show which entry is selected before GETKEY,
+	     since we're comming in here also on GRUB_TIMEOUT == -1 and
+	     hang in GETKEY */
+	  if (current_term->flags & TERM_DUMB)
+	    grub_printf ("\r    Highlighted entry is %d: ", entryno);
+
+	  c = ASCII_CHAR (getkey ());
+
+	  if (grub_timeout >= 0)
+	    {
+	      if (current_term->flags & TERM_DUMB)
+		grub_putchar ('\r');
+	      else
+		gotoxy (3, 22);
+	      printf ("                                                                    ");
+	      grub_timeout = -1;
+	      fallback_entryno = -1;
+	      if (! (current_term->flags & TERM_DUMB))
+		gotoxy (74, 4 + entryno);
+	    }
+
+	  /* We told them above (at least in SUPPORT_SERIAL) to use
+	     '^' or 'v' so accept these keys.  */
+	  if (c == 16 || c == '^')
+	    {
+	      if (current_term->flags & TERM_DUMB)
+		{
+		  if (entryno > 0)
+		    entryno--;
+		}
+	      else
+		{
+		  if (entryno > 0)
+		    {
+		      print_entry (4 + entryno, 0,
+				   get_entry (menu_entries,
+					      first_entry + entryno,
+					      0));
+		      entryno--;
+		      print_entry (4 + entryno, 1,
+				   get_entry (menu_entries,
+					      first_entry + entryno,
+					      0));
+		    }
+		  else if (first_entry > 0)
+		    {
+		      first_entry--;
+		      print_entries (3, 12, first_entry, entryno,
+				     menu_entries);
+		    }
+		}
+	    }
+	  else if ((c == 14 || c == 'v')
+		   && first_entry + entryno + 1 < num_entries)
+	    {
+	      if (current_term->flags & TERM_DUMB)
+		entryno++;
+	      else
+		{
+		  if (entryno < 11)
+		    {
+		      print_entry (4 + entryno, 0,
+				   get_entry (menu_entries,
+					      first_entry + entryno,
+					      0));
+		      entryno++;
+		      print_entry (4 + entryno, 1,
+				   get_entry (menu_entries,
+					      first_entry + entryno,
+					      0));
+		  }
+		else if (num_entries > 12 + first_entry)
+		  {
+		    first_entry++;
+		    print_entries (3, 12, first_entry, entryno, menu_entries);
+		  }
+		}
+	    }
+	  else if (c == 7)
+	    {
+	      /* Page Up */
+	      first_entry -= 12;
+	      if (first_entry < 0)
+		{
+		  entryno += first_entry;
+		  first_entry = 0;
+		  if (entryno < 0)
+		    entryno = 0;
+		}
+	      print_entries (3, 12, first_entry, entryno, menu_entries);
+	    }
+	  else if (c == 3)
+	    {
+	      /* Page Down */
+	      first_entry += 12;
+	      if (first_entry + entryno + 1 >= num_entries)
+		{
+		  first_entry = num_entries - 12;
+		  if (first_entry < 0)
+		    first_entry = 0;
+		  entryno = num_entries - first_entry - 1;
+		}
+	      print_entries (3, 12, first_entry, entryno, menu_entries);
+	    }
+
+	  if (config_entries)
+	    {
+	      if ((c == '\n') || (c == '\r') || (c == 6))
+		break;
+	    }
+	  else
+	    {
+	      if ((c == 'd') || (c == 'o') || (c == 'O'))
+		{
+		  if (! (current_term->flags & TERM_DUMB))
+		    print_entry (4 + entryno, 0,
+				 get_entry (menu_entries,
+					    first_entry + entryno,
+					    0));
+
+		  /* insert after is almost exactly like insert before */
+		  if (c == 'o')
+		    {
+		      /* But `o' differs from `O', since it may causes
+			 the menu screen to scroll up.  */
+		      if (entryno < 11 || (current_term->flags & TERM_DUMB))
+			entryno++;
+		      else
+			first_entry++;
+		      
+		      c = 'O';
+		    }
+
+		  cur_entry = get_entry (menu_entries,
+					 first_entry + entryno,
+					 0);
+
+		  if (c == 'O')
+		    {
+		      grub_memmove (cur_entry + 2, cur_entry,
+				    ((int) heap) - ((int) cur_entry));
+
+		      cur_entry[0] = ' ';
+		      cur_entry[1] = 0;
+
+		      heap += 2;
+
+		      num_entries++;
+		    }
+		  else if (num_entries > 0)
+		    {
+		      char *ptr = get_entry(menu_entries,
+					    first_entry + entryno + 1,
+					    0);
+
+		      grub_memmove (cur_entry, ptr,
+				    ((int) heap) - ((int) ptr));
+		      heap -= (((int) ptr) - ((int) cur_entry));
+
+		      num_entries--;
+
+		      if (entryno >= num_entries)
+			entryno--;
+		      if (first_entry && num_entries < 12 + first_entry)
+			first_entry--;
+		    }
+
+		  if (current_term->flags & TERM_DUMB)
+		    {
+		      grub_printf ("\n\n");
+		      print_entries_raw (num_entries, first_entry,
+					 menu_entries);
+		      grub_printf ("\n");
+		    }
+		  else
+		    print_entries (3, 12, first_entry, entryno, menu_entries);
+		}
+
+	      cur_entry = menu_entries;
+	      if (c == 27)
+		return;
+	      if (c == 'b')
+		break;
+	    }
+
+	  if (! auth && password)
+	    {
+	      if (c == 'p')
+		{
+		  /* Do password check here! */
+		  char entered[32];
+		  char *pptr = password;
+
+		  if (current_term->flags & TERM_DUMB)
+		    grub_printf ("\r                                    ");
+		  else
+		    gotoxy (1, 21);
+
+		  /* Wipe out the previously entered password */
+		  grub_memset (entered, 0, sizeof (entered));
+		  get_cmdline (" Password: ", entered, 31, '*', 0);
+
+		  while (! isspace (*pptr) && *pptr)
+		    pptr++;
+
+		  /* Make sure that PASSWORD is NUL-terminated.  */
+		  *pptr++ = 0;
+
+		  if (! check_password (entered, password, password_type))
+		    {
+		      char *new_file = config_file;
+		      while (isspace (*pptr))
+			pptr++;
+
+		      /* If *PPTR is NUL, then allow the user to use
+			 privileged instructions, otherwise, load
+			 another configuration file.  */
+		      if (*pptr != 0)
+			{
+			  while ((*(new_file++) = *(pptr++)) != 0)
+			    ;
+
+			  /* Make sure that the user will not have
+			     authority in the next configuration.  */
+			  auth = 0;
+			  return;
+			}
+		      else
+			{
+			  /* Now the user is superhuman.  */
+			  auth = 1;
+			  goto restart;
+			}
+		    }
+		  else
+		    {
+		      grub_printf ("Failed!\n      Press any key to continue...");
+		      getkey ();
+		      goto restart;
+		    }
+		}
+	    }
+	  else
+	    {
+	      if (c == 'e')
+		{
+		  int new_num_entries = 0, i = 0;
+		  char *new_heap;
+
+		  if (config_entries)
+		    {
+		      new_heap = heap;
+		      cur_entry = get_entry (config_entries,
+					     first_entry + entryno,
+					     1);
+		    }
+		  else
+		    {
+		      /* safe area! */
+		      new_heap = heap + NEW_HEAPSIZE + 1;
+		      cur_entry = get_entry (menu_entries,
+					     first_entry + entryno,
+					     0);
+		    }
+
+		  do
+		    {
+		      while ((*(new_heap++) = cur_entry[i++]) != 0);
+		      new_num_entries++;
+		    }
+		  while (config_entries && cur_entry[i]);
+
+		  /* this only needs to be done if config_entries is non-NULL,
+		     but it doesn't hurt to do it always */
+		  *(new_heap++) = 0;
+
+		  if (config_entries)
+		    run_menu (heap, NULL, new_num_entries, new_heap, 0);
+		  else
+		    {
+		      cls ();
+		      print_cmdline_message (0);
+
+		      new_heap = heap + NEW_HEAPSIZE + 1;
+
+		      saved_drive = boot_drive;
+		      saved_partition = install_partition;
+		      current_drive = GRUB_INVALID_DRIVE;
+
+		      if (! get_cmdline (PACKAGE " edit> ", new_heap,
+					 NEW_HEAPSIZE + 1, 0, 1))
+			{
+			  int j = 0;
+
+			  /* get length of new command */
+			  while (new_heap[j++])
+			    ;
+
+			  if (j < 2)
+			    {
+			      j = 2;
+			      new_heap[0] = ' ';
+			      new_heap[1] = 0;
+			    }
+
+			  /* align rest of commands properly */
+			  grub_memmove (cur_entry + j, cur_entry + i,
+					(int) heap - ((int) cur_entry + i));
+
+			  /* copy command to correct area */
+			  grub_memmove (cur_entry, new_heap, j);
+
+			  heap += (j - i);
+			}
+		    }
+
+		  goto restart;
+		}
+	      if (c == 'c')
+		{
+		  enter_cmdline (heap, 0);
+		  goto restart;
+		}
+#ifdef GRUB_UTIL
+	      if (c == 'q')
+		{
+		  /* The same as ``quit''.  */
+		  stop ();
+		}
+#endif
+	    }
+	}
+    }
+  
+  /* Attempt to boot an entry.  */
+  
+ boot_entry:
+  
+  cls ();
+  setcursor (1);
+  
+  while (1)
+    {
+      if (config_entries)
+	printf ("  Booting \'%s\'\n\n",
+		get_entry (menu_entries, first_entry + entryno, 0));
+      else
+	printf ("  Booting command-list\n\n");
+
+      if (! cur_entry)
+	cur_entry = get_entry (config_entries, first_entry + entryno, 1);
+
+      /* Set CURRENT_ENTRYNO for the command "savedefault".  */
+      current_entryno = first_entry + entryno;
+      
+      if (run_script (cur_entry, heap))
+	{
+	  if (fallback_entryno >= 0)
+	    {
+	      cur_entry = NULL;
+	      first_entry = 0;
+	      entryno = fallback_entries[fallback_entryno];
+	      fallback_entryno++;
+	      if (fallback_entryno >= MAX_FALLBACK_ENTRIES
+		  || fallback_entries[fallback_entryno] < 0)
+		fallback_entryno = -1;
+	    }
+	  else
+	    break;
+	}
+      else
+	break;
+    }
+
+  show_menu = 1;
+  goto restart;
+}
+
+
+static int
+get_line_from_config (char *cmdline, int maxlen, int read_from_file)
+{
+  int pos = 0, literal = 0, comment = 0;
+  char c;  /* since we're loading it a byte at a time! */
+  
+  while (1)
+    {
+      if (read_from_file)
+	{
+	  if (! grub_read (&c, 1))
+	    break;
+	}
+      else
+	{
+	  if (! read_from_preset_menu (&c, 1))
+	    break;
+	}
+
+      /* Skip all carriage returns.  */
+      if (c == '\r')
+	continue;
+
+      /* Replace tabs with spaces.  */
+      if (c == '\t')
+	c = ' ';
+
+      /* The previous is a backslash, then...  */
+      if (literal)
+	{
+	  /* If it is a newline, replace it with a space and continue.  */
+	  if (c == '\n')
+	    {
+	      c = ' ';
+	      
+	      /* Go back to overwrite a backslash.  */
+	      if (pos > 0)
+		pos--;
+	    }
+	    
+	  literal = 0;
+	}
+	  
+      /* translate characters first! */
+      if (c == '\\' && ! literal)
+	literal = 1;
+
+      if (comment)
+	{
+	  if (c == '\n')
+	    comment = 0;
+	}
+      else if (! pos)
+	{
+	  if (c == '#')
+	    comment = 1;
+	  else if ((c != ' ') && (c != '\n'))
+	    cmdline[pos++] = c;
+	}
+      else
+	{
+	  if (c == '\n')
+	    break;
+
+	  if (pos < maxlen)
+	    cmdline[pos++] = c;
+	}
+    }
+
+  cmdline[pos] = 0;
+
+  return pos;
+}
+
+extern void __savedefault_once_reset();
+
+/* This is the starting function in C.  */
+void
+cmain (void)
+{
+  int config_len, menu_len, num_entries;
+  char *config_entries, *menu_entries;
+  char *kill_buf = (char *) KILL_BUF;
+
+  auto void reset (void);
+  void reset (void)
+    {
+      count_lines = -1;
+      config_len = 0;
+      menu_len = 0;
+      num_entries = 0;
+      config_entries = (char *) mbi.drives_addr + mbi.drives_length;
+      menu_entries = (char *) MENU_BUF;
+      init_config ();
+    }
+  
+  /* Initialize the environment for restarting Stage 2.  */
+  grub_setjmp (restart_env);
+  
+  /* Initialize the kill buffer.  */
+  *kill_buf = 0;
+
+  /* Never return.  */
+  for (;;)
+    {
+      int is_opened, is_preset;
+
+      reset ();
+      
+      /* Here load the configuration file.  */
+      
+#ifdef GRUB_UTIL
+      if (use_config_file)
+#endif /* GRUB_UTIL */
+	{
+	  char *default_file = (char *) DEFAULT_FILE_BUF;
+	  int i;
+	  
+	  /* Get a saved default entry if possible.  */
+	  saved_entryno = 0;
+	  *default_file = 0;
+	  grub_strncat (default_file, config_file, DEFAULT_FILE_BUFLEN);
+	  for (i = grub_strlen(default_file); i >= 0; i--)
+	    if (default_file[i] == '/')
+	      {
+		i++;
+		break;
+	      }
+	  default_file[i] = 0;
+	  grub_strncat (default_file + i, "default", DEFAULT_FILE_BUFLEN - i);
+	  if (grub_open (default_file))
+	    {
+	      char buf[10]; /* This is good enough.  */
+	      char *p = buf;
+	      int len;
+	      
+	      len = grub_read (buf, sizeof (buf));
+	      if (len > 0)
+		{
+		  buf[sizeof (buf) - 1] = 0;
+		  safe_parse_maxint (&p, &saved_entryno);
+		}
+
+	      grub_close ();
+	    }
+	  errnum = ERR_NONE;
+	  
+	  do
+	    {
+	      /* STATE 0:  Before any title command.
+		 STATE 1:  In a title command.
+		 STATE >1: In a entry after a title command.  */
+	      int state = 0, prev_config_len = 0, prev_menu_len = 0;
+	      char *cmdline;
+
+	      /* Try the preset menu first. This will succeed at most once,
+		 because close_preset_menu disables the preset menu.  */
+	      is_opened = is_preset = open_preset_menu ();
+	      if (! is_opened)
+		{
+		  is_opened = grub_open (config_file);
+		  errnum = ERR_NONE;
+		}
+
+	      if (! is_opened)
+		break;
+
+	      /* This is necessary, because the menu must be overrided.  */
+	      reset ();
+	      
+	      cmdline = (char *) CMDLINE_BUF;
+	      while (get_line_from_config (cmdline, NEW_HEAPSIZE,
+					   ! is_preset))
+		{
+		  struct builtin *builtin;
+		  
+		  /* Get the pointer to the builtin structure.  */
+		  builtin = find_command (cmdline);
+		  errnum = 0;
+		  if (! builtin)
+		    /* Unknown command. Just skip now.  */
+		    continue;
+		  
+		  if (builtin->flags & BUILTIN_TITLE)
+		    {
+		      char *ptr;
+		      
+		      /* the command "title" is specially treated.  */
+		      if (state > 1)
+			{
+			  /* The next title is found.  */
+			  num_entries++;
+			  config_entries[config_len++] = 0;
+			  prev_menu_len = menu_len;
+			  prev_config_len = config_len;
+			}
+		      else
+			{
+			  /* The first title is found.  */
+			  menu_len = prev_menu_len;
+			  config_len = prev_config_len;
+			}
+		      
+		      /* Reset the state.  */
+		      state = 1;
+		      
+		      /* Copy title into menu area.  */
+		      ptr = skip_to (1, cmdline);
+		      while ((menu_entries[menu_len++] = *(ptr++)) != 0)
+			;
+		    }
+		  else if (! state)
+		    {
+		      /* Run a command found is possible.  */
+		      if (builtin->flags & BUILTIN_MENU)
+			{
+			  char *arg = skip_to (1, cmdline);
+			  (builtin->func) (arg, BUILTIN_MENU);
+			  errnum = 0;
+			}
+		      else
+			/* Ignored.  */
+			continue;
+		    }
+		  else
+		    {
+		      char *ptr = cmdline;
+		      
+		      state++;
+		      /* Copy config file data to config area.  */
+		      while ((config_entries[config_len++] = *ptr++) != 0)
+			;
+		    }
+		}
+	      
+	      if (state > 1)
+		{
+		  /* Finish the last entry.  */
+		  num_entries++;
+		  config_entries[config_len++] = 0;
+		}
+	      else
+		{
+		  menu_len = prev_menu_len;
+		  config_len = prev_config_len;
+		}
+	      
+	      menu_entries[menu_len++] = 0;
+	      config_entries[config_len++] = 0;
+	      grub_memmove (config_entries + config_len, menu_entries,
+			    menu_len);
+	      menu_entries = config_entries + config_len;
+
+	      /* Make sure that all fallback entries are valid.  */
+	      if (fallback_entryno >= 0)
+		{
+		  for (i = 0; i < MAX_FALLBACK_ENTRIES; i++)
+		    {
+		      if (fallback_entries[i] < 0)
+			break;
+		      if (fallback_entries[i] >= num_entries)
+			{
+			  grub_memmove (fallback_entries + i,
+					fallback_entries + i + 1,
+					((MAX_FALLBACK_ENTRIES - i - 1)
+					 * sizeof (int)));
+			  i--;
+			}
+		    }
+
+		  if (fallback_entries[0] < 0)
+		    fallback_entryno = -1;
+		}
+	      /* Check if the default entry is present. Otherwise reset
+		 it to fallback if fallback is valid, or to DEFAULT_ENTRY 
+		 if not.  */
+	      if (default_entry >= num_entries)
+		{
+		  if (fallback_entryno >= 0)
+		    {
+		      default_entry = fallback_entries[0];
+		      fallback_entryno++;
+		      if (fallback_entryno >= MAX_FALLBACK_ENTRIES
+			  || fallback_entries[fallback_entryno] < 0)
+			fallback_entryno = -1;
+		    }
+		  else
+		    default_entry = 0;
+		}
+	      
+	      if (is_preset)
+		close_preset_menu ();
+	      else
+		grub_close ();
+	    }
+	  while (is_preset);
+	}
+#ifndef SUPPORT_DISKLESS
+      __savedefault_once_reset();
+#endif
+      if (! num_entries)
+	{
+	  /* If no acceptable config file, goto command-line, starting
+	     heap from where the config entries would have been stored
+	     if there were any.  */
+	  enter_cmdline (config_entries, 1);
+	}
+      else
+	{
+	  /* Run menu interface.  */
+	  run_menu (menu_entries, config_entries, num_entries,
+		    menu_entries + menu_len, default_entry);
+	}
+    }
+}
diff -Naur grub-0.97/util/grub-install.in grub-0.97-suse/util/grub-install.in
--- grub-0.97/util/grub-install.in	2004-07-24 15:57:31.000000000 -0300
+++ grub-0.97-suse/util/grub-install.in	2006-09-09 17:00:12.000000000 -0300
@@ -27,7 +27,7 @@
 host_cpu=@host_cpu@
 host_os=@host_os@
 host_vendor=@host_vendor@
-pkglibdir=${libdir}/${PACKAGE}/${host_cpu}-${host_vendor}
+pkglibdir=${libdir}/${PACKAGE}/
 
 grub_shell=${sbindir}/grub
 grub_set_default=${sbindir}/grub-set-default
@@ -406,14 +406,19 @@
     exit 1
 fi
 
-# Copy the GRUB images to the GRUB directory.
-for file in ${grubdir}/stage1 ${grubdir}/stage2 ${grubdir}/*stage1_5; do
-    rm -f $file || exit 1
-done
-for file in \
-    ${pkglibdir}/stage1 ${pkglibdir}/stage2 ${pkglibdir}/*stage1_5; do
-    cp -f $file ${grubdir} || exit 1
-done
+# FHS says that /usr/share is used for architecture independent data,
+# so all stage-files are directly installed to /usr/lib/grub.
+# Therefor this part is no longer needed.
+# <--cut_here--> 
+## Copy the GRUB images to the GRUB directory.
+#for file in ${grubdir}/stage1 ${grubdir}/stage2 ${grubdir}/*stage1_5; do
+#    rm -f $file || exit 1
+#done
+#for file in \
+#    ${pkglibdir}/stage1 ${pkglibdir}/stage2 ${pkglibdir}/*stage1_5; do
+#    cp -f $file ${grubdir} || exit 1
+#done
+# <--uncut-->
 
 # Make a default file.
 ${grub_set_default} --root-directory=${rootdir} default
diff -Naur grub-0.97/util/grub-install.in~ grub-0.97-suse/util/grub-install.in~
--- grub-0.97/util/grub-install.in~	1969-12-31 21:00:00.000000000 -0300
+++ grub-0.97-suse/util/grub-install.in~	2004-07-24 15:57:31.000000000 -0300
@@ -0,0 +1,477 @@
+#! /bin/sh
+
+# Install GRUB on your drive.
+#   Copyright (C) 1999,2000,2001,2002,2003,2004 Free Software Foundation, Inc.
+#
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Initialize some variables.
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+sbindir=@sbindir@
+libdir=@libdir@
+PACKAGE=@PACKAGE@
+VERSION=@VERSION@
+host_cpu=@host_cpu@
+host_os=@host_os@
+host_vendor=@host_vendor@
+pkglibdir=${libdir}/${PACKAGE}/${host_cpu}-${host_vendor}
+
+grub_shell=${sbindir}/grub
+grub_set_default=${sbindir}/grub-set-default
+log_file=/tmp/grub-install.log.$$
+img_file=/tmp/grub-install.img.$$
+rootdir=
+grub_prefix=/boot/grub
+
+install_device=
+no_floppy=
+force_lba=
+recheck=no
+debug=no
+
+# look for secure tempfile creation wrappers on this platform
+if test -x /bin/tempfile; then
+    mklog="/bin/tempfile --prefix=grub"
+    mkimg="/bin/tempfile --prefix=grub"
+elif test -x /bin/mktemp; then
+    mklog="/bin/mktemp /tmp/grub-install.log.XXXXXX"
+    mkimg="/bin/mktemp /tmp/grub-install.img.XXXXXX"
+else
+    mklog=""
+    mkimg=""
+fi
+
+# Usage: usage
+# Print the usage.
+usage () {
+    cat <<EOF
+Usage: grub-install [OPTION] install_device
+Install GRUB on your drive.
+
+  -h, --help              print this message and exit
+  -v, --version           print the version information and exit
+  --root-directory=DIR    install GRUB images under the directory DIR
+                          instead of the root directory
+  --grub-shell=FILE       use FILE as the grub shell
+  --no-floppy             do not probe any floppy drive
+  --force-lba             force GRUB to use LBA mode even for a buggy
+                          BIOS
+  --recheck               probe a device map even if it already exists
+
+INSTALL_DEVICE can be a GRUB device name or a system device filename.
+
+grub-install copies GRUB images into the DIR/boot directory specfied by
+--root-directory, and uses the grub shell to install grub into the boot
+sector.
+
+Report bugs to <bug-grub@gnu.org>.
+EOF
+}
+
+# Usage: convert os_device
+# Convert an OS device to the corresponding GRUB drive.
+# This part is OS-specific.
+convert () {
+    # First, check if the device file exists.
+    if test -e "$1"; then
+	:
+    else
+	echo "$1: Not found or not a block device." 1>&2
+	exit 1
+    fi
+
+    # Break the device name into the disk part and the partition part.
+    case "$host_os" in
+    linux*)
+	tmp_disk=`echo "$1" | sed -e 's%\([sh]d[a-z]\)[0-9]*$%\1%' \
+				  -e 's%\(d[0-9]*\)p[0-9]*$%\1%' \
+				  -e 's%\(fd[0-9]*\)$%\1%' \
+				  -e 's%/part[0-9]*$%/disc%' \
+				  -e 's%\(c[0-7]d[0-9]*\).*$%\1%'`
+	tmp_part=`echo "$1" | sed -e 's%.*/[sh]d[a-z]\([0-9]*\)$%\1%' \
+				  -e 's%.*d[0-9]*p%%' \
+				  -e 's%.*/fd[0-9]*$%%' \
+				  -e 's%.*/floppy/[0-9]*$%%' \
+				  -e 's%.*/\(disc\|part\([0-9]*\)\)$%\2%' \
+				  -e 's%.*c[0-7]d[0-9]*p%%'`
+	;;
+    gnu*)
+	tmp_disk=`echo "$1" | sed 's%\([sh]d[0-9]*\).*%\1%'`
+	tmp_part=`echo "$1" | sed "s%$tmp_disk%%"` ;;
+    freebsd* | kfreebsd*-gnu)
+	tmp_disk=`echo "$1" | sed 's%r\{0,1\}\([saw]d[0-9]*\).*$%r\1%' \
+			    | sed 's%r\{0,1\}\(da[0-9]*\).*$%r\1%'`
+	tmp_part=`echo "$1" \
+	    | sed "s%.*/r\{0,1\}[saw]d[0-9]\(s[0-9]*[a-h]\)%\1%" \
+       	    | sed "s%.*/r\{0,1\}da[0-9]\(s[0-9]*[a-h]\)%\1%"`
+	;;
+    netbsd* | knetbsd*-gnu)
+	tmp_disk=`echo "$1" | sed 's%r\{0,1\}\([sw]d[0-9]*\).*$%r\1d%' \
+	    | sed 's%r\{0,1\}\(fd[0-9]*\).*$%r\1a%'`
+	tmp_part=`echo "$1" \
+	    | sed "s%.*/r\{0,1\}[sw]d[0-9]\([abe-p]\)%\1%"`
+	;;
+    *)
+	echo "grub-install does not support your OS yet." 1>&2
+	exit 1 ;;
+    esac
+
+    # Get the drive name.
+    tmp_drive=`grep -v '^#' $device_map | grep "$tmp_disk *$" \
+	| sed 's%.*\(([hf]d[0-9][a-g0-9,]*)\).*%\1%'`
+
+    # If not found, print an error message and exit.
+    if test "x$tmp_drive" = x; then
+	echo "$1 does not have any corresponding BIOS drive." 1>&2
+	exit 1
+    fi
+
+    if test "x$tmp_part" != x; then
+	# If a partition is specified, we need to translate it into the
+	# GRUB's syntax.
+	case "$host_os" in
+	linux*)
+	    echo "$tmp_drive" | sed "s%)$%,`expr $tmp_part - 1`)%" ;;
+	gnu*)
+	    if echo $tmp_part | grep "^s" >/dev/null; then
+		tmp_pc_slice=`echo $tmp_part \
+		    | sed "s%s\([0-9]*\)[a-g]*$%\1%"`
+		tmp_drive=`echo "$tmp_drive" \
+		    | sed "s%)%,\`expr "$tmp_pc_slice" - 1\`)%"`
+	    fi
+	    if echo $tmp_part | grep "[a-g]$" >/dev/null; then
+		tmp_bsd_partition=`echo "$tmp_part" \
+		    | sed "s%[^a-g]*\([a-g]\)$%\1%"`
+		tmp_drive=`echo "$tmp_drive" \
+		    | sed "s%)%,$tmp_bsd_partition)%"`
+	    fi
+	    echo "$tmp_drive" ;;
+	freebsd* | kfreebsd*-gnu)
+	    if echo $tmp_part | grep "^s" >/dev/null; then
+		tmp_pc_slice=`echo $tmp_part \
+		    | sed "s%s\([0-9]*\)[a-h]*$%\1%"`
+		tmp_drive=`echo "$tmp_drive" \
+		    | sed "s%)%,\`expr "$tmp_pc_slice" - 1\`)%"`
+	    fi
+	    if echo $tmp_part | grep "[a-h]$" >/dev/null; then
+		tmp_bsd_partition=`echo "$tmp_part" \
+		    | sed "s%s\{0,1\}[0-9]*\([a-h]\)$%\1%"`
+		tmp_drive=`echo "$tmp_drive" \
+		    | sed "s%)%,$tmp_bsd_partition)%"`
+	    fi
+	    echo "$tmp_drive" ;;
+	netbsd* | knetbsd*-gnu)
+	    if echo $tmp_part | grep "^[abe-p]$" >/dev/null; then
+		tmp_bsd_partition=`echo "$tmp_part" \
+		    | sed "s%\([a-p]\)$%\1%"`
+		tmp_drive=`echo "$tmp_drive" \
+		    | sed "s%)%,$tmp_bsd_partition)%"`
+	    fi
+	    echo "$tmp_drive" ;;
+	esac
+    else
+	# If no partition is specified, just print the drive name.
+	echo "$tmp_drive"
+    fi
+}
+
+# Usage: resolve_symlink file
+# Find the real file/device that file points at
+resolve_symlink () {
+	tmp_fname=$1
+	# Resolve symlinks
+	while test -L $tmp_fname; do
+		tmp_new_fname=`ls -al $tmp_fname | sed -n 's%.*-> \(.*\)%\1%p'`
+		if test -z "$tmp_new_fname"; then
+			echo "Unrecognized ls output" 2>&1
+			exit 1
+		fi
+
+		# Convert relative symlinks
+		case $tmp_new_fname in
+			/*) tmp_fname="$tmp_new_fname"
+			;;
+			*) tmp_fname="`echo $tmp_fname | sed 's%/[^/]*$%%'`/$tmp_new_fname"
+			;;
+		esac
+	done
+	echo "$tmp_fname"
+}
+
+# Usage: find_device file
+# Find block device on which the file resides.
+find_device () {
+    # For now, this uses the program `df' to get the device name, but is
+    # this really portable?
+    tmp_fname=`df $1/ | sed -n 's%.*\(/dev/[^ 	]*\).*%\1%p'`
+
+    if test -z "$tmp_fname"; then
+	echo "Could not find device for $1" 2>&1
+	exit 1
+    fi
+
+	tmp_fname=`resolve_symlink $tmp_fname`
+
+    echo "$tmp_fname"
+}
+
+# Check the arguments.
+for option in "$@"; do
+    case "$option" in
+    -h | --help)
+	usage
+	exit 0 ;;
+    -v | --version)
+	echo "grub-install (GNU GRUB ${VERSION})"
+	exit 0 ;;
+    --root-directory=*)
+	rootdir=`echo "$option" | sed 's/--root-directory=//'` ;;
+    --grub-shell=*)
+	grub_shell=`echo "$option" | sed 's/--grub-shell=//'` ;;
+    --no-floppy)
+	no_floppy="--no-floppy" ;;
+    --force-lba)
+	force_lba="--force-lba" ;;
+    --recheck)
+	recheck=yes ;;
+    # This is an undocumented feature...
+    --debug)
+	debug=yes ;;
+    -*)
+	echo "Unrecognized option \`$option'" 1>&2
+	usage
+	exit 1
+	;;
+    *)
+	if test "x$install_device" != x; then
+	    echo "More than one install_devices?" 1>&2
+	    usage
+	    exit 1
+	fi
+	install_device="${option}" ;;
+    esac
+done
+
+if test "x$install_device" = x; then
+    echo "install_device not specified." 1>&2
+    usage
+    exit 1
+fi
+
+# If the debugging feature is enabled, print commands.
+if test $debug = yes; then
+    set -x
+fi
+
+# Initialize these directories here, since ROOTDIR was initialized.
+case "$host_os" in
+netbsd* | openbsd*)
+    # Because /boot is used for the boot block in NetBSD and OpenBSD, use /grub
+    # instead of /boot/grub.
+    grub_prefix=/grub
+    bootdir=${rootdir}
+    ;;
+*)
+    # Use /boot/grub by default.
+    bootdir=${rootdir}/boot
+    ;;
+esac
+
+grubdir=${bootdir}/grub
+device_map=${grubdir}/device.map
+
+# Check if GRUB is installed.
+# This is necessary, because the user can specify "grub --read-only".
+set $grub_shell dummy
+if test -f "$1"; then
+    :
+else
+    echo "$1: Not found." 1>&2
+    exit 1
+fi
+
+if test -f "$pkglibdir/stage1"; then
+    :
+else
+    echo "${pkglibdir}/stage1: Not found." 1>&2
+    exit 1
+fi
+
+if test -f "$pkglibdir/stage2"; then
+    :
+else
+    echo "${pkglibdir}/stage2: Not found." 1>&2
+    exit 1
+fi
+
+# Don't check for *stage1_5, because it is not fatal even if any
+# Stage 1.5 does not exist.
+
+# Create the GRUB directory if it is not present.
+test -d "$bootdir" || mkdir "$bootdir" || exit 1
+test -d "$grubdir" || mkdir "$grubdir" || exit 1
+
+# If --recheck is specified, remove the device map, if present.
+if test $recheck = yes; then
+    rm -f $device_map
+fi
+
+# Create the device map file if it is not present.
+if test -f "$device_map"; then
+    :
+else
+    # Create a safe temporary file.
+    test -n "$mklog" && log_file=`$mklog`
+
+    $grub_shell --batch $no_floppy --device-map=$device_map <<EOF >$log_file
+quit
+EOF
+    if grep "Error [0-9]*: " $log_file >/dev/null; then
+	cat $log_file 1>&2
+	exit 1
+    fi
+
+    rm -f $log_file
+fi
+
+# Make sure that there is no duplicated entry.
+tmp=`sed -n '/^([fh]d[0-9]*)/s/\(^(.*)\).*/\1/p' $device_map \
+    | sort | uniq -d | sed -n 1p`
+if test -n "$tmp"; then
+    echo "The drive $tmp is defined multiple times in the device map $device_map" 1>&2
+    exit 1
+fi
+
+# Check for INSTALL_DEVICE.
+case "$install_device" in
+/dev/*)
+    install_device=`resolve_symlink "$install_device"`
+    install_drive=`convert "$install_device"`
+    # I don't know why, but some shells wouldn't die if exit is
+    # called in a function.
+    if test "x$install_drive" = x; then
+	exit 1
+    fi ;;
+\([hf]d[0-9]*\))
+    install_drive="$install_device" ;;
+[hf]d[0-9]*)
+    # The GRUB format with no parenthesis.
+    install_drive="($install_device)" ;;
+*)
+    echo "Format of install_device not recognized." 1>&2
+    usage
+    exit 1 ;;
+esac
+
+# Get the root drive.
+root_device=`find_device ${rootdir}`
+bootdir_device=`find_device ${bootdir}`
+
+# Check if the boot directory is in the same device as the root directory.
+if test "x$root_device" != "x$bootdir_device"; then
+    # Perhaps the user has a separate boot partition.
+    root_device=$bootdir_device
+    grub_prefix="/grub"
+fi
+
+# Convert the root device to a GRUB drive.
+root_drive=`convert "$root_device"`
+if test "x$root_drive" = x; then
+    exit 1
+fi
+
+# Check if the root directory exists in the same device as the grub
+# directory.
+grubdir_device=`find_device ${grubdir}`
+
+if test "x$grubdir_device" != "x$root_device"; then
+    # For now, cannot deal with this situation.
+    cat <<EOF 1>&2
+You must set the root directory by the option --root-directory, because
+$grubdir does not exist in the root device $root_device.
+EOF
+    exit 1
+fi
+
+# Copy the GRUB images to the GRUB directory.
+for file in ${grubdir}/stage1 ${grubdir}/stage2 ${grubdir}/*stage1_5; do
+    rm -f $file || exit 1
+done
+for file in \
+    ${pkglibdir}/stage1 ${pkglibdir}/stage2 ${pkglibdir}/*stage1_5; do
+    cp -f $file ${grubdir} || exit 1
+done
+
+# Make a default file.
+${grub_set_default} --root-directory=${rootdir} default
+
+# Make sure that GRUB reads the same images as the host OS.
+test -n "$mkimg" && img_file=`$mkimg`
+test -n "$mklog" && log_file=`$mklog`
+
+for file in ${grubdir}/stage1 ${grubdir}/stage2 ${grubdir}/*stage1_5; do
+    count=5
+    tmp=`echo $file | sed "s|^${grubdir}|${grub_prefix}|"`
+    while test $count -gt 0; do
+	$grub_shell --batch $no_floppy --device-map=$device_map <<EOF >$log_file
+dump ${root_drive}${tmp} ${img_file}
+quit
+EOF
+	if grep "Error [0-9]*: " $log_file >/dev/null; then
+	    :
+	elif cmp $file $img_file >/dev/null; then
+	    break
+	fi
+	sleep 1
+	count=`expr $count - 1`    
+    done
+    if test $count -eq 0; then
+	echo "The file $file not read correctly." 1>&2
+	exit 1
+    fi
+done
+
+rm -f $img_file
+rm -f $log_file
+
+# Create a safe temporary file.
+test -n "$mklog" && log_file=`$mklog`
+
+# Now perform the installation.
+$grub_shell --batch $no_floppy --device-map=$device_map <<EOF >$log_file
+root $root_drive
+setup $force_lba --stage2=$grubdir/stage2 --prefix=$grub_prefix $install_drive
+quit
+EOF
+
+if grep "Error [0-9]*: " $log_file >/dev/null || test $debug = yes; then
+    cat $log_file 1>&2
+    exit 1
+fi
+
+rm -f $log_file
+
+# Prompt the user to check if the device map is correct.
+echo "Installation finished. No error reported."
+echo "This is the contents of the device map $device_map."
+echo "Check if this is correct or not. If any of the lines is incorrect,"
+echo "fix it and re-run the script \`grub-install'."
+echo
+
+cat $device_map
+
+# Bye.
+exit 0
diff -Naur grub-0.97/util/grub-md5-crypt.in grub-0.97-suse/util/grub-md5-crypt.in
--- grub-0.97/util/grub-md5-crypt.in	2003-07-09 08:45:51.000000000 -0300
+++ grub-0.97-suse/util/grub-md5-crypt.in	2006-09-09 17:00:12.000000000 -0300
@@ -88,7 +88,7 @@
 fi
 
 # Run the grub shell.
-$grub_shell --batch --device-map=/dev/null <<EOF \
+$grub_shell --batch <<EOF \
     | grep "^Encrypted: " | sed 's/^Encrypted: //'
 md5crypt
 $password
diff -Naur grub-0.97/util/mbchk.c grub-0.97-suse/util/mbchk.c
--- grub-0.97/util/mbchk.c	2003-10-19 13:36:45.000000000 -0200
+++ grub-0.97-suse/util/mbchk.c	2006-09-09 17:00:12.000000000 -0300
@@ -59,7 +59,9 @@
   int i;
   char buf[8192];
 
-  if (fread (buf, 1, 8192, fp) < 0)
+  fread (buf, 1, 8192, fp);
+  
+  if (ferror(fp))
     {
       fprintf (stderr, "%s: Read error.\n", filename);
       return 0;
